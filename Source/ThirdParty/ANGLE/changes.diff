diff --git a/doc/ExtensionSupport.md b/doc/ExtensionSupport.md
index db98abc0e7318a935b920c8f6d79c5a9950272f1..94728c3d214fa3e1aa4ffade3f711604aaa71daf 100644
--- a/doc/ExtensionSupport.md
+++ b/doc/ExtensionSupport.md
@@ -231,6 +231,7 @@ using data from registry_xml.py and gl.xml.
 | [GL_CHROMIUM_copy_compressed_texture](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/CHROMIUM_copy_compressed_texture.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_CHROMIUM_copy_texture](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/CHROMIUM_copy_texture.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_copy_texture_3d](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_copy_texture_3d.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
+| [GL_WEBKIT_explicit_resolve_target](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/WEBKIT_explicit_resolve_target.txt) |  |  |  |  |  |  |  |
 | [GL_CHROMIUM_framebuffer_mixed_samples](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/CHROMIUM_framebuffer_mixed_samples.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_framebuffer_multisample](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_framebuffer_multisample.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_get_image](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_get_image.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
@@ -267,6 +268,7 @@ using data from registry_xml.py and gl.xml.
 | [GL_ANGLE_texture_external_update](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_external_update.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_texture_multisample](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_multisample.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_texture_rectangle](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_rectangle.txt) |  |  |  |  |  |  |  |
+| [GL_ANGLE_variable_rasterization_rate_metal](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_variable_rasterization_rate_metal.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_vulkan_image](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_vulkan_image.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_webgl_compatibility](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_webgl_compatibility.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_yuv_internal_format](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_yuv_internal_format.txt) | &#x2714; |  | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
diff --git a/include/GLES2/gl2ext_angle.h b/include/GLES2/gl2ext_angle.h
index 46b52b05a9f490f1ea686d1915aef7508878d77a..7ac187ffe7048404f7f3fd16bb93cfe74f4b3eed 100644
--- a/include/GLES2/gl2ext_angle.h
+++ b/include/GLES2/gl2ext_angle.h
@@ -743,5 +743,23 @@ GL_APICALL void GL_APIENTRY glGetPointervANGLE (GLenum pname, void **params);
 #endif
 #endif /* GL_ANGLE_blob_cache */
 
+#ifndef GL_WEBKIT_explicit_resolve_target
+typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC) (GLenum, GLenum, GLenum, GLuint);
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glFramebufferResolveRenderbufferWEBKIT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+#endif
+#endif /* GL_WEBKIT_explicit_resolve_target */
+
+#ifndef GL_ANGLE_variable_rasterization_rate_metal
+#define GL_ANGLE_variable_rasterization_rate_metal 1
+
+#define GL_VARIABLE_RASTERIZATION_RATE_ANGLE            0x96BC
+#define GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE   0x96BD
+typedef void *GLMTLRasterizationRateMapANGLE;
+typedef void (GL_APIENTRYP PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC) (GLuint, GLMTLRasterizationRateMapANGLE);
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glBindMetalRasterizationRateMapANGLE(GLuint framebuffer, GLMTLRasterizationRateMapANGLE map);
+#endif
+#endif /* GL_ANGLE_variable_rasterization_rate_metal */
 
 #endif  // INCLUDE_GLES2_GL2EXT_ANGLE_H_
diff --git a/include/GLSLANG/ShaderLang.h b/include/GLSLANG/ShaderLang.h
index 8bab63f3cc4e0f01442f23f5e05a59c4042c3da7..521ab8d1603cd471801cd61c80e3925f5e567df0 100644
--- a/include/GLSLANG/ShaderLang.h
+++ b/include/GLSLANG/ShaderLang.h
@@ -26,7 +26,7 @@
 
 // Version number for shader translation API.
 // It is incremented every time the API changes.
-#define ANGLE_SH_VERSION 375
+#define ANGLE_SH_VERSION 376
 
 enum ShShaderSpec
 {
@@ -477,6 +477,9 @@ struct ShCompileOptions
     // Whether inactive shader variables from the output.
     uint64_t removeInactiveVariables : 1;
 
+    // Ensure all loops execute side-effects or terminate.
+    uint64_t ensureLoopForwardProgress : 1;
+
     ShCompileOptionsMetal metal;
     ShPixelLocalStorageOptions pls;
 };
diff --git a/include/platform/autogen/FeaturesMtl_autogen.h b/include/platform/autogen/FeaturesMtl_autogen.h
index 61c9f3ebed8fdd2ea459cc91772ab259819a96a6..89b77a90bd1d894c64369f689d07d12c95c5c24a 100644
--- a/include/platform/autogen/FeaturesMtl_autogen.h
+++ b/include/platform/autogen/FeaturesMtl_autogen.h
@@ -74,6 +74,12 @@ struct FeaturesMtl : FeatureSetBase
         &members,
     };
 
+    FeatureInfo hasVariableRasterizationRate = {
+        "hasVariableRasterizationRate",
+        FeatureCategory::MetalFeatures,
+        &members,
+    };
+
     FeatureInfo allowInlineConstVertexData = {
         "allowInlineConstVertexData",
         FeatureCategory::MetalFeatures,
@@ -344,6 +350,12 @@ struct FeaturesMtl : FeatureSetBase
         &members,
     };
 
+    FeatureInfo ensureLoopForwardProgress = {
+        "ensureLoopForwardProgress",
+        FeatureCategory::MetalFeatures,
+        &members,
+    };
+
 };
 
 inline FeaturesMtl::FeaturesMtl()  = default;
diff --git a/include/platform/mtl_features.json b/include/platform/mtl_features.json
index e3b71dc8efb87b223cdee9e93a0b29f91c482fce..4c2b83c236c07f77008cc21a13bdb0932734299a 100644
--- a/include/platform/mtl_features.json
+++ b/include/platform/mtl_features.json
@@ -70,6 +70,13 @@
                 "The renderer supports MTL(Shared)Event"
             ]
         },
+        {
+            "name": "has_variable_rasterization_rate",
+            "category": "Features",
+            "description": [
+                "The renderer supports variable rasterization rate"
+            ]
+        },
         {
             "name": "allow_inline_const_vertex_data",
             "category": "Features",
@@ -418,6 +425,14 @@
                 "having side effects and not optimized out."
             ],
             "issue": "http://crbug.com/1513738"
+        },
+        {
+            "name": "ensure_loop_forward_progress",
+            "category": "Features",
+            "description": [
+                "Inject statements into loop bodies when needed to ensure infinite loops are optimized out."
+            ],
+            "issue": "http://crbug.com/1513738"
         }
     ]
 }
diff --git a/scripts/code_generation_hashes/ANGLE_shader_preprocessor.json b/scripts/code_generation_hashes/ANGLE_shader_preprocessor.json
index 4bac11cb1b35587b23e423aafe68515044ba7bd6..1785c364eeb57ab08b318d7b8ac978af67f554e8 100644
--- a/scripts/code_generation_hashes/ANGLE_shader_preprocessor.json
+++ b/scripts/code_generation_hashes/ANGLE_shader_preprocessor.json
@@ -8,9 +8,9 @@
   "src/compiler/preprocessor/preprocessor.y":
     "770be78579281bd332f2277dcd3be7d3",
   "src/compiler/preprocessor/preprocessor_lex_autogen.cpp":
-    "39caf992f2baeb3de0198a216ac71951",
+    "6948eb67eb0dad47de9b7baf35ff084d",
   "src/compiler/preprocessor/preprocessor_tab_autogen.cpp":
-    "3f39a629435b363bb4b9d24cecf2b13d",
+    "4400616dc48b5aa8489814600801a544",
   "tools/flex-bison/linux/bison.sha1":
     "dfc9209e0c76eddd9bed0601c6c189e5",
   "tools/flex-bison/linux/flex.sha1":
diff --git a/scripts/code_generation_hashes/ANGLE_shader_translator.json b/scripts/code_generation_hashes/ANGLE_shader_translator.json
index 1250245f688ce02c7c7d8812cbf56a49ce1b318b..31a7ac20c360a33efc277ef82e5e1b9a2a8cfe94 100644
--- a/scripts/code_generation_hashes/ANGLE_shader_translator.json
+++ b/scripts/code_generation_hashes/ANGLE_shader_translator.json
@@ -8,7 +8,7 @@
   "src/compiler/translator/glslang.y":
     "53e0a7272e498302d2b08726397bddd3",
   "src/compiler/translator/glslang_lex_autogen.cpp":
-    "b48d7d9013cbf0596a5792b00522c024",
+    "fe9623ca5a79de4699cc44745f2b1925",
   "src/compiler/translator/glslang_tab_autogen.cpp":
     "b3a90dde9dea633233d929586571a487",
   "src/compiler/translator/glslang_tab_autogen.h":
diff --git a/scripts/code_generation_hashes/Extension_files.json b/scripts/code_generation_hashes/Extension_files.json
index c7c543f464e0fb12fc9d7cfe383d1e74cf5c2335..13d529d015cb1438c0884ba004f53d96ad60f27f 100644
--- a/scripts/code_generation_hashes/Extension_files.json
+++ b/scripts/code_generation_hashes/Extension_files.json
@@ -1,6 +1,6 @@
 {
   "doc/ExtensionSupport.md":
-    "f00f01f5e093379877c2bc37a91bac43",
+    "c19bb92e6cf20aaf66f8c14445acf5a7",
   "scripts/egl_angle_ext.xml":
     "8389749098fae1d5c832a06b5be51dc1",
   "scripts/extension_data/intel_630_linux.json":
@@ -20,15 +20,15 @@
   "scripts/extension_data/swiftshader_win10_gles1.json":
     "bea8e2106d62e1ea0e8938f150865a37",
   "scripts/gl_angle_ext.xml":
-    "da4ecccdd77635f1b0e9d4664f856706",
+    "2cba159af592da788a15449eae941cb4",
   "scripts/registry_xml.py":
-    "08a71b46d1660385ac20ec90f972655e",
+    "bb960e9dd67776385b3300528a499988",
   "src/libANGLE/gen_extensions.py":
     "dc4727460d1ece9f98a2ae47bf15ddb3",
   "src/libANGLE/gles_extensions_autogen.cpp":
-    "97df979b59ca309ceb3757ef398c4bdf",
+    "ec25889ce206bdfdc4306e889d44a564",
   "src/libANGLE/gles_extensions_autogen.h":
-    "4484fe13bac680f32f0ae7b2116d8f40",
+    "0d6178e8fae3d56bf0e8f0abd13ce8e7",
   "third_party/EGL-Registry/src/api/egl.xml":
     "2056d54ea07156f1988ca1366bdee21a",
   "third_party/OpenCL-Docs/src/xml/cl.xml":
diff --git a/scripts/code_generation_hashes/GL_EGL_WGL_loader.json b/scripts/code_generation_hashes/GL_EGL_WGL_loader.json
index 92ad715a318325426026029da5a51bba3f4efdee..7f2335828ecd7c987d3736235827e0869c885bd1 100644
--- a/scripts/code_generation_hashes/GL_EGL_WGL_loader.json
+++ b/scripts/code_generation_hashes/GL_EGL_WGL_loader.json
@@ -4,9 +4,9 @@
   "scripts/generate_loader.py":
     "93c78a8d11323fa311fed5118fbcf083",
   "scripts/gl_angle_ext.xml":
-    "da4ecccdd77635f1b0e9d4664f856706",
+    "2cba159af592da788a15449eae941cb4",
   "scripts/registry_xml.py":
-    "08a71b46d1660385ac20ec90f972655e",
+    "bb960e9dd67776385b3300528a499988",
   "src/libEGL/egl_loader_autogen.cpp":
     "2aca2a57c51fc2b1c7e1da0a7ccf6107",
   "src/libEGL/egl_loader_autogen.h":
@@ -26,17 +26,17 @@
   "util/capture/trace_egl_loader_autogen.h":
     "9adc81af729078b16b36647f02401342",
   "util/capture/trace_gles_loader_autogen.cpp":
-    "81242937e728987adc15e39c0b007ff5",
+    "7bdf9fdb924b47970e2217ab5719ac70",
   "util/capture/trace_gles_loader_autogen.h":
-    "d369496980c96dd58d2a00fd40386b08",
+    "1048e92fc4693a7b7f3bd85995e5c2fa",
   "util/egl_loader_autogen.cpp":
     "ae6abfc6c2c0a997ad59258dfc0339ce",
   "util/egl_loader_autogen.h":
     "ea5f73048616a6fc80eaa7e93ef5f0ce",
   "util/gles_loader_autogen.cpp":
-    "33c532e70695584adb587d6c3e55789c",
+    "ace17d9f56aca3e242cc1382b525cc10",
   "util/gles_loader_autogen.h":
-    "09a4e0c77d71c01b44caa74b4da72eff",
+    "e24dadbddb4a6effbce8cb0749f69d08",
   "util/windows/wgl_loader_autogen.cpp":
     "373b062587eab8a163121255f54597dc",
   "util/windows/wgl_loader_autogen.h":
diff --git a/scripts/code_generation_hashes/GL_EGL_entry_points.json b/scripts/code_generation_hashes/GL_EGL_entry_points.json
index f6feccc2702380bc71942972d85f5dc70864de26..799b7dba824483450e68fa72c2e6ce65ff027699 100644
--- a/scripts/code_generation_hashes/GL_EGL_entry_points.json
+++ b/scripts/code_generation_hashes/GL_EGL_entry_points.json
@@ -4,21 +4,21 @@
   "scripts/entry_point_packed_egl_enums.json":
     "a72ae855c6b403912103b519139951a1",
   "scripts/entry_point_packed_gl_enums.json":
-    "57a3a729fd25032bc336f4b6a55bc238",
+    "c1ac98d815f33bffc4ecd71e6dc1e992",
   "scripts/generate_entry_points.py":
-    "f85b51def09831d0dae3fd77b55a4ed9",
+    "bebf1936c62ecce1f261d2c062092aab",
   "scripts/gl_angle_ext.xml":
-    "da4ecccdd77635f1b0e9d4664f856706",
+    "2cba159af592da788a15449eae941cb4",
   "scripts/registry_xml.py":
-    "08a71b46d1660385ac20ec90f972655e",
+    "bb960e9dd67776385b3300528a499988",
   "src/common/entry_points_enum_autogen.cpp":
-    "9c99201dcef2f7fac313b7c5dfcfb072",
+    "79a7c3181b4bf01219af4956199b3246",
   "src/common/entry_points_enum_autogen.h":
-    "5e4c0ec4ae6c17bf499c1ff3c95c7858",
+    "3d0f71fb91aad544736544dd02f3969f",
   "src/common/frame_capture_utils_autogen.cpp":
-    "6cc2d56a399e8b3ceb6bffac5584a8e2",
+    "48a6f508b749358f450593f0c7b5e561",
   "src/common/frame_capture_utils_autogen.h":
-    "62459bf6cbafd153f28b549bdef2167e",
+    "06574c1611a06eb990cead3c450bb21e",
   "src/libANGLE/Context_gles_1_0_autogen.h":
     "cb1cfe652972d301a5a98b4f233fcc4f",
   "src/libANGLE/Context_gles_2_0_autogen.h":
@@ -30,7 +30,7 @@
   "src/libANGLE/Context_gles_3_2_autogen.h":
     "cf9900e0067812fc6773e8ae4664da33",
   "src/libANGLE/Context_gles_ext_autogen.h":
-    "cc4d3742bf9a5484e7a455e6ad81000f",
+    "063d3ea00ea5cd2ab12120dadc39aad8",
   "src/libANGLE/capture/capture_cl_autogen.cpp":
     "fa6bf9530e2f1176decc6ceeaf7e3280",
   "src/libANGLE/capture/capture_cl_autogen.h":
@@ -60,9 +60,9 @@
   "src/libANGLE/capture/capture_gles_3_2_autogen.h":
     "5e956a19d9e3ba697fb05049c4be9936",
   "src/libANGLE/capture/capture_gles_ext_autogen.cpp":
-    "bc9dee0a76e1b7026e6f01178850844b",
+    "44cdf717e3ac3deb6099e0669193b306",
   "src/libANGLE/capture/capture_gles_ext_autogen.h":
-    "76c7c54392e667abd3f2940aceb8d603",
+    "45930d3ab4d2e0c803d85f12829a4e32",
   "src/libANGLE/context_private_call_autogen.h":
     "faa8cc9fc573c8f138d6c057a50467be",
   "src/libANGLE/validationCL_autogen.h":
@@ -80,7 +80,7 @@
   "src/libANGLE/validationES3_autogen.h":
     "29b3f384a582a4ffd45a898a481839fd",
   "src/libANGLE/validationESEXT_autogen.h":
-    "781ebd105c6a8e4b5cd5e1a5866225cc",
+    "6320e3ee6560d9f24583049b32182e7d",
   "src/libEGL/libEGL_autogen.cpp":
     "77d82db4a45c2f08108929ef7fe8b698",
   "src/libEGL/libEGL_autogen.def":
@@ -130,19 +130,19 @@
   "src/libGLESv2/entry_points_gles_3_2_autogen.h":
     "647f932a299cdb4726b60bbba059f0d2",
   "src/libGLESv2/entry_points_gles_ext_autogen.cpp":
-    "6824f834ea2c98038845a3b02de3ff22",
+    "8bad0d7070c50ce52f00c4521084eede",
   "src/libGLESv2/entry_points_gles_ext_autogen.h":
-    "4f0d8de63bcdaad4ed1ebd74413e184f",
+    "588f8d9c4725986da8fcf10f99d73a0c",
   "src/libGLESv2/libGLESv2_autogen.cpp":
-    "1b365900227d3d5ad79875166ad56f85",
+    "368356e8ac959f152ea232db2b8328d7",
   "src/libGLESv2/libGLESv2_autogen.def":
-    "3ee8a29c2476a467bca2389be6790887",
+    "22006d037748b4e32b993d97140eba58",
   "src/libGLESv2/libGLESv2_no_capture_autogen.def":
-    "35f5e283170cdea6df3b71fc0f14e93a",
+    "7742008113a15adda091ac5b9348c0bc",
   "src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def":
-    "16cfdf6a6de70cf38f0f5140fa23575a",
+    "7b061a4dbe641e246ed0619e392df095",
   "src/libGLESv2/libGLESv2_with_capture_autogen.def":
-    "6b0d27e68d3648cb09d11ae8f53b03c7",
+    "15d32b11d868bb729d42b42314e9612e",
   "src/libOpenCL/libOpenCL_autogen.cpp":
     "10849978c910dc1af5dd4f0c815d1581",
   "third_party/EGL-Registry/src/api/egl.xml":
@@ -156,5 +156,5 @@
   "third_party/OpenGL-Registry/src/xml/wgl.xml":
     "eae784bf4d1b983a42af5671b140b7c4",
   "util/capture/frame_capture_replay_autogen.cpp":
-    "52474be1085612f2a54f7bed883bf882"
+    "2a38eba59a0489ab45e603f616ffc6bd"
 }
diff --git a/scripts/code_generation_hashes/GLenum_value_to_string_map.json b/scripts/code_generation_hashes/GLenum_value_to_string_map.json
index 4cf91d7375c0e7a606097939a8c294dd1425ac3a..fb28808207faaf66e79fe09e9c8a4e3feb275f5b 100644
--- a/scripts/code_generation_hashes/GLenum_value_to_string_map.json
+++ b/scripts/code_generation_hashes/GLenum_value_to_string_map.json
@@ -2,11 +2,11 @@
   "scripts/gen_gl_enum_utils.py":
     "3ec60ab12923f4825b57fe183f2152b2",
   "scripts/gl_angle_ext.xml":
-    "da4ecccdd77635f1b0e9d4664f856706",
+    "2cba159af592da788a15449eae941cb4",
   "scripts/registry_xml.py":
-    "08a71b46d1660385ac20ec90f972655e",
+    "bb960e9dd67776385b3300528a499988",
   "src/common/gl_enum_utils_autogen.cpp":
-    "4d10717a63e081079dda1723d370d22d",
+    "dcbb1ecc28a9c354532ac4eb04d905e3",
   "src/common/gl_enum_utils_autogen.h":
     "51f421ef562d771b3cded2ad207d0fd9",
   "third_party/OpenGL-Registry/src/xml/gl.xml":
diff --git a/scripts/code_generation_hashes/Static_builtins.json b/scripts/code_generation_hashes/Static_builtins.json
index a9c4c00f310983d0eea0ff81fd9b0caad947d27e..ba7d5f2fd442660726a21b8b413f649e052f3b11 100644
--- a/scripts/code_generation_hashes/Static_builtins.json
+++ b/scripts/code_generation_hashes/Static_builtins.json
@@ -1,20 +1,20 @@
 {
   "src/compiler/translator/ImmutableString_autogen.cpp":
-    "d0f7abe7524a893ea9b2c4bae35d7b77",
+    "2d1c367a827d010569158a833fe43838",
   "src/compiler/translator/Operator_autogen.h":
-    "6f763e278e7f891b9c9c690204ecdb1d",
+    "5bf164c0e357df73ab727dd14346f05e",
   "src/compiler/translator/SymbolTable_autogen.cpp":
-    "e68d3f13b5ffa93c25613b9002e923a8",
+    "246d64fb05b51b57a9a58c6d615cb4f8",
   "src/compiler/translator/SymbolTable_autogen.h":
     "36d32dd6e9e1111a1a04d3e64fddf8d0",
   "src/compiler/translator/builtin_function_declarations.txt":
-    "03ac25e00deb51acfa0799c76b8bcb03",
+    "df755020e057b626d8a8412bb481bea8",
   "src/compiler/translator/builtin_variables.json":
     "e1995c9828b7943e47dc2846c2d071c0",
   "src/compiler/translator/gen_builtin_symbols.py":
     "0c435afdae31eea13a17d72e059ee5b4",
   "src/compiler/translator/tree_util/BuiltIn_autogen.h":
-    "bb1654e42df989002e6a746e1c418a43",
+    "17d9d37a3683b9f2ceb0cb4cc1dd5b75",
   "src/tests/compiler_tests/ImmutableString_test_autogen.cpp":
-    "8ae82aec0edb5622cb4b9700eb2faed3"
+    "b17e626af5a4dc41bb5ec8de827012bf"
 }
diff --git a/scripts/code_generation_hashes/interpreter_utils.json b/scripts/code_generation_hashes/interpreter_utils.json
index 54e8973b9d9ed631a5c3b4f44a2243ffa8ff8405..db92150c0b4ededed0f35ce613aec4657c130039 100644
--- a/scripts/code_generation_hashes/interpreter_utils.json
+++ b/scripts/code_generation_hashes/interpreter_utils.json
@@ -4,9 +4,9 @@
   "scripts/gen_interpreter_utils.py":
     "c525953cf6fb2294d489e9c22cbabdb8",
   "scripts/gl_angle_ext.xml":
-    "da4ecccdd77635f1b0e9d4664f856706",
+    "2cba159af592da788a15449eae941cb4",
   "scripts/registry_xml.py":
-    "08a71b46d1660385ac20ec90f972655e",
+    "bb960e9dd67776385b3300528a499988",
   "third_party/EGL-Registry/src/api/egl.xml":
     "2056d54ea07156f1988ca1366bdee21a",
   "third_party/OpenCL-Docs/src/xml/cl.xml":
@@ -20,5 +20,5 @@
   "util/capture/trace_fixture.h":
     "4a0c7fde0a41217d377a49c2499b2e2a",
   "util/capture/trace_interpreter_autogen.cpp":
-    "2850abe17933505c15506aac43fc804f"
+    "312aa0f107933fb8a617aba0cb38476a"
 }
diff --git a/scripts/code_generation_hashes/proc_table.json b/scripts/code_generation_hashes/proc_table.json
index a46a47321d28e06da2e73c4a0f48c4c6f081134a..9d07b6f52463e540b566b001d0532891836b7fa3 100644
--- a/scripts/code_generation_hashes/proc_table.json
+++ b/scripts/code_generation_hashes/proc_table.json
@@ -4,11 +4,11 @@
   "scripts/gen_proc_table.py":
     "23ebf460dda78d2c21625e0d41d3cb97",
   "scripts/gl_angle_ext.xml":
-    "da4ecccdd77635f1b0e9d4664f856706",
+    "2cba159af592da788a15449eae941cb4",
   "scripts/registry_xml.py":
-    "08a71b46d1660385ac20ec90f972655e",
+    "bb960e9dd67776385b3300528a499988",
   "src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp":
-    "0509998531cd46780dda07f371be3277",
+    "33d0ac7beba20069fa4a90db6359b695",
   "src/libGLESv2/proc_table_cl_autogen.cpp":
     "ed003b0f041aaaa35b67d3fe07e61f91",
   "src/libOpenCL/libOpenCL_autogen.map":
diff --git a/scripts/entry_point_packed_gl_enums.json b/scripts/entry_point_packed_gl_enums.json
index b258660ba4367032e592ab8d6397ee5edca0a661..fe961d3125259b015d3d005a6d45443ede3131bc 100644
--- a/scripts/entry_point_packed_gl_enums.json
+++ b/scripts/entry_point_packed_gl_enums.json
@@ -440,6 +440,9 @@
     "glFramebufferFoveationParameters": {
         "framebuffer": "FramebufferID"
     },
+    "glFramebufferResolveRenderbufferWEBKIT": {
+        "renderbuffer": "RenderbufferID"
+    },
     "glFramebufferRenderbuffer": {
         "renderbuffer": "RenderbufferID"
     },
diff --git a/scripts/generate_entry_points.py b/scripts/generate_entry_points.py
index ffdbb309936a8686ac7b33dc865d42fa3919b1ff..58487e7006f9734621239084f24f400f6e1f9092 100755
--- a/scripts/generate_entry_points.py
+++ b/scripts/generate_entry_points.py
@@ -999,6 +999,7 @@ FORMAT_DICT = {
     "GLint": "%d",
     "GLintptr": UNSIGNED_LONG_LONG_FORMAT,
     "GLSETBLOBPROCANGLE": POINTER_FORMAT,
+    "GLMTLRasterizationRateMapANGLE": POINTER_FORMAT,
     "GLshort": "%d",
     "GLsizei": "%d",
     "GLsizeiptr": UNSIGNED_LONG_LONG_FORMAT,
diff --git a/scripts/gl_angle_ext.xml b/scripts/gl_angle_ext.xml
index 0389244dd9232e3b4cd18bfd7d8a03721643eeb8..40eb16fc1619a3e63d6befd5b574c1216901bbf9 100644
--- a/scripts/gl_angle_ext.xml
+++ b/scripts/gl_angle_ext.xml
@@ -13,6 +13,7 @@
     <types>
         <type>typedef GLsizeiptr (<apientry/> *<name>GLGETBLOBPROCANGLE</name>)(const void *key, GLsizeiptr keySize, void *value, GLsizeiptr valueSize, const void *userParam);</type>
         <type>typedef void (<apientry/> *<name>GLSETBLOBPROCANGLE</name>)(const void *key, GLsizeiptr keySize, const void *value, GLsizeiptr valueSize, const void *userParam);</type>
+        <type>typedef void *<name>GLMTLRasterizationRateMapANGLE</name>;</type>
     </types>
 
     <!-- SECTION: GL parameter class type definitions. -->
@@ -1066,6 +1067,18 @@
             <param len="1">void **<name>params</name></param>
             <alias name="glGetPointerv"/>
         </command>
+        <command>
+            <proto>void <name>glBindMetalRasterizationRateMapANGLE</name></proto>
+            <param><ptype>GLuint</ptype> <name>framebuffer</name></param>
+            <param><ptype>GLMTLRasterizationRateMapANGLE</ptype> <name>map</name></param>
+        </command>
+        <command>
+            <proto>void <name>glFramebufferResolveRenderbufferWEBKIT</name></proto>
+            <param><ptype>GLenum</ptype> <name>target</name></param>
+            <param><ptype>GLenum</ptype> <name>attachment</name></param>
+            <param><ptype>GLenum</ptype> <name>renderbuffertarget</name></param>
+            <param><ptype>GLuint</ptype> <name>renderbuffer</name></param>
+        </command>
     </commands>
 
     <!-- SECTION: ANGLE extension interface definitions -->
@@ -1467,6 +1480,18 @@
                 <enum name="GL_SHADER_BINARY_ANGLE"/>
             </require>
         </extension>
+        <extension name="GL_ANGLE_variable_rasterization_rate_metal" supported="gles2">
+            <require>
+                <enum name="GL_VARIABLE_RASTERIZATION_RATE_ANGLE"/>
+                <enum name="GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE"/>
+                <command name="glBindMetalRasterizationRateMapANGLE"/>
+            </require>
+        </extension>
+        <extension name="GL_WEBKIT_explicit_resolve_target" supported='gles2'>
+            <require>
+                <command name="glFramebufferResolveRenderbufferWEBKIT"/>
+            </require>
+        </extension>
         <extension name="GL_ANGLE_blob_cache" supported="gles2">
             <require>
                 <command name="glBlobCacheCallbacksANGLE"/>
@@ -1656,4 +1681,8 @@
         <enum value="0x96EF" name="GL_BLOB_CACHE_SET_FUNCTION_ANGLE"/>
         <enum value="0x972D" name="GL_BLOB_CACHE_USER_PARAM_ANGLE"/>
     </enums>
+    <enums namespace="GL" start="0x96BC" end="0x96BD" vendor="ANGLE">
+        <enum value="0x96BC" name="GL_VARIABLE_RASTERIZATION_RATE_ANGLE"/>
+        <enum value="0x96BD" name="GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE"/>
+    </enums>
 </registry>
diff --git a/scripts/registry_xml.py b/scripts/registry_xml.py
index 20290dfb85b24c072d509e5f9f5ee9f95802fdb2..fbae880195089d75ab3e6df67f1f8e03e5885ff1 100644
--- a/scripts/registry_xml.py
+++ b/scripts/registry_xml.py
@@ -74,11 +74,13 @@ angle_requestable_extensions = [
     "GL_ANGLE_texture_external_update",
     "GL_ANGLE_texture_multisample",
     "GL_ANGLE_texture_rectangle",
+    "GL_ANGLE_variable_rasterization_rate_metal",
     "GL_ANGLE_vulkan_image",
     "GL_ANGLE_yuv_internal_format",
     "GL_CHROMIUM_color_buffer_float_rgb",
     "GL_CHROMIUM_color_buffer_float_rgba",
     "GL_CHROMIUM_lose_context",
+    "GL_WEBKIT_explicit_resolve_target",
 ]
 
 gles_requestable_extensions = [
diff --git a/src/common/debug.cpp b/src/common/debug.cpp
index 706852242b5579629b6156f27d330209b6701a1a..5c8eb4d2d9934f0626e3d817d5029d597ea41c75 100644
--- a/src/common/debug.cpp
+++ b/src/common/debug.cpp
@@ -36,6 +36,14 @@
 #include "common/entry_points_enum_autogen.h"
 #include "common/system_utils.h"
 
+#if defined(ANGLE_ENABLE_ASSERTS)
+bool AreAssertionsEnabled()
+{
+    static bool enabled = [] { return angle::GetEnvironmentVar("ANGLE_DISABLE_ASSERTS") != "1"; }();
+    return enabled;
+}
+#endif  // defined(ANGLE_ENABLE_ASSERTS)
+
 namespace gl
 {
 
diff --git a/src/common/debug.h b/src/common/debug.h
index 48a1979e5edb3165d659c000c789f9a705809923..0ae642f624bca7ae94c595327058fb76bb6c8e50 100644
--- a/src/common/debug.h
+++ b/src/common/debug.h
@@ -177,4 +177,15 @@ angle::SimpleMutex &GetDebugMutex();
 #    define ANGLE_REENABLE_UNUSED_FUNCTION_WARNING
 #endif
 
+// clang-format off
+#if defined(__clang__)
+#    define ANGLE_DISABLE_NONLITERAL_FORMAT_WARNING \
+        _Pragma("clang diagnostic push") _Pragma("clang diagnostic ignored \"-Wformat-nonliteral\"")
+#    define ANGLE_REENABLE_NONLITERAL_FORMAT_WARNING _Pragma("clang diagnostic pop")
+#else
+#    define ANGLE_DISABLE_NONLITERAL_FORMAT_WARNING
+#    define ANGLE_REENABLE_NONLITERAL_FORMAT_WARNING
+#endif
+// clang-format on
+
 #endif  // COMMON_DEBUG_H_
diff --git a/src/common/entry_points_enum_autogen.cpp b/src/common/entry_points_enum_autogen.cpp
index 63a19ed02e59e81861d8e49bd650241efcebcd5c..f8f12f1fd5f895a0185c04061b797477b38683aa 100644
--- a/src/common/entry_points_enum_autogen.cpp
+++ b/src/common/entry_points_enum_autogen.cpp
@@ -522,6 +522,8 @@ const char *GetEntryPointName(EntryPoint ep)
             return "glBindFramebufferOES";
         case EntryPoint::GLBindImageTexture:
             return "glBindImageTexture";
+        case EntryPoint::GLBindMetalRasterizationRateMapANGLE:
+            return "glBindMetalRasterizationRateMapANGLE";
         case EntryPoint::GLBindProgramPipeline:
             return "glBindProgramPipeline";
         case EntryPoint::GLBindProgramPipelineEXT:
@@ -950,6 +952,8 @@ const char *GetEntryPointName(EntryPoint ep)
             return "glFramebufferRenderbuffer";
         case EntryPoint::GLFramebufferRenderbufferOES:
             return "glFramebufferRenderbufferOES";
+        case EntryPoint::GLFramebufferResolveRenderbufferWEBKIT:
+            return "glFramebufferResolveRenderbufferWEBKIT";
         case EntryPoint::GLFramebufferTexture:
             return "glFramebufferTexture";
         case EntryPoint::GLFramebufferTexture2D:
diff --git a/src/common/entry_points_enum_autogen.h b/src/common/entry_points_enum_autogen.h
index 3e6f0362f78a2a8845b0c1a39cb972402f2a0f0d..4d10327c2af20f89a4a47a0db2a2d512c19c1201 100644
--- a/src/common/entry_points_enum_autogen.h
+++ b/src/common/entry_points_enum_autogen.h
@@ -267,6 +267,7 @@ enum class EntryPoint
     GLBindFramebuffer,
     GLBindFramebufferOES,
     GLBindImageTexture,
+    GLBindMetalRasterizationRateMapANGLE,
     GLBindProgramPipeline,
     GLBindProgramPipelineEXT,
     GLBindRenderbuffer,
@@ -481,6 +482,7 @@ enum class EntryPoint
     GLFramebufferPixelLocalStorageRestoreANGLE,
     GLFramebufferRenderbuffer,
     GLFramebufferRenderbufferOES,
+    GLFramebufferResolveRenderbufferWEBKIT,
     GLFramebufferTexture,
     GLFramebufferTexture2D,
     GLFramebufferTexture2DMultisampleEXT,
diff --git a/src/common/frame_capture_utils_autogen.cpp b/src/common/frame_capture_utils_autogen.cpp
index 13a3b3e472f11b67629c901034080b0c506e7310..6d2c39414ba8010cd2ca2c302bdd797d2ecac7cb 100644
--- a/src/common/frame_capture_utils_autogen.cpp
+++ b/src/common/frame_capture_utils_autogen.cpp
@@ -222,6 +222,10 @@ void WriteParamCaptureReplay(std::ostream &os, const CallCapture &call, const Pa
             WriteParamValueReplay<ParamType::TGLGETBLOBPROCANGLE>(
                 os, call, param.value.GLGETBLOBPROCANGLEVal);
             break;
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            WriteParamValueReplay<ParamType::TGLMTLRasterizationRateMapANGLE>(
+                os, call, param.value.GLMTLRasterizationRateMapANGLEVal);
+            break;
         case ParamType::TGLSETBLOBPROCANGLE:
             WriteParamValueReplay<ParamType::TGLSETBLOBPROCANGLE>(
                 os, call, param.value.GLSETBLOBPROCANGLEVal);
@@ -995,6 +999,8 @@ const char *ParamTypeToString(ParamType paramType)
             return "GLDEBUGPROCKHR";
         case ParamType::TGLGETBLOBPROCANGLE:
             return "GLGETBLOBPROCANGLE";
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            return "GLMTLRasterizationRateMapANGLE";
         case ParamType::TGLSETBLOBPROCANGLE:
             return "GLSETBLOBPROCANGLE";
         case ParamType::TGLbitfield:
diff --git a/src/common/frame_capture_utils_autogen.h b/src/common/frame_capture_utils_autogen.h
index aba4c7679065ec3e56a9ba1128edeffebd8408a0..7a55f33cb847a2ac4ff3c4ca345a2e898c8760df 100644
--- a/src/common/frame_capture_utils_autogen.h
+++ b/src/common/frame_capture_utils_autogen.h
@@ -100,6 +100,7 @@ enum class ParamType
     TGLDEBUGPROC,
     TGLDEBUGPROCKHR,
     TGLGETBLOBPROCANGLE,
+    TGLMTLRasterizationRateMapANGLE,
     TGLSETBLOBPROCANGLE,
     TGLbitfield,
     TGLboolean,
@@ -271,7 +272,7 @@ enum class ParamType
     TvoidPointerPointer,
 };
 
-constexpr uint32_t kParamTypeCount = 234;
+constexpr uint32_t kParamTypeCount = 235;
 
 union ParamValue
 {
@@ -334,6 +335,7 @@ union ParamValue
     GLDEBUGPROC GLDEBUGPROCVal;
     GLDEBUGPROCKHR GLDEBUGPROCKHRVal;
     GLGETBLOBPROCANGLE GLGETBLOBPROCANGLEVal;
+    GLMTLRasterizationRateMapANGLE GLMTLRasterizationRateMapANGLEVal;
     GLSETBLOBPROCANGLE GLSETBLOBPROCANGLEVal;
     GLbitfield GLbitfieldVal;
     GLboolean GLbooleanVal;
@@ -891,6 +893,14 @@ inline GLGETBLOBPROCANGLE GetParamVal<ParamType::TGLGETBLOBPROCANGLE, GLGETBLOBP
     return value.GLGETBLOBPROCANGLEVal;
 }
 
+template <>
+inline GLMTLRasterizationRateMapANGLE
+GetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE, GLMTLRasterizationRateMapANGLE>(
+    const ParamValue &value)
+{
+    return value.GLMTLRasterizationRateMapANGLEVal;
+}
+
 template <>
 inline GLSETBLOBPROCANGLE GetParamVal<ParamType::TGLSETBLOBPROCANGLE, GLSETBLOBPROCANGLE>(
     const ParamValue &value)
@@ -2211,6 +2221,8 @@ T AccessParamValue(ParamType paramType, const ParamValue &value)
             return GetParamVal<ParamType::TGLDEBUGPROCKHR, T>(value);
         case ParamType::TGLGETBLOBPROCANGLE:
             return GetParamVal<ParamType::TGLGETBLOBPROCANGLE, T>(value);
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            return GetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE, T>(value);
         case ParamType::TGLSETBLOBPROCANGLE:
             return GetParamVal<ParamType::TGLSETBLOBPROCANGLE, T>(value);
         case ParamType::TGLbitfield:
@@ -2917,6 +2929,14 @@ inline void SetParamVal<ParamType::TGLGETBLOBPROCANGLE>(GLGETBLOBPROCANGLE value
     valueOut->GLGETBLOBPROCANGLEVal = valueIn;
 }
 
+template <>
+inline void SetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE>(
+    GLMTLRasterizationRateMapANGLE valueIn,
+    ParamValue *valueOut)
+{
+    valueOut->GLMTLRasterizationRateMapANGLEVal = valueIn;
+}
+
 template <>
 inline void SetParamVal<ParamType::TGLSETBLOBPROCANGLE>(GLSETBLOBPROCANGLE valueIn,
                                                         ParamValue *valueOut)
@@ -4276,6 +4296,9 @@ void InitParamValue(ParamType paramType, T valueIn, ParamValue *valueOut)
         case ParamType::TGLGETBLOBPROCANGLE:
             SetParamVal<ParamType::TGLGETBLOBPROCANGLE>(valueIn, valueOut);
             break;
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            SetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE>(valueIn, valueOut);
+            break;
         case ParamType::TGLSETBLOBPROCANGLE:
             SetParamVal<ParamType::TGLSETBLOBPROCANGLE>(valueIn, valueOut);
             break;
diff --git a/src/common/gl_enum_utils_autogen.cpp b/src/common/gl_enum_utils_autogen.cpp
index a5bc003ea96f15e3819b526d117e888d68b10eb6..dad677d9c72c19ab5322ac9cce1a86ae97656bb9 100644
--- a/src/common/gl_enum_utils_autogen.cpp
+++ b/src/common/gl_enum_utils_autogen.cpp
@@ -2818,6 +2818,10 @@ const char *GLenumToString(GLESEnum enumGroup, unsigned int value)
                     return "GL_RGBX8_ANGLE";
                 case 0x96BB:
                     return "GL_SHADER_BINARY_ANGLE";
+                case 0x96BC:
+                    return "GL_VARIABLE_RASTERIZATION_RATE_ANGLE";
+                case 0x96BD:
+                    return "GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE";
                 case 0x96BE:
                     return "GL_PROGRAM_BINARY_READY_ANGLE";
                 case 0x96C0:
@@ -22315,6 +22319,7 @@ static StringEnumEntry g_stringEnumTable[] = {
     {"GL_MESH_SUBROUTINE_UNIFORM_NV", 0x957E},
     {"GL_MESH_VERTICES_OUT_NV", 0x9579},
     {"GL_MESH_WORK_GROUP_SIZE_NV", 0x953E},
+    {"GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE", 0x96BD},
     {"GL_MIN", 0x8007},
     {"GL_MINMAX", 0x802E},
     {"GL_MINMAX_EXT", 0x802E},
@@ -24984,6 +24989,7 @@ static StringEnumEntry g_stringEnumTable[] = {
     {"GL_VARIABLE_E_NV", 0x8527},
     {"GL_VARIABLE_F_NV", 0x8528},
     {"GL_VARIABLE_G_NV", 0x8529},
+    {"GL_VARIABLE_RASTERIZATION_RATE_ANGLE", 0x96BC},
     {"GL_VARIANT_ARRAY_EXT", 0x87E8},
     {"GL_VARIANT_ARRAY_POINTER_EXT", 0x87E9},
     {"GL_VARIANT_ARRAY_STRIDE_EXT", 0x87E6},
diff --git a/src/common/log_utils.h b/src/common/log_utils.h
index fc1aa2cccb169a6580cff7b2f144fe1768dbf6c5..de2ccdab42b3a77f3104e03c0715be22e8df2264 100644
--- a/src/common/log_utils.h
+++ b/src/common/log_utils.h
@@ -262,10 +262,13 @@ std::ostream &FmtHex(std::ostream &os, T value)
 
 // A macro asserting a condition and outputting failures to the debug log
 #if defined(ANGLE_ENABLE_ASSERTS)
+bool AreAssertionsEnabled();
 #    define ASSERT(expression)                                                           \
         (expression ? static_cast<void>(0)                                               \
-                    : (FATAL() << "\t! Assert failed in " << __FUNCTION__ << " (" << __FILE__ \
-                               << ":" << __LINE__ << "): " << #expression))
+                    : (!AreAssertionsEnabled()                                           \
+                           ? static_cast<void>(0)                                        \
+                           : (FATAL() << "\t! Assert failed in " << __FUNCTION__ << " (" \
+                                      << __FILE__ << ":" << __LINE__ << "): " << #expression)))
 #else
 #    define ASSERT(condition) ANGLE_EAT_STREAM_PARAMETERS << !(condition)
 #endif  // defined(ANGLE_ENABLE_ASSERTS)
diff --git a/src/common/tls.cpp b/src/common/tls.cpp
index 9600bae1a49fc9b6c409dfe311439a630b3b29f2..b66a225f407cc74f50e0be4015692a8cd94dffd0 100644
--- a/src/common/tls.cpp
+++ b/src/common/tls.cpp
@@ -20,7 +20,6 @@
 #    include <wrl/async.h>
 #    include <wrl/client.h>
 
-using namespace std;
 using namespace Windows::Foundation;
 using namespace ABI::Windows::System::Threading;
 
diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index 268ef72b2e82923b99b88e6e1b6d480c4d5e206a..32e264e9f3102354ccc65d8cd49453f7ac1b708e 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/compiler.gni b/src/compiler.gni
index 4afd2254c1301f3e061f26a1198b35b624c8d128..6db5e094ba886a1dc31c608812a70754e7d5538c 100644
--- a/src/compiler.gni
+++ b/src/compiler.gni
@@ -212,6 +212,7 @@ angle_translator_sources = [
   "src/compiler/translator/tree_ops/glsl/apple/RewriteRowMajorMatrices.h",
   "src/compiler/translator/tree_ops/glsl/apple/RewriteUnaryMinusOperatorFloat.h",
   "src/compiler/translator/tree_ops/glsl/apple/UnfoldShortCircuitAST.h",
+  "src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.h",
   "src/compiler/translator/tree_util/BuiltIn.h",
   "src/compiler/translator/tree_util/BuiltIn_autogen.h",
   "src/compiler/translator/tree_util/DriverUniform.cpp",
@@ -422,6 +423,7 @@ angle_translator_lib_msl_sources = [
   "src/compiler/translator/tree_ops/msl/AddExplicitTypeCasts.h",
   "src/compiler/translator/tree_ops/msl/ConvertUnsupportedConstructorsToFunctionCalls.cpp",
   "src/compiler/translator/tree_ops/msl/ConvertUnsupportedConstructorsToFunctionCalls.h",
+  "src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.cpp",
   "src/compiler/translator/tree_ops/msl/FixTypeConstructors.cpp",
   "src/compiler/translator/tree_ops/msl/FixTypeConstructors.h",
   "src/compiler/translator/tree_ops/msl/GuardFragDepthWrite.cpp",
diff --git a/src/compiler/fuzz/translator_fuzzer.cpp b/src/compiler/fuzz/translator_fuzzer.cpp
index 03254652c1abeb00871193938597ec5014c22b89..73b5e75fe8432950ce75083fb083b62154ee5fe7 100644
--- a/src/compiler/fuzz/translator_fuzzer.cpp
+++ b/src/compiler/fuzz/translator_fuzzer.cpp
@@ -126,6 +126,10 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
                                 options.allowTranslateUniformBlockToStructuredBuffer ||
                                 options.rewriteIntegerUnaryMinusOperator;
     }
+    if (!IsOutputMSL(shaderOutput))
+    {
+        hasUnsupportedOptions = hasUnsupportedOptions || options.ensureLoopForwardProgress;
+    }
 
     // If there are any options not supported with this output, don't attempt to run the translator.
     if (hasUnsupportedOptions)
@@ -149,6 +153,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
     }
 
     std::vector<uint32_t> validOutputs;
+#ifndef ANGLE_TRANSLATOR_FUZZER_METAL_ONLY
     validOutputs.push_back(SH_ESSL_OUTPUT);
     validOutputs.push_back(SH_GLSL_COMPATIBILITY_OUTPUT);
     validOutputs.push_back(SH_GLSL_130_OUTPUT);
@@ -164,6 +169,10 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
     validOutputs.push_back(SH_SPIRV_VULKAN_OUTPUT);
     validOutputs.push_back(SH_HLSL_3_0_OUTPUT);
     validOutputs.push_back(SH_HLSL_4_1_OUTPUT);
+#endif
+#ifdef ANGLE_ENABLE_METAL
+    validOutputs.push_back(SH_MSL_METAL_OUTPUT);
+#endif
     bool found = false;
     for (auto valid : validOutputs)
     {
@@ -195,6 +204,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 
         if (translator == nullptr)
         {
+            sh::Finalize();
             return 0;
         }
 
@@ -229,6 +239,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 
         if (!translator->Init(resources))
         {
+            sh::Finalize();
             return 0;
         }
 
@@ -241,5 +252,6 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
     const char *shaderStrings[]       = {reinterpret_cast<const char *>(data)};
     translator->compile(shaderStrings, 1, options);
 
+    sh::Finalize();
     return 0;
 }
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index d03039602a42956a7d60903f36bcc194012c4900..1059f9c6ae6090d8a8657b61077f07ed6af9e269 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/Compiler.cpp b/src/compiler/translator/Compiler.cpp
index aa3e57f7d117b8bd6485bb6f4e5237fb5528db31..9cf88cd4fda034c7c69ac695b01463ce31cb6c7a 100644
--- a/src/compiler/translator/Compiler.cpp
+++ b/src/compiler/translator/Compiler.cpp
@@ -61,6 +61,7 @@
 #include "compiler/translator/tree_ops/glsl/apple/AddAndTrueToLoopCondition.h"
 #include "compiler/translator/tree_ops/glsl/apple/RewriteDoWhile.h"
 #include "compiler/translator/tree_ops/glsl/apple/UnfoldShortCircuitAST.h"
+#include "compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.h"
 #include "compiler/translator/tree_util/BuiltIn.h"
 #include "compiler/translator/tree_util/FindSymbolNode.h"
 #include "compiler/translator/tree_util/IntermNodePatternMatcher.h"
@@ -1066,6 +1067,14 @@ bool TCompiler::checkAndSimplifyAST(TIntermBlock *root,
         }
     }
 
+    if (compileOptions.ensureLoopForwardProgress)
+    {
+        if (!EnsureLoopForwardProgress(this, root))
+        {
+            return false;
+        }
+    }
+
     if (compileOptions.simplifyLoopConditions)
     {
         if (!SimplifyLoopConditions(this, root, &getSymbolTable()))
diff --git a/src/compiler/translator/ImmutableString_autogen.cpp b/src/compiler/translator/ImmutableString_autogen.cpp
index 55b45b68b31fed310218713e69a3b47c5cc68e12..77595853886e518d4bed603d584ffdf10a38fd0e 100644
--- a/src/compiler/translator/ImmutableString_autogen.cpp
+++ b/src/compiler/translator/ImmutableString_autogen.cpp
@@ -29,183 +29,209 @@ std::ostream &operator<<(std::ostream &os, const ImmutableString &str)
 namespace
 {
 
-constexpr int mangledkT1[] = {444,  1347, 2411, 431,  2282, 804,  2338, 20,   74,   74,
-                              1270, 1644, 2471, 1830, 1952, 2471, 2461, 1205, 437,  1399,
-                              1428, 2558, 907,  1860, 1910, 384,  340,  213,  1028, 1474,
-                              233,  1572, 1397, 2214, 2065, 1240, 1307, 307,  81,   1838};
-constexpr int mangledkT2[] = {1894, 451,  2116, 81,   2046, 968,  1123, 2108, 1234, 1081,
-                              822,  1256, 1355, 61,   2360, 373,  629,  1576, 1869, 1074,
-                              1140, 749,  2257, 1061, 1948, 706,  2264, 1475, 1361, 712,
-                              1166, 1950, 181,  1106, 2540, 2567, 1310, 1429, 2549, 711};
+constexpr int mangledkT1[] = {2186, 2708, 298,  662,  720,  2610, 2533, 955,  2266, 363,
+                              1173, 1913, 2069, 417,  1813, 1398, 2943, 2855, 2466, 2534,
+                              437,  1593, 1729, 543,  1529, 2896, 2290, 2843, 2741, 280,
+                              1542, 849,  750,  2664, 258,  424,  2478, 625,  1465, 1890};
+constexpr int mangledkT2[] = {2890, 2051, 1552, 239,  2564, 1463, 881,  1891, 2426, 2313,
+                              826,  805,  1439, 2489, 1282, 100,  1736, 3080, 2650, 2986,
+                              1292, 1531, 979,  1536, 1588, 1155, 2910, 775,  850,  791,
+                              199,  1380, 1547, 2246, 2532, 190,  1494, 672,  1700, 1391};
 constexpr int mangledkG[]  = {
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    528,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    939,  0,    0,    0,    0,
-    772,  645,  0,    0,    0,    2137, 0,    0,    0,    0,    0,    0,    0,    0,    572,  0,
-    0,    0,    447,  0,    0,    745,  0,    0,    91,   0,    1647, 1694, 0,    0,    0,    0,
-    0,    0,    0,    2176, 0,    0,    0,    0,    0,    0,    0,    0,    1956, 0,    0,    0,
-    0,    0,    0,    502,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1618,
-    2196, 0,    0,    0,    0,    374,  0,    0,    1600, 0,    0,    0,    0,    0,    0,    0,
-    0,    117,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    741,  0,    0,
-    0,    0,    0,    1550, 432,  0,    0,    0,    0,    0,    0,    0,    0,    0,    1153, 0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1986, 0,    0,    0,    0,
-    944,  791,  2274, 0,    0,    0,    0,    0,    381,  1870, 0,    0,    0,    0,    1593, 0,
-    0,    566,  0,    1897, 541,  0,    856,  0,    0,    749,  1547, 0,    0,    0,    1939, 0,
-    1655, 0,    0,    0,    474,  0,    0,    0,    839,  0,    617,  0,    1777, 1787, 0,    0,
-    0,    0,    2522, 0,    2491, 0,    0,    2307, 613,  0,    0,    0,    777,  429,  0,    1153,
-    1911, 0,    0,    0,    2274, 0,    0,    722,  0,    172,  0,    0,    0,    1746, 0,    0,
-    0,    0,    657,  0,    0,    2435, 0,    2475, 955,  1120, 1041, 0,    894,  0,    0,    773,
-    1029, 492,  0,    0,    2108, 0,    0,    2571, 0,    0,    0,    2541, 0,    0,    0,    0,
-    0,    0,    0,    1643, 0,    0,    0,    0,    0,    0,    229,  0,    0,    907,  2533, 0,
-    2086, 508,  0,    1163, 2459, 0,    0,    0,    1145, 0,    0,    1585, 0,    0,    0,    268,
-    0,    0,    0,    0,    2045, 0,    809,  0,    0,    0,    0,    2595, 1392, 0,    1862, 747,
-    1029, 0,    2639, 0,    2275, 0,    0,    0,    1407, 0,    0,    0,    0,    163,  430,  322,
-    0,    0,    856,  0,    673,  0,    0,    0,    0,    0,    329,  0,    0,    2608, 2009, 0,
-    0,    2004, 1205, 1228, 1864, 0,    2273, 1528, 2624, 0,    0,    700,  0,    0,    2352, 0,
-    840,  1659, 0,    0,    0,    1397, 2567, 0,    0,    1903, 0,    1347, 568,  0,    0,    147,
-    281,  0,    0,    0,    1498, 856,  685,  1122, 984,  0,    0,    1712, 0,    1478, 0,    0,
-    0,    2570, 337,  771,  0,    0,    1175, 0,    2396, 1453, 0,    0,    1097, 0,    0,    0,
-    0,    0,    2659, 109,  0,    0,    0,    0,    0,    0,    0,    0,    0,    1003, 0,    0,
-    2445, 0,    0,    857,  0,    1513, 0,    0,    0,    472,  0,    1454, 0,    2648, 0,    0,
-    729,  0,    0,    312,  808,  0,    0,    80,   0,    0,    0,    0,    361,  0,    0,    1994,
-    0,    293,  222,  0,    0,    2104, 1027, 438,  0,    0,    0,    443,  471,  0,    1022, 0,
-    0,    626,  1727, 1279, 0,    0,    511,  0,    2208, 927,  0,    0,    0,    1770, 145,  569,
-    728,  0,    2159, 2179, 714,  0,    2368, 0,    1138, 1587, 585,  0,    1149, 0,    0,    1013,
-    1136, 0,    0,    0,    0,    6,    197,  0,    0,    0,    75,   2461, 843,  0,    0,    328,
-    0,    1853, 1945, 2379, 268,  1413, 464,  933,  0,    1077, 0,    0,    620,  0,    0,    0,
-    0,    2221, 0,    0,    1420, 2267, 1251, 2208, 0,    768,  0,    498,  0,    0,    0,    0,
-    788,  0,    0,    1281, 1760, 0,    0,    464,  0,    0,    2615, 0,    753,  0,    1933, 0,
-    0,    0,    0,    0,    0,    1395, 1088, 355,  0,    139,  2456, 0,    0,    910,  1000, 0,
-    1155, 203,  172,  2636, 1375, 1649, 1563, 0,    177,  0,    765,  1206, 0,    2086, 1389, 1924,
-    2206, 0,    0,    0,    719,  194,  0,    198,  0,    916,  0,    0,    2008, 967,  255,  0,
-    1556, 0,    0,    0,    0,    279,  0,    1517, 0,    0,    2177, 2172, 0,    410,  1182, 0,
-    0,    2452, 2613, 0,    2032, 0,    0,    30,   2075, 682,  647,  1280, 676,  2331, 0,    0,
-    0,    0,    0,    630,  0,    355,  1202, 0,    689,  0,    218,  0,    0,    960,  1140, 675,
-    878,  305,  0,    278,  2451, 1708, 723,  0,    0,    245,  1258, 0,    570,  1915, 2151, 0,
-    2152, 1390, 0,    0,    0,    88,   0,    0,    1827, 331,  0,    477,  0,    2004, 0,    1421,
-    2421, 1652, 2605, 0,    0,    0,    1792, 0,    0,    1179, 1593, 0,    0,    0,    277,  1056,
-    0,    2121, 0,    2488, 0,    957,  0,    1664, 481,  2235, 0,    210,  2586, 240,  0,    0,
-    902,  0,    0,    0,    0,    817,  655,  1125, 838,  1889, 0,    0,    125,  2341, 1972, 0,
-    23,   0,    0,    0,    2318, 2190, 0,    0,    0,    1163, 381,  0,    2157, 2024, 0,    0,
-    772,  729,  999,  0,    0,    406,  472,  0,    0,    0,    1946, 0,    0,    2137, 0,    94,
-    72,   0,    0,    2490, 1041, 810,  470,  0,    1798, 2563, 0,    1099, 0,    0,    868,  0,
-    2295, 0,    0,    1702, 0,    0,    1224, 1830, 0,    0,    0,    0,    0,    0,    0,    2524,
-    0,    0,    0,    0,    0,    291,  0,    1366, 0,    836,  0,    2458, 0,    187,  0,    882,
-    0,    0,    0,    0,    1194, 0,    935,  149,  1237, 0,    292,  0,    797,  0,    0,    1359,
-    935,  1163, 0,    492,  0,    633,  1490, 201,  0,    0,    0,    1507, 0,    0,    307,  0,
-    0,    1482, 0,    0,    0,    1427, 987,  2563, 2217, 934,  0,    1031, 1482, 0,    0,    2092,
-    471,  689,  0,    0,    1890, 0,    2153, 0,    0,    0,    1414, 0,    0,    0,    0,    0,
-    0,    257,  0,    1075, 2362, 647,  1189, 0,    0,    246,  292,  0,    0,    0,    512,  0,
-    111,  0,    2264, 755,  819,  0,    44,   0,    992,  0,    1540, 0,    1763, 0,    0,    0,
-    342,  0,    0,    0,    769,  0,    220,  2624, 0,    1271, 620,  1286, 0,    0,    0,    0,
-    153,  1188, 671,  1183, 0,    1727, 1951, 0,    0,    0,    0,    762,  512,  339,  1091, 669,
-    0,    0,    0,    463,  2624, 0,    2210, 1450, 133,  1208, 871,  0,    0,    0,    2421, 390,
-    0,    774,  355,  2345, 0,    2659, 0,    0,    2251, 0,    0,    1359, 2648, 0,    2629, 0,
-    0,    0,    0,    251,  0,    764,  0,    0,    48,   0,    0,    1366, 0,    491,  0,    509,
-    321,  816,  1862, 405,  0,    751,  1208, 817,  38,   1195, 713,  944,  1291, 1250, 0,    1328,
-    1954, 0,    1571, 0,    0,    0,    0,    0,    0,    681,  0,    0,    470,  615,  0,    618,
-    327,  0,    0,    158,  0,    0,    401,  0,    2101, 474,  1007, 2151, 0,    0,    0,    0,
-    0,    1048, 0,    654,  1859, 789,  0,    0,    1093, 0,    2330, 2414, 0,    0,    0,    1028,
-    0,    0,    0,    2466, 0,    762,  782,  1718, 1790, 1917, 0,    0,    1254, 0,    107,  0,
-    1233, 1777, 0,    0,    78,   393,  0,    2175, 2635, 1405, 0,    29,   1098, 840,  491,  2604,
-    0,    1948, 327,  820,  371,  2377, 0,    0,    0,    2089, 730,  757,  0,    1203, 0,    1872,
-    0,    0,    0,    30,   2356, 1510, 0,    0,    573,  258,  649,  0,    0,    0,    0,    913,
-    874,  1286, 0,    2568, 906,  1223, 208,  0,    383,  0,    0,    2335, 1395, 0,    0,    136,
-    1039, 1210, 0,    0,    875,  1844, 2569, 0,    0,    0,    807,  1481, 0,    0,    0,    2619,
-    0,    0,    2222, 0,    0,    0,    0,    764,  1007, 0,    0,    1719, 0,    802,  0,    0,
-    0,    275,  0,    0,    553,  1587, 1406, 234,  1451, 0,    935,  1564, 509,  0,    638,  0,
-    0,    209,  2179, 0,    3,    594,  275,  0,    2398, 835,  0,    0,    0,    0,    2034, 2003,
-    0,    0,    0,    1648, 0,    856,  688,  0,    2044, 548,  0,    1730, 2101, 1018, 0,    0,
-    0,    2205, 1313, 0,    2217, 341,  0,    0,    844,  0,    0,    0,    0,    1692, 0,    2492,
-    0,    404,  2487, 1888, 0,    2256, 116,  0,    2264, 0,    1089, 0,    128,  1580, 0,    2215,
-    0,    0,    1215, 0,    909,  276,  0,    0,    0,    1006, 0,    0,    2097, 2048, 2513, 878,
-    0,    1398, 1111, 0,    168,  0,    578,  0,    1973, 1528, 0,    1780, 0,    0,    1337, 0,
-    2076, 0,    0,    932,  437,  191,  0,    0,    356,  0,    976,  100,  0,    1157, 1030, 978,
-    0,    0,    552,  568,  0,    0,    2031, 0,    2578, 0,    0,    1276, 1210, 1151, 39,   1577,
-    0,    664,  825,  1294, 0,    0,    1290, 814,  0,    0,    0,    169,  0,    1979, 2632, 2096,
-    632,  1890, 0,    415,  150,  0,    0,    2039, 0,    1365, 0,    0,    0,    2146, 0,    0,
-    921,  0,    574,  451,  0,    0,    0,    0,    1075, 1304, 123,  0,    2140, 0,    0,    749,
-    317,  0,    2179, 930,  0,    1102, 0,    545,  0,    523,  2564, 0,    0,    0,    11,   2371,
-    2253, 182,  0,    638,  0,    104,  0,    711,  0,    0,    0,    1152, 2555, 0,    0,    0,
-    0,    1922, 103,  1486, 0,    363,  1558, 2030, 2456, 52,   0,    2073, 1011, 770,  1007, 903,
-    366,  2361, 2349, 0,    0,    898,  571,  881,  0,    0,    0,    0,    0,    626,  0,    796,
-    1628, 594,  0,    0,    389,  0,    1302, 0,    0,    132,  0,    1271, 2093, 0,    2426, 0,
-    424,  2462, 264,  0,    0,    957,  2311, 1706, 0,    1275, 0,    1740, 1148, 2211, 0,    198,
-    0,    496,  0,    1994, 889,  0,    909,  970,  0,    2326, 0,    1596, 1161, 0,    1040, 103,
-    0,    0,    0,    1086, 1527, 0,    125,  815,  964,  459,  428,  230,  2664, 688,  584,  577,
-    0,    2618, 0,    2467, 692,  524,  1101, 89,   615,  0,    0,    1211, 2129, 2039, 74,   0,
-    1225, 2639, 2283, 765,  1355, 0,    0,    2339, 0,    9,    1733, 0,    0,    0,    1196, 0,
-    84,   49,   0,    0,    321,  2297, 1255, 0,    0,    842,  2656, 0,    0,    0,    1263, 0,
-    579,  89,   0,    712,  2274, 0,    1508, 525,  0,    1337, 0,    703,  1244, 651,  365,  282,
-    0,    856,  0,    0,    0,    1227, 1538, 2631, 0,    1056, 1515, 1400, 0,    0,    795,  0,
-    0,    230,  2234, 0,    73,   1658, 0,    1353, 178,  2193, 0,    459,  1418, 2162, 718,  0,
-    575,  1097, 0,    0,    1266, 778,  1149, 0,    0,    1467, 2473, 0,    0,    2597, 0,    294,
-    630,  346,  0,    0,    0,    0,    65,   2251, 2266, 0,    522,  1152, 971,  2051, 0,    0,
-    542,  1074, 1104, 2567, 582,  0,    1262, 0,    2318, 2605, 1322, 0,    1307, 0,    2094, 2152,
-    283,  1308, 1891, 0,    776,  0,    246,  348,  1174, 0,    2415, 0,    2063, 716,  727,  0,
-    0,    0,    0,    0,    1669, 1407, 1271, 0,    2373, 264,  840,  0,    2536, 9,    901,  581,
-    763,  0,    906,  0,    1800, 1394, 0,    1478, 0,    1899, 0,    0,    0,    2217, 1340, 267,
-    816,  0,    0,    0,    0,    0,    0,    0,    0,    2645, 1978, 0,    726,  759,  0,    2617,
-    15,   1366, 966,  0,    2,    0,    0,    2515, 0,    1236, 0,    0,    2233, 0,    0,    1144,
-    0,    0,    0,    1321, 1102, 1204, 0,    1368, 1302, 2505, 1282, 2210, 366,  798,  1598, 1207,
-    2495, 1396, 0,    999,  0,    734,  632,  810,  0,    2191, 1361, 1340, 778,  0,    105,  850,
-    1936, 0,    1950, 0,    0,    0,    869,  1314, 582,  0,    0,    818,  382,  1225, 0,    82,
-    951,  1773, 2248, 1292, 181,  2517, 0,    0,    0,    0,    0,    0,    32,   0,    2154, 0,
-    318,  563,  0,    0,    658,  0,    266,  1817, 0,    1848, 0,    1446, 0,    69,   0,    426,
-    419,  19,   0,    368,  731,  381,  754,  0,    87,   370,  340,  0,    851,  2275, 1500, 192,
-    1448, 1253, 0,    0,    0,    0,    0,    169,  0,    1387, 0,    2184, 0,    0,    2083, 2586,
-    1399, 1141, 0,    2484, 0,    0,    383,  1055, 0,    0,    0,    464,  0,    430,  1192, 0,
-    1673, 0,    0,    0,    781,  0,    577,  272,  350,  716,  0,    0,    1378, 589,  1207, 115,
-    1293, 0,    0,    264,  2058, 0,    0,    0,    0,    1103, 2539, 1006, 0,    0,    944,  436,
-    0,    0,    1702, 702,  968,  32,   702,  674,  1602, 0,    0,    0,    0,    345,  516,  88,
-    784,  2656, 0,    0,    514,  2138, 2499, 0,    0,    0,    0,    0,    659,  0,    744,  2661,
-    0,    2000, 1574, 1095, 588,  198,  2082, 249,  1734, 1262, 2523, 1505, 913,  329,  727,  2352,
-    742,  1043, 0,    0,    1306, 0,    1172, 0,    643,  2415, 121,  0,    358,  0,    0,    2534,
-    0,    0,    0,    798,  0,    0,    687,  0,    247,  175,  771,  0,    1806, 116,  129,  325,
-    919,  314,  0,    0,    2516, 0,    2439, 1916, 0,    1281, 0,    2644, 860,  0,    0,    0,
-    278,  0,    0,    271,  284,  0,    1980, 0,    0,    0,    189,  44,   194,  1358, 0,    1953,
-    0,    1199, 2329, 0,    0,    1326, 0,    929,  0,    0,    915,  0,    0,    303,  64,   998,
-    0,    0,    0,    2128, 2119, 0,    0,    2625, 819,  1149, 1522, 0,    399,  0,    1130, 733,
-    0,    1695, 546,  1252, 362,  1315, 0,    1764, 1751, 28,   0,    98,   0,    261,  478,  0,
-    1240, 550,  0,    0,    2317, 2634, 706,  0,    270,  0,    0,    0,    21,   2234, 665,  665,
-    1347, 2306, 1621, 1398, 0,    2326, 954,  143,  2637, 623,  2153, 1040, 2424, 0,    1416, 0,
-    1,    383,  1998, 23,   1017, 130,  2440, 413,  0,    459,  792,  693,  717,  1681, 883,  0,
-    793,  0,    0,    148,  1249, 0,    0,    1465, 0,    0,    807,  0,    1174, 418,  536,  700,
-    135,  1176, 782,  1297, 0,    2562, 0,    0,    977,  0,    122,  2254, 1031, 126,  0,    0,
-    14,   2169, 0,    2650, 0,    1003, 956,  0,    1539, 0,    892,  2395, 1540, 0,    1588, 765,
-    1519, 131,  1950, 0,    0,    0,    0,    0,    1127, 15,   1142, 1356, 0,    214,  575,  0,
-    0,    0,    1101, 0,    507,  0,    0,    453,  196,  0,    0,    0,    2225, 966,  0,    817,
-    1124, 283,  0,    0,    1111, 1340, 0,    0,    923,  0,    732,  0,    953,  252,  0,    737,
-    0,    0,    0,    2415, 381,  0,    0,    0,    0,    1859, 1350, 0,    1117, 1895, 0,    0,
-    0,    0,    0,    2427, 71,   483,  631,  499,  1113, 0,    1259, 2083, 2244, 0,    1047, 1505,
-    581,  0,    0,    836,  1850, 521,  779,  0,    1150, 533,  417,  112,  66,   0,    0,    527,
-    320,  1391, 0,    361,  0,    94,   0,    689,  779,  0,    1674, 0,    186,  508,  897,  1164,
-    0,    1470, 2572, 2076, 786,  2488, 1506, 1836, 0,    127,  1033, 0,    1186, 0,    1270, 0,
-    1574, 951,  0,    1143, 513,  925,  1444, 0,    0,    779,  510,  2276, 239,  1223, 0,    326,
-    1674, 1429, 0,    583,  527,  1387, 0,    1765, 242,  1117, 928,  2359, 1345, 229,  0,    133,
-    1605, 2068, 0,    1927, 0,    0,    621,  1405, 769,  2065, 0,    0,    0,    0,    0,    0,
-    0,    2447, 0,    0,    0,    0,    1403, 0,    641,  1029, 1032, 0,    957,  1820, 532,  0,
-    0,    1317, 1531, 0,    0,    0,    1230, 0,    0,    195,  2544, 170,  0,    12,   1270, 0,
-    75,   333,  944,  0,    834,  0,    149,  0,    0,    0,    0,    0,    0,    1337, 697,  0,
-    0,    2307, 1426, 1926, 0,    1635, 0,    1246, 0,    2543, 0,    147,  1011, 494,  0,    1239,
-    824,  2147, 0,    1290, 33,   153,  2434, 472,  1637, 1343, 807,  295,  211,  0,    547,  316,
-    0,    1059, 0,    1166, 2434, 908,  698,  2164, 65,   150,  0,    666,  0,    0,    0,    0,
-    588,  1253, 0,    0,    2147, 512,  0,    0,    2354, 1792, 506,  1014, 1918, 0,    627,  0,
-    0,    0,    279,  0,    0,    0,    0,    0,    0,    156,  402,  736,  2282, 0,    0,    2598,
-    0,    1264, 1338, 1241, 2624, 0,    0,    0,    1890, 216,  66,   188,  0,    0,    1780, 0,
-    0,    0,    124,  312,  0,    1256, 681,  1702, 2608, 5,    0,    1089, 1293, 2129, 608,  0,
-    594,  538,  810,  0,    0,    2099, 0,    579,  705,  0,    93,   488,  1380, 554,  2202, 1044,
-    0,    0,    0,    0,    0,    66,   1205, 2148, 1002, 1012, 0,    939,  376,  1295, 711,  2460,
-    0,    2097, 1386, 0,    1247, 1118, 370,  0,    2086, 350,  0,    0,    1329, 1760, 2133, 2185,
-    598,  0,    0,    2321, 0,    313,  1356, 10,   1076, 314,  950,  0,    523,  1075, 72,   2080,
-    0,    1543, 0,    444,  2641, 375,  684,  0,    2466, 377,  119,  0,    0,    1563, 0,    1060,
-    258,  508,  1033, 0,    1232, 0,    1756, 997,  2505, 643,  981,  401,  0,    637,  956,  1154,
-    391,  1778, 1321, 0,    1734, 112,  0,    488,  2459, 1480, 418,  0,    1904, 0,    1622, 947,
-    66,   403,  0,    1401, 0,    73,   0,    1023, 2539, 13,   183,  0,    2015, 152,  0,    0,
-    0,    47,   0,    0,    2227, 2395, 2545, 2589, 1119, 0,    0,    0,    1215, 563,  0,    1178,
-    1090, 848,  424,  1073, 2447, 956,  0,    0,    1242, 1647, 0,    587,  0,    1294, 0,    1732,
-    442,  1199, 839,  1265, 0,    587,  0,    0,    543,  846,  1562, 2575, 574,  1898, 0,    2471,
-    1940, 2616, 207,  157,  0,    1319, 163,  0,    0,    2672, 51,   0,    223,  0,    42,   143,
-    318,  0};
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    682,  0,    296,  0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    489,  0,    696,  0,    0,    0,    0,    0,    0,
+    0,    0,    0,    818,  3071, 0,    0,    0,    0,    2849, 0,    0,    0,    0,    2314, 0,
+    0,    0,    98,   0,    0,    450,  0,    0,    45,   0,    0,    0,    0,    0,    1614, 0,
+    0,    0,    2596, 0,    0,    0,    0,    0,    0,    287,  0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    897,  0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    3038, 1045, 0,    0,    0,    422,  0,    0,    0,    0,    0,    0,    0,    0,    351,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    203,  1211, 0,    0,    0,    184,
+    0,    0,    2806, 0,    0,    0,    0,    0,    74,   0,    448,  0,    0,    0,    0,    0,
+    0,    0,    0,    0,    931,  0,    0,    0,    0,    1061, 0,    0,    0,    198,  0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    2959, 0,    2970, 0,    0,    0,
+    0,    0,    0,    502,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    77,   0,    0,    0,    0,    2681, 0,    0,    0,    502,  1779, 0,    0,    0,    0,    0,
+    2758, 0,    1301, 0,    0,    0,    0,    0,    110,  0,    3084, 0,    0,    0,    4,    0,
+    0,    0,    0,    0,    2003, 2899, 791,  0,    400,  0,    1824, 0,    0,    0,    0,    1596,
+    0,    0,    0,    0,    2330, 2862, 0,    1649, 875,  1541, 434,  0,    0,    0,    0,    2406,
+    0,    0,    2252, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    545,  0,    0,    0,    0,    0,    0,    0,    909,  0,    0,    0,
+    976,  0,    0,    992,  0,    563,  0,    2679, 850,  0,    0,    0,    620,  2924, 0,    0,
+    2988, 1185, 1503, 0,    0,    0,    812,  2944, 0,    0,    0,    0,    0,    0,    0,    1516,
+    0,    0,    0,    0,    0,    350,  0,    330,  0,    487,  821,  2996, 0,    0,    0,    0,
+    457,  0,    0,    0,    949,  1948, 2806, 0,    0,    1695, 472,  0,    913,  0,    0,    2755,
+    0,    0,    0,    0,    101,  0,    0,    0,    0,    792,  1385, 0,    0,    1255, 0,    359,
+    0,    0,    0,    2877, 0,    0,    0,    0,    0,    209,  406,  216,  0,    2879, 0,    0,
+    0,    0,    0,    97,   2545, 1803, 0,    0,    2556, 615,  0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    617,  0,    231,  1344, 2986, 1837,
+    0,    2610, 0,    0,    0,    0,    0,    1354, 0,    1177, 0,    0,    0,    0,    279,  0,
+    82,   169,  363,  0,    0,    0,    0,    1309, 0,    0,    0,    0,    0,    1077, 0,    151,
+    0,    0,    2288, 625,  0,    0,    1833, 1279, 0,    0,    0,    0,    271,  2784, 0,    2713,
+    0,    977,  1699, 0,    0,    0,    1559, 49,   0,    582,  0,    0,    0,    0,    0,    1277,
+    453,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    396,  462,  557,  0,
+    0,    0,    0,    0,    0,    90,   987,  511,  0,    0,    0,    625,  2485, 0,    0,    1270,
+    0,    207,  0,    0,    0,    1143, 0,    0,    0,    0,    0,    0,    0,    909,  0,    0,
+    0,    0,    2842, 0,    0,    387,  0,    1340, 0,    0,    0,    2394, 0,    0,    0,    0,
+    174,  0,    0,    0,    0,    0,    1074, 0,    0,    0,    2705, 0,    2684, 0,    0,    559,
+    365,  0,    0,    0,    2438, 380,  0,    0,    2240, 0,    0,    0,    0,    199,  0,    304,
+    651,  0,    0,    813,  0,    0,    0,    0,    0,    0,    645,  0,    0,    467,  255,  606,
+    0,    1136, 0,    0,    2958, 0,    2292, 0,    0,    0,    2621, 0,    0,    909,  2545, 0,
+    0,    0,    0,    0,    1165, 239,  0,    1158, 0,    0,    0,    0,    0,    1386, 877,  0,
+    0,    0,    0,    0,    0,    492,  0,    0,    2242, 0,    0,    826,  0,    2445, 0,    0,
+    0,    0,    0,    0,    21,   0,    0,    2819, 0,    0,    0,    0,    2487, 0,    0,    0,
+    0,    3060, 0,    3024, 4,    86,   935,  688,  3058, 520,  1294, 350,  0,    0,    0,    477,
+    2978, 0,    0,    0,    0,    472,  243,  0,    0,    0,    0,    149,  0,    0,    207,  0,
+    0,    0,    0,    0,    0,    0,    100,  0,    0,    407,  1107, 0,    489,  0,    0,    324,
+    517,  0,    0,    0,    0,    2705, 447,  350,  916,  0,    1189, 301,  0,    0,    0,    204,
+    418,  2636, 91,   894,  0,    30,   980,  0,    0,    0,    0,    3045, 0,    389,  755,  1612,
+    0,    3036, 0,    0,    0,    0,    697,  0,    0,    0,    1324, 0,    0,    804,  0,    1288,
+    0,    0,    189,  493,  0,    2363, 3046, 1679, 0,    0,    0,    2028, 0,    0,    0,    0,
+    605,  2657, 0,    2685, 0,    0,    0,    0,    0,    0,    2244, 0,    0,    0,    0,    0,
+    857,  0,    845,  0,    0,    720,  1790, 1010, 0,    0,    0,    0,    446,  0,    0,    0,
+    1184, 518,  2873, 0,    2187, 0,    0,    0,    0,    625,  0,    0,    0,    0,    2354, 0,
+    0,    1052, 0,    1062, 2671, 0,    0,    3004, 0,    342,  0,    1402, 0,    0,    2317, 0,
+    0,    0,    0,    185,  614,  1252, 1285, 3052, 238,  0,    1048, 246,  9,    0,    0,    0,
+    0,    0,    0,    95,   0,    569,  0,    910,  2504, 0,    289,  0,    0,    663,  214,  2800,
+    0,    0,    0,    939,  0,    0,    2798, 156,  362,  282,  0,    0,    223,  2054, 0,    0,
+    1024, 0,    524,  0,    0,    0,    0,    2603, 252,  1058, 58,   507,  0,    0,    0,    1201,
+    1294, 3003, 1050, 0,    0,    0,    1054, 0,    0,    748,  970,  2495, 538,  0,    1021, 2933,
+    0,    0,    0,    929,  415,  0,    3073, 0,    0,    769,  0,    0,    94,   3058, 0,    2462,
+    0,    0,    407,  595,  0,    0,    0,    392,  967,  0,    151,  311,  0,    447,  0,    0,
+    775,  80,   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1156, 0,    2843, 895,
+    0,    218,  0,    0,    0,    0,    0,    299,  0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    159,  0,    2818, 0,    984,  0,    0,    2793, 0,    0,    0,    1280, 0,    0,
+    0,    64,   0,    0,    1025, 501,  0,    1373, 0,    0,    0,    0,    1249, 456,  388,  0,
+    639,  843,  530,  0,    67,   383,  0,    345,  0,    319,  2701, 1123, 0,    0,    0,    0,
+    552,  702,  2587, 0,    0,    0,    2055, 0,    2825, 0,    2578, 0,    1337, 0,    776,  0,
+    224,  915,  0,    0,    0,    2966, 0,    0,    0,    0,    1013, 544,  908,  1286, 276,  820,
+    415,  0,    635,  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    633,  0,    1555,
+    758,  279,  948,  2802, 0,    732,  0,    1254, 0,    135,  1039, 0,    86,   1029, 0,    1110,
+    659,  0,    531,  0,    0,    0,    433,  97,   1308, 0,    0,    0,    55,   466,  1279, 725,
+    0,    0,    10,   0,    1348, 3045, 0,    0,    400,  0,    0,    0,    56,   0,    294,  449,
+    0,    0,    0,    0,    2778, 0,    0,    0,    0,    777,  540,  0,    0,    0,    1041, 2080,
+    0,    144,  426,  0,    2483, 2704, 0,    0,    0,    0,    0,    2617, 0,    0,    590,  0,
+    558,  0,    0,    0,    831,  1998, 0,    1302, 967,  0,    484,  200,  46,   0,    0,    0,
+    0,    0,    2650, 1661, 65,   0,    0,    2098, 0,    394,  507,  0,    0,    0,    0,    0,
+    474,  0,    567,  1726, 0,    386,  0,    0,    0,    1176, 0,    0,    54,   0,    864,  3063,
+    291,  0,    0,    246,  0,    1198, 0,    0,    1381, 0,    0,    2858, 0,    0,    1291, 0,
+    0,    0,    0,    1641, 2514, 0,    113,  756,  425,  0,    0,    2924, 0,    0,    1042, 0,
+    0,    0,    331,  772,  1031, 0,    0,    0,    2991, 0,    599,  0,    0,    1022, 1971, 0,
+    387,  0,    1034, 0,    440,  0,    1141, 0,    0,    0,    0,    0,    1080, 1744, 0,    0,
+    0,    2384, 1316, 0,    0,    1314, 0,    0,    0,    0,    1253, 1230, 1583, 0,    0,    718,
+    0,    1085, 270,  1343, 0,    1203, 610,  0,    2960, 2618, 0,    1081, 0,    0,    0,    0,
+    0,    479,  1036, 0,    522,  0,    0,    1120, 1533, 0,    3015, 64,   0,    1241, 0,    2932,
+    0,    148,  0,    3072, 0,    2390, 0,    0,    194,  0,    0,    0,    0,    0,    692,  473,
+    1264, 0,    2718, 0,    700,  600,  0,    565,  140,  2826, 0,    0,    37,   1337, 0,    1113,
+    0,    0,    0,    2473, 2655, 2500, 0,    505,  0,    0,    0,    0,    1178, 779,  369,  0,
+    1670, 338,  0,    0,    0,    0,    0,    1295, 458,  1972, 0,    1364, 0,    296,  1041, 0,
+    0,    105,  0,    433,  602,  1174, 0,    0,    963,  0,    0,    0,    0,    2373, 0,    4,
+    0,    2524, 3079, 178,  0,    0,    0,    2142, 0,    0,    0,    153,  88,   0,    393,  0,
+    800,  8,    624,  0,    0,    0,    0,    2296, 0,    0,    0,    679,  0,    392,  486,  0,
+    733,  0,    0,    2402, 232,  0,    507,  0,    308,  838,  1008, 0,    0,    0,    0,    0,
+    0,    765,  2859, 312,  0,    3065, 2347, 0,    132,  2978, 1222, 549,  0,    1317, 1394, 541,
+    328,  764,  572,  1032, 0,    421,  256,  15,   750,  292,  2914, 482,  846,  0,    364,  0,
+    40,   1215, 873,  1015, 1022, 0,    774,  0,    0,    269,  2286, 375,  426,  628,  2768, 0,
+    332,  0,    0,    0,    2307, 0,    987,  1319, 0,    204,  0,    0,    37,   0,    0,    241,
+    1023, 0,    918,  521,  0,    265,  1126, 238,  729,  534,  0,    0,    377,  748,  2009, 750,
+    393,  1399, 0,    0,    0,    214,  607,  0,    0,    2336, 1098, 0,    2349, 0,    872,  0,
+    448,  1043, 0,    871,  0,    0,    0,    0,    194,  2867, 677,  0,    0,    87,   475,  632,
+    0,    2000, 0,    0,    0,    0,    3009, 829,  752,  2926, 0,    1920, 0,    2,    570,  0,
+    0,    561,  2701, 2890, 3067, 242,  0,    0,    815,  0,    0,    313,  0,    0,    1073, 0,
+    1161, 0,    2753, 0,    0,    0,    0,    382,  0,    0,    0,    2768, 0,    1010, 0,    0,
+    577,  0,    2214, 568,  0,    132,  0,    0,    433,  0,    0,    0,    0,    1341, 1299, 1995,
+    3015, 0,    3086, 3058, 0,    1165, 0,    100,  0,    1361, 0,    0,    312,  11,   0,    0,
+    1830, 0,    2617, 0,    712,  0,    590,  913,  0,    0,    1199, 376,  77,   2889, 2834, 236,
+    0,    0,    2249, 0,    116,  0,    0,    0,    0,    1263, 0,    0,    1260, 844,  0,    0,
+    0,    1885, 0,    496,  0,    375,  0,    150,  2324, 0,    0,    0,    913,  148,  0,    0,
+    268,  1063, 0,    566,  0,    0,    553,  3040, 450,  508,  671,  0,    0,    453,  856,  1027,
+    616,  0,    1070, 0,    0,    0,    509,  0,    0,    866,  361,  0,    0,    0,    377,  1393,
+    0,    65,   0,    0,    180,  368,  0,    0,    0,    1072, 0,    0,    2470, 0,    0,    0,
+    0,    585,  370,  0,    0,    0,    836,  1091, 2013, 0,    0,    41,   447,  0,    0,    1061,
+    676,  0,    801,  648,  0,    0,    0,    0,    0,    0,    0,    1179, 2485, 959,  736,  529,
+    0,    618,  2630, 0,    0,    0,    1967, 902,  0,    0,    0,    213,  0,    185,  0,    0,
+    0,    1049, 628,  176,  374,  195,  996,  0,    54,   182,  0,    0,    118,  0,    0,    966,
+    105,  2922, 1205, 896,  0,    0,    666,  0,    0,    699,  0,    0,    177,  0,    0,    0,
+    0,    60,   0,    250,  0,    0,    0,    2454, 0,    321,  0,    0,    575,  0,    0,    922,
+    789,  1238, 840,  47,   0,    0,    0,    1274, 1130, 541,  44,   64,   444,  0,    511,  3068,
+    0,    0,    0,    271,  0,    1036, 0,    0,    0,    0,    494,  981,  0,    16,   1038, 2897,
+    1002, 0,    0,    1018, 574,  1188, 1138, 1018, 0,    1299, 138,  0,    3048, 847,  217,  604,
+    0,    1391, 0,    16,   665,  1238, 1060, 267,  303,  510,  193,  0,    739,  2235, 912,  221,
+    0,    630,  0,    1789, 0,    1066, 0,    938,  0,    0,    0,    320,  122,  1148, 0,    0,
+    427,  0,    55,   0,    1758, 0,    838,  582,  0,    734,  0,    747,  0,    951,  0,    0,
+    711,  521,  484,  0,    0,    0,    886,  0,    228,  0,    425,  0,    0,    0,    0,    0,
+    0,    0,    0,    2250, 0,    208,  2494, 0,    0,    0,    0,    0,    0,    787,  1382, 2866,
+    0,    0,    0,    0,    721,  949,  830,  1104, 0,    1159, 0,    2850, 2227, 2280, 124,  0,
+    0,    361,  0,    1170, 0,    650,  0,    0,    0,    477,  333,  1398, 1381, 0,    0,    0,
+    0,    0,    0,    0,    0,    0,    393,  941,  2687, 0,    3091, 0,    0,    57,   0,    0,
+    0,    0,    0,    0,    904,  1366, 1150, 278,  0,    175,  0,    0,    0,    0,    563,  0,
+    0,    1040, 0,    495,  791,  1156, 0,    0,    0,    2771, 0,    1258, 1206, 262,  853,  0,
+    455,  0,    410,  0,    149,  0,    556,  0,    212,  776,  265,  0,    0,    2963, 0,    0,
+    96,   0,    849,  566,  0,    0,    2726, 0,    0,    1016, 0,    2964, 755,  0,    326,  0,
+    2905, 815,  0,    912,  0,    481,  0,    1115, 513,  0,    2522, 0,    1169, 0,    590,  845,
+    2651, 1220, 0,    0,    0,    0,    694,  0,    0,    0,    924,  0,    0,    146,  1264, 0,
+    2384, 768,  0,    0,    0,    0,    106,  0,    1284, 463,  663,  794,  1357, 0,    1213, 1189,
+    0,    0,    25,   0,    0,    954,  0,    0,    2627, 0,    0,    3036, 0,    1344, 919,  498,
+    1303, 0,    0,    0,    0,    0,    582,  0,    527,  2735, 0,    2930, 522,  286,  0,    763,
+    2281, 0,    0,    0,    0,    1131, 1016, 0,    1245, 1223, 1041, 84,   0,    405,  877,  247,
+    276,  882,  0,    2402, 998,  784,  0,    781,  1395, 0,    0,    2991, 2720, 0,    2609, 2379,
+    0,    1627, 652,  777,  1265, 0,    1021, 1262, 0,    0,    791,  2494, 0,    401,  430,  0,
+    633,  0,    2403, 2436, 48,   1190, 0,    0,    0,    0,    2879, 2001, 0,    1328, 2224, 0,
+    2830, 1422, 0,    0,    0,    0,    0,    0,    0,    1410, 0,    0,    476,  0,    0,    1121,
+    1977, 0,    0,    0,    698,  0,    0,    0,    0,    842,  23,   793,  3049, 1309, 651,  0,
+    2394, 342,  0,    0,    688,  2015, 0,    0,    42,   0,    1511, 1278, 0,    0,    762,  1262,
+    1649, 808,  865,  0,    0,    0,    2945, 0,    1347, 0,    0,    0,    2991, 1201, 18,   0,
+    1363, 2281, 752,  0,    20,   0,    130,  297,  0,    136,  0,    1274, 670,  3088, 345,  3010,
+    2473, 0,    0,    0,    505,  1129, 672,  165,  837,  246,  0,    1237, 0,    1137, 0,    0,
+    0,    690,  0,    2994, 0,    0,    0,    509,  1256, 0,    2977, 0,    1175, 0,    0,    519,
+    52,   682,  50,   0,    0,    518,  1396, 0,    516,  0,    469,  0,    0,    29,   31,   520,
+    0,    0,    0,    0,    1107, 69,   514,  213,  346,  247,  0,    0,    0,    1934, 0,    0,
+    0,    1414, 2983, 0,    1346, 0,    2761, 840,  986,  863,  2814, 0,    0,    0,    0,    0,
+    2000, 0,    0,    361,  0,    0,    0,    36,   348,  359,  0,    2489, 0,    824,  1224, 527,
+    0,    529,  0,    276,  874,  0,    1035, 168,  0,    1481, 172,  2647, 0,    1934, 0,    0,
+    933,  306,  0,    0,    662,  1235, 0,    2988, 2394, 0,    0,    278,  0,    538,  0,    0,
+    1006, 0,    526,  0,    534,  0,    0,    0,    0,    0,    197,  126,  0,    691,  0,    1003,
+    0,    2412, 528,  1136, 848,  308,  18,   347,  0,    2526, 0,    2867, 3090, 1086, 917,  0,
+    0,    0,    0,    1081, 0,    1128, 0,    0,    0,    717,  2805, 2583, 0,    290,  1687, 124,
+    1117, 182,  0,    0,    0,    0,    0,    0,    0,    0,    554,  850,  67,   687,  747,  7,
+    994,  2813, 1329, 0,    2507, 0,    0,    0,    0,    757,  2974, 0,    409,  0,    866,  2779,
+    97,   0,    1370, 244,  1359, 0,    1059, 2638, 870,  0,    31,   0,    1172, 0,    700,  1217,
+    0,    541,  1152, 851,  0,    2605, 0,    0,    0,    1298, 0,    0,    596,  13,   0,    0,
+    543,  2311, 755,  180,  1219, 0,    0,    94,   2921, 116,  293,  313,  0,    1321, 716,  0,
+    625,  2624, 689,  0,    1211, 0,    0,    1208, 0,    248,  0,    109,  3006, 2316, 156,  368,
+    0,    613,  109,  0,    602,  0,    0,    0,    0,    0,    1218, 2952, 0,    2390, 0,    0,
+    0,    0,    0,    2293, 0,    112,  0,    1901, 729,  2240, 485,  0,    939,  1246, 1283, 305,
+    2988, 0,    0,    213,  0,    0,    2716, 1289, 832,  0,    0,    653,  2775, 0,    1292, 0,
+    1166, 0,    3028, 319,  638,  152,  0,    597,  512,  0,    0,    547,  0,    545,  191,  1353,
+    451,  0,    1031, 239,  2363, 0,    1149, 0,    744,  944,  0,    0,    0,    0,    256,  0,
+    0,    0,    2641, 0,    1187, 758,  0,    0,    316,  0,    706,  2335, 0,    534,  0,    0,
+    51,   0,    98,   2959, 2928, 1217, 1111, 0,    0,    0,    720,  0,    644,  0,    2653, 0,
+    710,  308,  0,    908,  387,  0,    27,   0,    2968, 0,    2664, 0,    380,  1963, 1154, 0,
+    0,    847,  631,  1311, 0,    1063, 1398, 0,    397,  0,    2896, 522,  0,    0,    727,  0,
+    0,    0,    0,    0,    908,  0,    230,  413,  0,    0,    0,    1123, 880,  271,  0,    2323,
+    0,    1369, 0,    197,  235,  999,  0,    1365, 921,  176,  127,  0,    0,    1231, 0,    1473,
+    3017, 2584, 822,  0,    379,  0,    1341, 0,    598,  0,    1387, 10,   0,    0,    357,  2963,
+    0,    0,    0,    725,  764,  0,    0,    0,    0,    8,    1159, 0,    0,    2897, 591,  578,
+    0,    170,  1273, 219,  0,    1517, 0,    0,    554,  0,    0,    0,    0,    1079, 1372, 0,
+    3000, 75,   982,  0,    0,    0,    0,    0,    0,    295,  2181, 0,    503,  1361, 903,  0,
+    0,    722,  622,  38,   339,  0,    830,  2794, 490,  2377, 0,    1076, 13,   0,    2784, 0,
+    3014, 0,    0,    1225, 420,  1153, 1275, 489,  2480, 806,  0,    1878, 162,  1307, 0,    576,
+    2943, 1330, 1405, 672,  164,  0,    61,   1597, 1310, 0,    0,    345,  2504, 787,  722,  0,
+    49,   745,  207,  2713, 43,   344,  408,  851,  774,  1054, 1296, 245,  1562, 2997, 606,  0,
+    0,    738,  0,    506,  437,  0,    120,  1087, 0,    1396, 478,  0,    2326, 2266, 125,  0,
+    366,  381,  412,  991,  287,  0,    1037, 0,    782,  1378, 0,    3002, 0,    2071, 2357, 1214,
+    0,    473,  0,    889,  685,  0,    753,  0,    2520, 648,  1090, 0,    0,    3009, 0,    0,
+    0,    0,    0,    0,    2692, 385,  0,    463,  1196, 0,    0,    0,    0,    0,    27,   0,
+    2532, 219,  1028, 140,  0,    0,    0,    908,  1313, 720,  775,  0,    727,  611,  503,  0,
+    0,    0,    2774, 0,    675,  2906, 0,    0,    0,    545,  1302, 0,    0,    636,  0,    431,
+    2885, 903,  597,  1390, 0,    1251, 1803, 710,  2415, 0,    0,    2918, 3034, 426,  412,  2355,
+    564,  1051, 1383, 654,  0,    1313, 1290, 107,  3,    1350, 0,    79,   2956, 1560, 0,    686,
+    2883, 810,  0,    1014, 0,    0,    0,    0,    1158, 3079, 1409, 337,  0,    0,    419,  749,
+    0,    736,  0,    736,  0,    334,  0,    0,    636,  0,    0,    0,    2402, 642,  0,    1254,
+    0,    23,   155,  1027, 335,  847,  0,    929,  0,    349,  3007, 884,  866,  2179, 354,  1114,
+    1005, 562,  963,  34,   1825, 783,  0,    0,    215,  0,    0,    0,    0,    0,    821,  1091,
+    12,   467,  0,    3079, 476,  70,   0};
 
 int MangledHashG(const char *key, const int *T)
 {
@@ -214,7 +240,7 @@ int MangledHashG(const char *key, const int *T)
     for (int i = 0; key[i] != '\0'; i++)
     {
         sum += T[i] * key[i];
-        sum %= 2674;
+        sum %= 3095;
     }
     return mangledkG[sum];
 }
@@ -224,31 +250,33 @@ int MangledPerfectHash(const char *key)
     if (strlen(key) > 40)
         return 0;
 
-    return (MangledHashG(key, mangledkT1) + MangledHashG(key, mangledkT2)) % 2674;
+    return (MangledHashG(key, mangledkT1) + MangledHashG(key, mangledkT2)) % 3095;
 }
 
-constexpr int unmangledkT1[] = {5,   243, 269, 18, 166, 172, 166, 94,  139, 124, 44,
-                                223, 131, 43,  66, 43,  67,  39,  105, 117, 114, 237,
-                                234, 191, 127, 71, 30,  206, 111, 221, 232, 64};
-constexpr int unmangledkT2[] = {247, 144, 271, 36,  31,  34,  151, 48,  97,  17,  155,
-                                261, 16,  9,   119, 217, 179, 242, 46,  267, 260, 80,
-                                57,  156, 248, 258, 197, 20,  1,   257, 126, 273};
+constexpr int unmangledkT1[] = {53,  156, 228, 135, 85,  200, 308, 47,  117, 99,  187,
+                                257, 305, 21,  220, 255, 10,  218, 9,   99,  259, 11,
+                                43,  302, 271, 114, 195, 193, 62,  228, 44,  7};
+constexpr int unmangledkT2[] = {67,  290, 208, 97,  70,  82,  264, 152, 151, 235, 251,
+                                175, 142, 150, 284, 300, 144, 40,  123, 146, 115, 212,
+                                42,  134, 50,  296, 137, 83,  183, 254, 120, 108};
 constexpr int unmangledkG[]  = {
-    0,   0,   0,   0,   78,  266, 191, 101, 0,   0,   56,  0,   143, 0,   0,   152, 232, 0,   0,
-    108, 0,   0,   239, 0,   199, 0,   60,  40,  48,  72,  24,  147, 0,   69,  96,  0,   0,   0,
-    0,   0,   0,   214, 221, 0,   120, 236, 0,   121, 0,   196, 268, 2,   248, 0,   266, 0,   132,
-    0,   0,   0,   0,   0,   264, 54,  272, 232, 0,   0,   0,   109, 94,  0,   98,  0,   0,   72,
-    0,   252, 19,  149, 0,   194, 0,   118, 0,   208, 9,   101, 0,   76,  0,   11,  0,   44,  0,
-    0,   187, 0,   106, 0,   0,   0,   280, 116, 51,  0,   6,   208, 133, 38,  283, 0,   125, 65,
-    121, 115, 175, 74,  49,  0,   62,  0,   267, 81,  118, 0,   252, 45,  0,   177, 0,   179, 195,
-    0,   0,   0,   162, 0,   241, 92,  272, 182, 49,  242, 0,   232, 0,   0,   0,   251, 0,   226,
-    198, 144, 199, 255, 177, 233, 126, 155, 218, 124, 92,  212, 223, 161, 148, 155, 120, 97,  241,
-    0,   90,  172, 71,  0,   0,   0,   41,  121, 0,   130, 5,   191, 177, 17,  184, 0,   189, 16,
-    171, 103, 0,   25,  228, 150, 0,   242, 0,   79,  95,  79,  11,  144, 92,  63,  69,  0,   206,
-    0,   230, 71,  20,  115, 0,   0,   41,  0,   0,   64,  0,   0,   138, 72,  64,  0,   0,   160,
-    0,   263, 63,  97,  279, 30,  37,  37,  0,   212, 0,   58,  133, 0,   0,   0,   42,  0,   202,
-    12,  0,   0,   99,  219, 0,   0,   201, 222, 204, 23,  121, 113, 1,   0,   211, 268, 0,   37,
-    183, 126, 170, 216, 30,  59,  0,   243, 171, 0,   177, 0,   82,  71,  0,   122, 0,   0};
+    0,   0,   0,   0,   313, 0,   0,   198, 0,   0,   78,  26,  0,   0,   0,   93,  0,   148, 305,
+    0,   0,   126, 0,   0,   0,   0,   0,   0,   0,   63,  302, 0,   0,   0,   161, 287, 0,   215,
+    0,   0,   120, 0,   206, 141, 44,  49,  285, 7,   0,   0,   0,   0,   0,   0,   0,   296, 0,
+    0,   172, 0,   243, 0,   288, 0,   129, 173, 0,   71,  0,   0,   137, 0,   277, 0,   68,  0,
+    0,   0,   206, 0,   0,   0,   0,   32,  0,   0,   104, 221, 90,  0,   167, 0,   0,   0,   135,
+    0,   263, 0,   176, 0,   70,  0,   71,  0,   50,  0,   187, 90,  0,   0,   1,   205, 0,   0,
+    82,  131, 130, 56,  0,   60,  0,   0,   0,   0,   42,  308, 102, 69,  0,   151, 154, 0,   166,
+    85,  58,  0,   39,  22,  77,  0,   48,  0,   33,  199, 93,  220, 95,  0,   0,   153, 74,  260,
+    0,   271, 0,   311, 141, 0,   310, 0,   0,   263, 150, 0,   94,  308, 111, 0,   14,  82,  103,
+    0,   111, 0,   42,  259, 107, 66,  55,  287, 0,   133, 273, 4,   249, 0,   4,   234, 0,   23,
+    211, 258, 74,  128, 133, 0,   0,   21,  0,   0,   0,   7,   0,   9,   125, 288, 44,  0,   0,
+    131, 0,   84,  0,   18,  9,   66,  139, 0,   64,  0,   0,   129, 60,  17,  4,   0,   0,   70,
+    0,   111, 73,  274, 275, 0,   309, 251, 130, 132, 0,   0,   117, 0,   0,   129, 0,   176, 36,
+    0,   240, 0,   0,   0,   231, 29,  80,  65,  153, 0,   111, 76,  141, 115, 73,  1,   0,   1,
+    35,  60,  63,  130, 67,  305, 0,   0,   68,  28,  136, 75,  211, 61,  165, 97,  140, 2,   248,
+    0,   43,  0,   14,  0,   0,   8,   164, 0,   0,   100, 0,   12,  282, 212, 0,   126, 0,   123,
+    47,  0,   64,  0,   268, 0,   0,   5,   0,   299, 57,  175};
 
 int UnmangledHashG(const char *key, const int *T)
 {
@@ -257,7 +285,7 @@ int UnmangledHashG(const char *key, const int *T)
     for (int i = 0; key[i] != '\0'; i++)
     {
         sum += T[i] * key[i];
-        sum %= 284;
+        sum %= 316;
     }
     return unmangledkG[sum];
 }
@@ -267,7 +295,7 @@ int UnmangledPerfectHash(const char *key)
     if (strlen(key) > 32)
         return 0;
 
-    return (UnmangledHashG(key, unmangledkT1) + UnmangledHashG(key, unmangledkT2)) % 284;
+    return (UnmangledHashG(key, unmangledkT1) + UnmangledHashG(key, unmangledkT2)) % 316;
 }
 
 }  // namespace
diff --git a/src/compiler/translator/InfoSink.h b/src/compiler/translator/InfoSink.h
index 8d3b1c0cf16e7ad912263ca4f3b37e6f0e808523..4cb10620fdab07e6896640fbf4675f78ad8072eb 100644
--- a/src/compiler/translator/InfoSink.h
+++ b/src/compiler/translator/InfoSink.h
@@ -21,7 +21,11 @@ class TSymbol;
 class TType;
 
 // Returns the fractional part of the given floating-point number.
-inline float fractionalPart(float f)
+#ifdef WK_WORKAROUND_RDAR_145268301_ASAN_STACK_USE_AFTER_SCOPE
+__attribute__((no_sanitize_address))
+#endif
+inline float
+fractionalPart(float f)
 {
     float intPart = 0.0f;
     return modff(f, &intPart);
diff --git a/src/compiler/translator/Operator_autogen.h b/src/compiler/translator/Operator_autogen.h
index c72ea9dc22b272a59ee005322e01b28b780fa95c..c3b4797d16b0e6fde0536977c44ee406c1d258cf 100644
--- a/src/compiler/translator/Operator_autogen.h
+++ b/src/compiler/translator/Operator_autogen.h
@@ -432,6 +432,7 @@ enum TOperator : uint16_t
     EOpInterpolateAtCenter,
 
     // Group MetalCommon
+    EOpLoopForwardProgress,
     EOpSaturate,
 };
 
diff --git a/src/compiler/translator/SymbolTable_autogen.cpp b/src/compiler/translator/SymbolTable_autogen.cpp
index 3381c55feb8152de06e7f1983cfcfa8dc3231c0a..84f87047b531c864d580c00247259b43847d1006 100644
--- a/src/compiler/translator/SymbolTable_autogen.cpp
+++ b/src/compiler/translator/SymbolTable_autogen.cpp
@@ -25,7 +25,7 @@ using TableBase = TSymbolTableBase;
 
 struct SymbolIdChecker
 {
-    static_assert(TSymbolTable::kFirstUserDefinedSymbolId > 2021);
+    static_assert(TSymbolTable::kFirstUserDefinedSymbolId > 2022);
 };
 
 namespace BuiltInName
@@ -284,6 +284,7 @@ constexpr const ImmutableString lessThan("lessThan");
 constexpr const ImmutableString lessThanEqual("lessThanEqual");
 constexpr const ImmutableString log("log");
 constexpr const ImmutableString log2("log2");
+constexpr const ImmutableString loopForwardProgress("loopForwardProgress");
 constexpr const ImmutableString matrixCompMult("matrixCompMult");
 constexpr const ImmutableString max("max");
 constexpr const ImmutableString memoryBarrier("memoryBarrier");
@@ -17251,6 +17252,15 @@ constexpr const TFunction interpolateAtCenter_30B(
     StaticType::Get<EbtFloat, EbpUndefined, EvqGlobal, 4, 1>(),
     EOpInterpolateAtCenter,
     true);
+constexpr const TFunction loopForwardProgress_(
+    BuiltInId::loopForwardProgress,
+    BuiltInName::loopForwardProgress,
+    std::array<TExtension, 1u>{{TExtension::UNDEFINED}},
+    BuiltInParameters::empty,
+    0,
+    StaticType::Get<EbtVoid, EbpUndefined, EvqGlobal, 1, 1>(),
+    EOpLoopForwardProgress,
+    false);
 constexpr const TFunction saturate_00B(BuiltInId::saturate_Float1,
                                        BuiltInName::saturate,
                                        std::array<TExtension, 1u>{{TExtension::UNDEFINED}},
@@ -19220,6 +19230,7 @@ constexpr SymbolRule kRules[] = {
     Rule::Get<kESSLInternalBackendBuiltIns, Shader::FRAGMENT, 0>(&interpolateAtCenter_10B),
     Rule::Get<kESSLInternalBackendBuiltIns, Shader::FRAGMENT, 0>(&interpolateAtCenter_20B),
     Rule::Get<kESSLInternalBackendBuiltIns, Shader::FRAGMENT, 0>(&interpolateAtCenter_30B),
+    Rule::Get<kESSLInternalBackendBuiltIns, Shader::ALL, 0>(&loopForwardProgress_),
     Rule::Get<kESSLInternalBackendBuiltIns, Shader::ALL, 0>(&saturate_00B),
     Rule::Get<kESSLInternalBackendBuiltIns, Shader::ALL, 0>(&saturate_10B),
     Rule::Get<kESSLInternalBackendBuiltIns, Shader::ALL, 0>(&saturate_20B),
@@ -20927,6 +20938,7 @@ constexpr const char *kMangledNames[] = {"radians(00B",
                                          "interpolateAtCenter(10B",
                                          "interpolateAtCenter(20B",
                                          "interpolateAtCenter(30B",
+                                         "loopForwardProgress(",
                                          "saturate(00B",
                                          "saturate(10B",
                                          "saturate(20B",
@@ -22352,130 +22364,131 @@ constexpr uint16_t kMangledOffsets[] = {
     1779,  // interpolateAtCenter_10B
     1780,  // interpolateAtCenter_20B
     1781,  // interpolateAtCenter_30B
-    1782,  // saturate_00B
-    1783,  // saturate_10B
-    1784,  // saturate_20B
-    1785,  // saturate_30B
-    1786,  // gl_DepthRangeParameters
-    1787,  // gl_DepthRange
-    1788,  // gl_NumSamples
-    1790,  // gl_MaxVertexAttribs
-    1791,  // gl_MaxVertexUniformVectors
-    1792,  // gl_MaxVertexTextureImageUnits
-    1793,  // gl_MaxCombinedTextureImageUnits
-    1794,  // gl_MaxTextureImageUnits
-    1795,  // gl_MaxFragmentUniformVectors
-    1796,  // gl_MaxVaryingVectors
-    1797,  // gl_MaxDrawBuffers
-    1798,  // gl_MaxDualSourceDrawBuffersEXT
-    1799,  // gl_MaxVertexOutputVectors
-    1800,  // gl_MaxFragmentInputVectors
-    1801,  // gl_MinProgramTexelOffset
-    1802,  // gl_MaxProgramTexelOffset
-    1803,  // gl_MaxImageUnits
-    1804,  // gl_MaxVertexImageUniforms
-    1805,  // gl_MaxFragmentImageUniforms
-    1806,  // gl_MaxComputeImageUniforms
-    1807,  // gl_MaxCombinedImageUniforms
-    1808,  // gl_MaxCombinedShaderOutputResources
-    1809,  // gl_MaxComputeWorkGroupCount
-    1810,  // gl_MaxComputeWorkGroupSize
-    1811,  // gl_MaxComputeUniformComponents
-    1812,  // gl_MaxComputeTextureImageUnits
-    1813,  // gl_MaxComputeAtomicCounters
-    1814,  // gl_MaxComputeAtomicCounterBuffers
-    1815,  // gl_MaxVertexAtomicCounters
-    1816,  // gl_MaxFragmentAtomicCounters
-    1817,  // gl_MaxCombinedAtomicCounters
-    1818,  // gl_MaxAtomicCounterBindings
-    1819,  // gl_MaxVertexAtomicCounterBuffers
-    1820,  // gl_MaxFragmentAtomicCounterBuffers
-    1821,  // gl_MaxCombinedAtomicCounterBuffers
-    1822,  // gl_MaxAtomicCounterBufferSize
-    1823,  // gl_MaxGeometryInputComponents
-    1826,  // gl_MaxGeometryOutputComponents
-    1829,  // gl_MaxGeometryImageUniforms
-    1832,  // gl_MaxGeometryTextureImageUnits
-    1835,  // gl_MaxGeometryOutputVertices
-    1838,  // gl_MaxGeometryTotalOutputComponents
-    1841,  // gl_MaxGeometryUniformComponents
-    1844,  // gl_MaxGeometryAtomicCounters
-    1847,  // gl_MaxGeometryAtomicCounterBuffers
-    1850,  // gl_MaxTessControlInputComponents
-    1853,  // gl_MaxTessControlOutputComponents
-    1856,  // gl_MaxTessControlTextureImageUnits
-    1859,  // gl_MaxTessControlUniformComponents
-    1862,  // gl_MaxTessControlTotalOutputComponents
-    1865,  // gl_MaxTessControlImageUniforms
-    1868,  // gl_MaxTessControlAtomicCounters
-    1871,  // gl_MaxTessControlAtomicCounterBuffers
-    1874,  // gl_MaxTessPatchComponents
-    1877,  // gl_MaxPatchVertices
-    1880,  // gl_MaxTessGenLevel
-    1883,  // gl_MaxTessEvaluationInputComponents
-    1886,  // gl_MaxTessEvaluationOutputComponents
-    1889,  // gl_MaxTessEvaluationTextureImageUnits
-    1892,  // gl_MaxTessEvaluationUniformComponents
-    1895,  // gl_MaxTessEvaluationImageUniforms
-    1898,  // gl_MaxTessEvaluationAtomicCounters
-    1901,  // gl_MaxTessEvaluationAtomicCounterBuffers
-    1904,  // gl_MaxSamples
-    1906,  // gl_MaxClipDistances
-    1909,  // gl_MaxCullDistances
-    1911,  // gl_MaxCombinedClipAndCullDistances
-    1913,  // gl_FragCoord
-    1915,  // gl_FrontFacing
-    1916,  // gl_PointCoord
-    1917,  // gl_FragColor
-    1918,  // gl_FragData
-    1919,  // gl_FragDepth
-    1920,  // gl_HelperInvocation
-    1921,  // gl_SecondaryFragColorEXT
-    1922,  // gl_SecondaryFragDataEXT
-    1923,  // gl_FragDepthEXT
-    1924,  // gl_LastFragData
-    1927,  // gl_LastFragColor
-    1928,  // gl_LastFragColorARM
-    1929,  // gl_LastFragDepthARM
-    1930,  // gl_LastFragStencilARM
-    1931,  // gl_PrimitiveID
-    1943,  // gl_Layer
-    1950,  // gl_SampleID
-    1952,  // gl_SamplePosition
-    1954,  // gl_SampleMaskIn
-    1956,  // gl_SampleMask
-    1958,  // gl_Position
-    1968,  // gl_PointSize
-    1970,  // gl_InstanceID
-    1971,  // gl_InstanceIndex
-    1972,  // gl_VertexID
-    1973,  // gl_VertexIndex
-    1974,  // gl_DrawID
-    1975,  // gl_BaseVertex
-    1976,  // gl_BaseInstance
-    1977,  // angle_BaseVertex
-    1978,  // angle_BaseInstance
-    1979,  // gl_ClipDistance
-    1982,  // gl_NumWorkGroups
-    1983,  // gl_WorkGroupSize
-    1984,  // gl_WorkGroupID
-    1985,  // gl_LocalInvocationID
-    1986,  // gl_GlobalInvocationID
-    1987,  // gl_LocalInvocationIndex
-    1988,  // gl_PrimitiveIDIn
-    1991,  // gl_InvocationID
-    1997,  // gl_PerVertex
-    2006,  // gl_in
-    2015,  // gl_PatchVerticesIn
-    2021,  // gl_TessLevelOuter
-    2027,  // gl_TessLevelInner
-    2033,  // gl_out
-    2039,  // gl_BoundingBox
-    2042,  // gl_BoundingBoxEXT
-    2045,  // gl_BoundingBoxOES
-    2048,  // gl_TessCoord
-    2049,  // gl_ViewID_OVR
-    2050,  // gl_CullDistance
+    1782,  // loopForwardProgress_
+    1783,  // saturate_00B
+    1784,  // saturate_10B
+    1785,  // saturate_20B
+    1786,  // saturate_30B
+    1787,  // gl_DepthRangeParameters
+    1788,  // gl_DepthRange
+    1789,  // gl_NumSamples
+    1791,  // gl_MaxVertexAttribs
+    1792,  // gl_MaxVertexUniformVectors
+    1793,  // gl_MaxVertexTextureImageUnits
+    1794,  // gl_MaxCombinedTextureImageUnits
+    1795,  // gl_MaxTextureImageUnits
+    1796,  // gl_MaxFragmentUniformVectors
+    1797,  // gl_MaxVaryingVectors
+    1798,  // gl_MaxDrawBuffers
+    1799,  // gl_MaxDualSourceDrawBuffersEXT
+    1800,  // gl_MaxVertexOutputVectors
+    1801,  // gl_MaxFragmentInputVectors
+    1802,  // gl_MinProgramTexelOffset
+    1803,  // gl_MaxProgramTexelOffset
+    1804,  // gl_MaxImageUnits
+    1805,  // gl_MaxVertexImageUniforms
+    1806,  // gl_MaxFragmentImageUniforms
+    1807,  // gl_MaxComputeImageUniforms
+    1808,  // gl_MaxCombinedImageUniforms
+    1809,  // gl_MaxCombinedShaderOutputResources
+    1810,  // gl_MaxComputeWorkGroupCount
+    1811,  // gl_MaxComputeWorkGroupSize
+    1812,  // gl_MaxComputeUniformComponents
+    1813,  // gl_MaxComputeTextureImageUnits
+    1814,  // gl_MaxComputeAtomicCounters
+    1815,  // gl_MaxComputeAtomicCounterBuffers
+    1816,  // gl_MaxVertexAtomicCounters
+    1817,  // gl_MaxFragmentAtomicCounters
+    1818,  // gl_MaxCombinedAtomicCounters
+    1819,  // gl_MaxAtomicCounterBindings
+    1820,  // gl_MaxVertexAtomicCounterBuffers
+    1821,  // gl_MaxFragmentAtomicCounterBuffers
+    1822,  // gl_MaxCombinedAtomicCounterBuffers
+    1823,  // gl_MaxAtomicCounterBufferSize
+    1824,  // gl_MaxGeometryInputComponents
+    1827,  // gl_MaxGeometryOutputComponents
+    1830,  // gl_MaxGeometryImageUniforms
+    1833,  // gl_MaxGeometryTextureImageUnits
+    1836,  // gl_MaxGeometryOutputVertices
+    1839,  // gl_MaxGeometryTotalOutputComponents
+    1842,  // gl_MaxGeometryUniformComponents
+    1845,  // gl_MaxGeometryAtomicCounters
+    1848,  // gl_MaxGeometryAtomicCounterBuffers
+    1851,  // gl_MaxTessControlInputComponents
+    1854,  // gl_MaxTessControlOutputComponents
+    1857,  // gl_MaxTessControlTextureImageUnits
+    1860,  // gl_MaxTessControlUniformComponents
+    1863,  // gl_MaxTessControlTotalOutputComponents
+    1866,  // gl_MaxTessControlImageUniforms
+    1869,  // gl_MaxTessControlAtomicCounters
+    1872,  // gl_MaxTessControlAtomicCounterBuffers
+    1875,  // gl_MaxTessPatchComponents
+    1878,  // gl_MaxPatchVertices
+    1881,  // gl_MaxTessGenLevel
+    1884,  // gl_MaxTessEvaluationInputComponents
+    1887,  // gl_MaxTessEvaluationOutputComponents
+    1890,  // gl_MaxTessEvaluationTextureImageUnits
+    1893,  // gl_MaxTessEvaluationUniformComponents
+    1896,  // gl_MaxTessEvaluationImageUniforms
+    1899,  // gl_MaxTessEvaluationAtomicCounters
+    1902,  // gl_MaxTessEvaluationAtomicCounterBuffers
+    1905,  // gl_MaxSamples
+    1907,  // gl_MaxClipDistances
+    1910,  // gl_MaxCullDistances
+    1912,  // gl_MaxCombinedClipAndCullDistances
+    1914,  // gl_FragCoord
+    1916,  // gl_FrontFacing
+    1917,  // gl_PointCoord
+    1918,  // gl_FragColor
+    1919,  // gl_FragData
+    1920,  // gl_FragDepth
+    1921,  // gl_HelperInvocation
+    1922,  // gl_SecondaryFragColorEXT
+    1923,  // gl_SecondaryFragDataEXT
+    1924,  // gl_FragDepthEXT
+    1925,  // gl_LastFragData
+    1928,  // gl_LastFragColor
+    1929,  // gl_LastFragColorARM
+    1930,  // gl_LastFragDepthARM
+    1931,  // gl_LastFragStencilARM
+    1932,  // gl_PrimitiveID
+    1944,  // gl_Layer
+    1951,  // gl_SampleID
+    1953,  // gl_SamplePosition
+    1955,  // gl_SampleMaskIn
+    1957,  // gl_SampleMask
+    1959,  // gl_Position
+    1969,  // gl_PointSize
+    1971,  // gl_InstanceID
+    1972,  // gl_InstanceIndex
+    1973,  // gl_VertexID
+    1974,  // gl_VertexIndex
+    1975,  // gl_DrawID
+    1976,  // gl_BaseVertex
+    1977,  // gl_BaseInstance
+    1978,  // angle_BaseVertex
+    1979,  // angle_BaseInstance
+    1980,  // gl_ClipDistance
+    1983,  // gl_NumWorkGroups
+    1984,  // gl_WorkGroupSize
+    1985,  // gl_WorkGroupID
+    1986,  // gl_LocalInvocationID
+    1987,  // gl_GlobalInvocationID
+    1988,  // gl_LocalInvocationIndex
+    1989,  // gl_PrimitiveIDIn
+    1992,  // gl_InvocationID
+    1998,  // gl_PerVertex
+    2007,  // gl_in
+    2016,  // gl_PatchVerticesIn
+    2022,  // gl_TessLevelOuter
+    2028,  // gl_TessLevelInner
+    2034,  // gl_out
+    2040,  // gl_BoundingBox
+    2043,  // gl_BoundingBoxEXT
+    2046,  // gl_BoundingBoxOES
+    2049,  // gl_TessCoord
+    2050,  // gl_ViewID_OVR
+    2051,  // gl_CullDistance
 };
 
 using Ext = TExtension;
@@ -22696,6 +22709,8 @@ constexpr UnmangledEntry unmangled[] = {
      Shader::FRAGMENT},
     {"interpolateAtCenter", std::array<TExtension, 1>{{Ext::UNDEFINED}},
      kESSLInternalBackendBuiltIns, Shader::FRAGMENT},
+    {"loopForwardProgress", std::array<TExtension, 1>{{Ext::UNDEFINED}},
+     kESSLInternalBackendBuiltIns, Shader::ALL},
     {"saturate", std::array<TExtension, 1>{{Ext::UNDEFINED}}, kESSLInternalBackendBuiltIns,
      Shader::ALL}};
 
@@ -24092,8 +24107,10 @@ namespace
 {
 uint16_t GetNextRuleIndex(uint32_t nameHash)
 {
-    if (nameHash == 1422 - 1)
+    if (nameHash == 1423 - 1)
+    {
         return ArraySize(BuiltInArray::kRules);
+    }
     return BuiltInArray::kMangledOffsets[nameHash + 1];
 }
 }  // namespace
@@ -24104,8 +24121,10 @@ const TSymbol *TSymbolTable::findBuiltIn(const ImmutableString &name, int shader
         return nullptr;
 
     uint32_t nameHash = name.mangledNameHash();
-    if (nameHash >= 1422)
+    if (nameHash >= 1423)
+    {
         return nullptr;
+    }
 
     const char *actualName = BuiltInArray::kMangledNames[nameHash];
     if (name != actualName)
@@ -24126,8 +24145,10 @@ bool TSymbolTable::isUnmangledBuiltInName(const ImmutableString &name,
         return false;
 
     uint32_t nameHash = name.unmangledNameHash();
-    if (nameHash >= 179)
+    if (nameHash >= 180)
+    {
         return false;
+    }
 
     return BuiltInArray::unmangled[nameHash].matches(name, mShaderSpec, shaderVersion, mShaderType,
                                                      extensions);
diff --git a/src/compiler/translator/builtin_function_declarations.txt b/src/compiler/translator/builtin_function_declarations.txt
index 83d1bee2f929c154fc942abc4ce65972e3931322..4708a4e5174a2ec97774912ff92e16d3604aa63e 100644
--- a/src/compiler/translator/builtin_function_declarations.txt
+++ b/src/compiler/translator/builtin_function_declarations.txt
@@ -875,6 +875,8 @@ GROUP END MetalFragmentSample
 
 // MSL common functions
 GROUP BEGIN MetalCommon
+  DEFAULT METADATA {"essl_level": "ESSL_INTERNAL_BACKEND_BUILTINS", "hasSideEffects": true}
+    void loopForwardProgress();
   DEFAULT METADATA {"essl_level": "ESSL_INTERNAL_BACKEND_BUILTINS"}
     genType saturate(genType);
 GROUP END MetalCommon
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 15e399b6556026a8ef7f632175607b56eefca55b..f10bb7abc48dfde26c6634daf7af9a5ad2ec1da1 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index d5a48edd40f382359db76acf1a1ce75b6a6dc6d5..907c62e0bb659292b3912707904981863429478a 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/msl/EmitMetal.cpp b/src/compiler/translator/msl/EmitMetal.cpp
index 664e8d49b3e010011e1530371acb29088fb84964..d0619656cc637e3f5af3fc5813823b013e908175 100644
--- a/src/compiler/translator/msl/EmitMetal.cpp
+++ b/src/compiler/translator/msl/EmitMetal.cpp
@@ -181,12 +181,17 @@ class GenMetalTraverser : public TIntermTraverser
 
     void emitSingleConstant(const TConstantUnion *const constUnion);
 
+    void emitForwardProgressStore();
+    void emitForwardProgressSignal();
+    bool shouldEnsureForwardProgress() const { return mForwardProgressStoreNestingCount >= 0; }
+
   private:
     Sink &mOut;
     const TCompiler &mCompiler;
     const PipelineStructs &mPipelineStructs;
     SymbolEnv &mSymbolEnv;
     IdGen &mIdGen;
+    int mForwardProgressStoreNestingCount = -1;  // Negative means forward progress is not ensured.
     int mIndentLevel                  = -1;
     int mLastIndentationPos           = -1;
     int mOpenPointerParenCount        = 0;
@@ -201,8 +206,45 @@ class GenMetalTraverser : public TIntermTraverser
     size_t mDriverUniformsBindingIndex     = 0;
     size_t mUBOArgumentBufferBindingIndex  = 0;
     bool mRasterOrderGroupsSupported       = false;
-    bool mInjectAsmStatementIntoLoopBodies = false;
+    friend class ScopedForwardProgressStore;
+};
+
+class ScopedForwardProgressStore
+{
+  public:
+    ScopedForwardProgressStore(GenMetalTraverser &traverser);
+    ~ScopedForwardProgressStore();
+
+  private:
+    GenMetalTraverser &mTraverser;
 };
+
+ScopedForwardProgressStore::ScopedForwardProgressStore(GenMetalTraverser &traverser)
+    : mTraverser(traverser)
+{
+    if (mTraverser.shouldEnsureForwardProgress())
+    {
+        if (mTraverser.mForwardProgressStoreNestingCount == 0)
+        {
+            mTraverser.emitOpenBrace();
+            mTraverser.emitForwardProgressStore();
+        }
+        ++mTraverser.mForwardProgressStoreNestingCount;
+    }
+}
+
+ScopedForwardProgressStore::~ScopedForwardProgressStore()
+{
+    if (mTraverser.shouldEnsureForwardProgress())
+    {
+        --mTraverser.mForwardProgressStoreNestingCount;
+        if (mTraverser.mForwardProgressStoreNestingCount == 0)
+        {
+            mTraverser.emitCloseBrace();
+        }
+    }
+}
+
 }  // anonymous namespace
 
 GenMetalTraverser::~GenMetalTraverser()
@@ -228,9 +270,13 @@ GenMetalTraverser::GenMetalTraverser(const TCompiler &compiler,
       mDriverUniformsBindingIndex(compileOptions.metal.driverUniformsBindingIndex),
       mUBOArgumentBufferBindingIndex(compileOptions.metal.UBOArgumentBufferBindingIndex),
       mRasterOrderGroupsSupported(compileOptions.pls.fragmentSyncType ==
-                                  ShFragmentSynchronizationType::RasterOrderGroups_Metal),
-      mInjectAsmStatementIntoLoopBodies(compileOptions.metal.injectAsmStatementIntoLoopBodies)
-{}
+                                  ShFragmentSynchronizationType::RasterOrderGroups_Metal)
+{
+    if (compileOptions.metal.injectAsmStatementIntoLoopBodies)
+    {
+        mForwardProgressStoreNestingCount = 0;
+    }
+}
 
 void GenMetalTraverser::emitIndentation()
 {
@@ -282,16 +328,6 @@ static const char *GetOperatorString(TOperator op,
             return resultType.isSignedInt() ? "ANGLE_addAssignInt" : "+=";
         case TOperator::EOpSubAssign:
             return resultType.isSignedInt() ? "ANGLE_subAssignInt" : "-=";
-        case TOperator::EOpMulAssign:
-            return "*=";
-        case TOperator::EOpDivAssign:
-            return "/=";
-        case TOperator::EOpIModAssign:
-            return "%=";
-        case TOperator::EOpBitShiftLeftAssign:
-            return "<<=";  // TODO: Check logical vs arithmetic shifting.
-        case TOperator::EOpBitShiftRightAssign:
-            return ">>=";  // TODO: Check logical vs arithmetic shifting.
         case TOperator::EOpBitwiseAndAssign:
             return "&=";
         case TOperator::EOpBitwiseXorAssign:
@@ -302,16 +338,6 @@ static const char *GetOperatorString(TOperator op,
             return resultType.isSignedInt() ? "ANGLE_addInt" : "+";
         case TOperator::EOpSub:
             return resultType.isSignedInt() ? "ANGLE_subInt" : "-";
-        case TOperator::EOpMul:
-            return "*";
-        case TOperator::EOpDiv:
-            return "/";
-        case TOperator::EOpIMod:
-            return "%";
-        case TOperator::EOpBitShiftLeft:
-            return "<<";  // TODO: Check logical vs arithmetic shifting.
-        case TOperator::EOpBitShiftRight:
-            return ">>";  // TODO: Check logical vs arithmetic shifting.
         case TOperator::EOpBitwiseAnd:
             return "&";
         case TOperator::EOpBitwiseXor:
@@ -363,16 +389,12 @@ static const char *GetOperatorString(TOperator op,
             return resultType.isSignedInt() ? "ANGLE_preIncrementInt" : "++";
         case TOperator::EOpPreDecrement:
             return resultType.isSignedInt() ? "ANGLE_preDecrementInt" : "--";
-        case TOperator::EOpVectorTimesScalarAssign:
-            return "*=";
         case TOperator::EOpVectorTimesMatrixAssign:
             return "*=";
         case TOperator::EOpMatrixTimesScalarAssign:
             return "*=";
         case TOperator::EOpMatrixTimesMatrixAssign:
             return "*=";
-        case TOperator::EOpVectorTimesScalar:
-            return "*";
         case TOperator::EOpVectorTimesMatrix:
             return "*";
         case TOperator::EOpMatrixTimesVector:
@@ -386,6 +408,30 @@ static const char *GetOperatorString(TOperator op,
         case TOperator::EOpNotEqualComponentWise:
             return "!=";
 
+        case TOperator::EOpBitShiftRight:
+        case TOperator::EOpBitShiftRightAssign:
+            // TODO: Check logical vs arithmetic shifting.
+            return "ANGLE_rshift";
+
+        case TOperator::EOpBitShiftLeft:
+        case TOperator::EOpBitShiftLeftAssign:
+            // TODO: Check logical vs arithmetic shifting.
+            return resultType.isSignedInt() ? "ANGLE_ilshift" : "ANGLE_ulshift";
+
+        case TOperator::EOpMulAssign:
+        case TOperator::EOpMul:
+        case TOperator::EOpVectorTimesScalarAssign:
+        case TOperator::EOpVectorTimesScalar:
+            return resultType.isSignedInt() ? "ANGLE_imul" : "*";
+
+        case TOperator::EOpDiv:
+        case TOperator::EOpDivAssign:
+            return resultType.isSignedInt() ? "ANGLE_div" : "/";
+
+        case TOperator::EOpIMod:
+        case TOperator::EOpIModAssign:
+            return resultType.isSignedInt() ? "ANGLE_imod" : "%";
+
         case TOperator::EOpEqual:
             if ((argType0->getStruct() && argType1->getStruct()) &&
                 (argType0->isArray() && argType1->isArray()))
@@ -523,6 +569,8 @@ static const char *GetOperatorString(TOperator op,
             return "metal::rint";
         case TOperator::EOpClamp:
             return "metal::clamp";  // TODO fast vs precise namespace
+        case TOperator::EOpLoopForwardProgress:
+            return "ANGLE_loopForwardProgress";
         case TOperator::EOpSaturate:
             return "metal::saturate";  // TODO fast vs precise namespace
         case TOperator::EOpMix:
@@ -882,17 +930,14 @@ void GenMetalTraverser::emitPostQualifier(const EmitVariableDeclarationConfig &e
 
 void GenMetalTraverser::emitLoopBody(TIntermBlock *bodyNode)
 {
-    if (mInjectAsmStatementIntoLoopBodies)
+    const bool emitForwardProgress = shouldEnsureForwardProgress();
+    if (emitForwardProgress)
     {
         emitOpenBrace();
-
-        emitIndentation();
-        mOut << "__asm__(\"\");\n";
+        emitForwardProgressSignal();
     }
-
     bodyNode->traverse(this);
-
-    if (mInjectAsmStatementIntoLoopBodies)
+    if (emitForwardProgress)
     {
         emitCloseBrace();
     }
@@ -1813,6 +1858,18 @@ bool GenMetalTraverser::visitBinary(Visit, TIntermBinary *binaryNode)
         }
         break;
 
+        case TOperator::EOpDivAssign:
+        case TOperator::EOpIModAssign:
+        case TOperator::EOpBitShiftRightAssign:
+        case TOperator::EOpBitShiftLeftAssign:
+        case TOperator::EOpAddAssign:
+        case TOperator::EOpSubAssign:
+        case TOperator::EOpMulAssign:
+        case TOperator::EOpVectorTimesScalarAssign:
+            leftNode.traverse(this);
+            mOut << " = ";
+            [[fallthrough]];
+
         default:
         {
             const TType &resultType = binaryNode->getType();
@@ -2248,8 +2305,32 @@ bool GenMetalTraverser::visitAggregate(Visit, TIntermAggregate *aggregateNode)
             emitArgList("{", "}");
         }
         else
+        {
+            bool isFtoi = [&]() {
+                if ((!retType.isScalar() && !retType.isVector()) ||
+                    !IsInteger(retType.getBasicType()))
+                {
+                    return false;
+                }
+                if (aggregateNode->getChildCount() != 1)
+                {
+                    return false;
+                }
+                auto &argType = aggregateNode->getChildNode(0)->getAsTyped()->getType();
+                return (argType.isScalar() || argType.isVector()) &&
+                       argType.getBasicType() == EbtFloat;
+            }();
+
+            if (isFtoi)
+            {
+                mOut << "ANGLE_ftoi<";
+                emitType(retType, etConfig);
+                mOut << ">";
+            }
+            else
             {
                 emitType(retType, etConfig);
+            }
             emitArgList("(", ")");
         }
 
@@ -2374,6 +2455,26 @@ void GenMetalTraverser::emitCloseBrace()
     mOut << "}";
 }
 
+void GenMetalTraverser::emitForwardProgressStore()
+{
+    // https://eel.is/c++draft/intro.progress
+    // "The implementation may assume that any thread will eventually do one of the following:""
+    //  - ...
+    //  - "perform an access through a volatile glvalue"
+    // Emit a volatile variable which all loops in the stack will access.
+    emitIndentation();
+    mOut << "volatile bool ANGLE_p;\n";
+}
+
+void GenMetalTraverser::emitForwardProgressSignal()
+{
+    // Emit a read though the volatile variable. This marks the loop as making forward progress even
+    // if the compiler can otherwise analyze it to be infinite. This ensures that the loop
+    // has defined behavior.
+    emitIndentation();
+    mOut << "(void) ANGLE_p;\n";
+}
+
 static bool RequiresSemicolonTerminator(TIntermNode &node)
 {
     if (node.getAsBlock())
@@ -2575,6 +2676,8 @@ bool GenMetalTraverser::visitForLoop(TIntermLoop *loopNode)
     TIntermTyped *condNode = loopNode->getCondition();
     TIntermTyped *exprNode = loopNode->getExpression();
 
+    ScopedForwardProgressStore scopedProgress(*this);
+
     mOut << "for (";
 
     if (initNode)
@@ -2617,6 +2720,7 @@ bool GenMetalTraverser::visitWhileLoop(TIntermLoop *loopNode)
     ASSERT(condNode);
     ASSERT(!initNode && !exprNode);
 
+    ScopedForwardProgressStore scopedProgress(*this);
     emitIndentation();
     mOut << "while (";
     condNode->traverse(this);
@@ -2636,6 +2740,7 @@ bool GenMetalTraverser::visitDoWhileLoop(TIntermLoop *loopNode)
     ASSERT(condNode);
     ASSERT(!initNode && !exprNode);
 
+    ScopedForwardProgressStore scopedProgress(*this);
     emitIndentation();
     mOut << "do\n";
     emitLoopBody(loopNode->getBody());
diff --git a/src/compiler/translator/msl/ProgramPrelude.cpp b/src/compiler/translator/msl/ProgramPrelude.cpp
index 90a8bca03b4488543bfe474a5a54bc22d42e65df..9fb421a5670d98fae5591784b33acc1a4f95ea42 100644
--- a/src/compiler/translator/msl/ProgramPrelude.cpp
+++ b/src/compiler/translator/msl/ProgramPrelude.cpp
@@ -113,6 +113,13 @@ class ProgramPrelude : public TIntermTraverser
     void degrees();
     void radians();
     void mod();
+    void div();
+    void imod();
+    void imul();
+    void ilshift();
+    void ulshift();
+    void rshift();
+    void ftoi();
     void mixBool();
     void postIncrementMatrix();
     void preIncrementMatrix();
@@ -285,6 +292,7 @@ class ProgramPrelude : public TIntermTraverser
     void addAssignInt();
     void subInt();
     void subAssignInt();
+    void loopForwardProgress();
 
   private:
     TInfoSinkBase &mOut;
@@ -439,6 +447,116 @@ ANGLE_ALWAYS_INLINE X ANGLE_mod(X x, Y y)
 }
 )")
 
+// Avoid undefined behavior when:
+// - the divisor is 0
+// - the dividend is INT_MIN and the divisor is -1 (integer overflow)
+// When the behavior would be undefined the result is `x`.
+// FIXME: This function should also handle INT_MIN / -1, but currently this hits a bug in the metal
+// compiler
+PROGRAM_PRELUDE_DECLARE(div,
+                        R"(
+template<typename X, typename Y, typename Z = metal::conditional_t<metal::is_scalar_v<Y>, X, Y>>
+ANGLE_ALWAYS_INLINE Z ANGLE_div(X x, Y y)
+{
+    Z zx = Z(x);
+    Z zy = Z(y);
+    auto predicate = zy == Z(0);
+    return zx / metal::select(zy, Z(1), predicate);
+}
+)")
+
+// Avoid undefined behavior when:
+// - the divisor is 0
+// - the dividend is INT_MIN and the divisor is -1 (integer overflow)
+// - either of the operands is negative (undefined behavior in Metal)
+// When the behavior would be undefined the result is 0.
+// FIXME: This function should also handle INT_MIN % -1, but currently this hits a bug in the metal
+// compiler
+PROGRAM_PRELUDE_DECLARE(imod,
+                        R"(
+template<typename X, typename Y, typename Z = metal::conditional_t<metal::is_scalar_v<Y>, X, Y>>
+ANGLE_ALWAYS_INLINE Z ANGLE_imod(X x, Y y)
+{
+    if constexpr (metal::is_signed_v<Z>) {
+        Z y_or_one = metal::select(Z(y), Z(1), Z(y) == Z(0));
+        if (metal::any(((Z(x) | y_or_one) & Z(2147483648u)) != Z(0u)))
+        {
+            return as_type<Z>(
+                metal::make_unsigned_t<Z>(x) - metal::make_unsigned_t<Z>(x / y_or_one) * metal::make_unsigned_t<Z>(y_or_one)
+            );
+        }
+        else
+        {
+            return x % y_or_one;
+        }
+    }
+    else
+    {
+        return x % metal::select(Z(y), Z(1u), Z(y) == Z(0u));
+    }
+}
+)")
+
+// Avoid undefined behavior when the operand is outside the range of values that can be represented.
+// When the behavior would be undefined the value is clamped to fit the target type.
+PROGRAM_PRELUDE_DECLARE(ftoi,
+                        R"(
+template <typename X, typename Y>
+ANGLE_ALWAYS_INLINE X ANGLE_ftoi(Y y)
+{
+    auto min = metal::numeric_limits<X>::min();
+    auto max = metal::numeric_limits<X>::max();
+    return X(metal::clamp(y, Y(min), Y(max)));
+}
+)")
+
+// Avoid undefined behavior due to integer overflow
+PROGRAM_PRELUDE_DECLARE(imul,
+                        R"(
+template<typename X, typename Y, typename Z = metal::conditional_t<metal::is_scalar_v<Y>, X, Y>>
+ANGLE_ALWAYS_INLINE Z ANGLE_imul(X x, Y y)
+{
+    return as_type<Z>(metal::make_unsigned_t<Z>(x) * metal::make_unsigned_t<Z>(y));
+}
+)")
+
+// Avoid undefined behavior in e1 << e2 when:
+// 1) e2 is larger than the bit width of the type
+// 2) e2 is a negative value.
+// 3) e1 is a negative value
+PROGRAM_PRELUDE_DECLARE(ilshift,
+                        R"(
+template <typename X, typename Y>
+ANGLE_ALWAYS_INLINE X ANGLE_ilshift(X x, Y y)
+{
+    return as_type<X>(metal::select(metal::make_unsigned_t<X>(0), metal::make_unsigned_t<X>(x) << (y & Y(31)), metal::make_unsigned_t<Y>(y) < metal::make_unsigned_t<Y>(32)));
+}
+)")
+
+// Avoid undefined behavior in e1 << e2 when:
+// 1) e2 is larger than the bit width of the type
+// 2) e2 is a negative value.
+PROGRAM_PRELUDE_DECLARE(ulshift,
+                        R"(
+template <typename X, typename Y>
+ANGLE_ALWAYS_INLINE X ANGLE_ulshift(X x, Y y)
+{
+    return metal::select(X(0), x << (y & Y(31)), metal::make_unsigned_t<Y>(y) < metal::make_unsigned_t<Y>(32));
+}
+)")
+
+// Avoid undefined behavior in e1 >> e2 when:
+// 1) e2 is larger than the bit width of the type
+// 2) e2 is a negative value.
+PROGRAM_PRELUDE_DECLARE(rshift,
+                        R"(
+template <typename X, typename Y>
+ANGLE_ALWAYS_INLINE X ANGLE_rshift(X x, Y y)
+{
+    return metal::select(X(0), x >> (y & Y(31)), metal::make_unsigned_t<Y>(y) < metal::make_unsigned_t<Y>(32));
+}
+)")
+
 PROGRAM_PRELUDE_DECLARE(mixBool,
                         R"(
 template <typename T, int N>
@@ -2860,6 +2978,14 @@ ANGLE_ALWAYS_INLINE thread X &ANGLE_subAssignInt(thread X &x, Y y)
 }
 )")
 
+PROGRAM_PRELUDE_DECLARE(loopForwardProgress,
+                        R"(
+ANGLE_ALWAYS_INLINE void ANGLE_loopForwardProgress()
+{
+    volatile bool p = true;
+}
+)")
+
 ////////////////////////////////////////////////////////////////////////////////
 
 // Returned Name is valid for as long as `buffer` is still alive.
@@ -3371,6 +3497,10 @@ void ProgramPrelude::visitOperator(TOperator op,
         case TOperator::EOpMod:
             mod();
             break;
+        case TOperator::EOpIModAssign:
+        case TOperator::EOpIMod:
+            imod();
+            break;
         case TOperator::EOpRefract:
             if (argType0->isScalar())
             {
@@ -3565,7 +3695,22 @@ void ProgramPrelude::visitOperator(TOperator op,
             }
             break;
 
+        case TOperator::EOpMul:
+        case TOperator::EOpMulAssign:
+        case TOperator::EOpVectorTimesScalar:
+        case TOperator::EOpVectorTimesScalarAssign:
+            if (argType0->isSignedInt())
+            {
+                imul();
+            }
+            if (argType0->isSignedInt())
+            {
+                subAssignInt();
+            }
+            break;
+
         case TOperator::EOpDiv:
+        case TOperator::EOpDivAssign:
             if (argType1->isMatrix())
             {
                 if (argType0->isMatrix())
@@ -3577,12 +3722,9 @@ void ProgramPrelude::visitOperator(TOperator op,
                     divScalarMatrix();
                 }
             }
-            break;
-
-        case TOperator::EOpDivAssign:
-            if (argType0->isMatrix() && argType1->isMatrix())
+            else
             {
-                componentWiseDivideAssign();
+                div();
             }
             break;
 
@@ -3669,20 +3811,31 @@ void ProgramPrelude::visitOperator(TOperator op,
             }
             break;
 
+        case TOperator::EOpBitShiftLeft:
+        case TOperator::EOpBitShiftLeftAssign:
+        {
+            if (argType0->isSignedInt())
+            {
+                ilshift();
+            }
+            else
+            {
+                ulshift();
+            }
+            break;
+        }
+
+        case TOperator::EOpBitShiftRight:
+        case TOperator::EOpBitShiftRightAssign:
+            rshift();
+            break;
+
         case TOperator::EOpComma:
         case TOperator::EOpAssign:
         case TOperator::EOpInitialize:
-        case TOperator::EOpMulAssign:
-        case TOperator::EOpIModAssign:
-        case TOperator::EOpBitShiftLeftAssign:
-        case TOperator::EOpBitShiftRightAssign:
         case TOperator::EOpBitwiseAndAssign:
         case TOperator::EOpBitwiseXorAssign:
         case TOperator::EOpBitwiseOrAssign:
-        case TOperator::EOpMul:
-        case TOperator::EOpIMod:
-        case TOperator::EOpBitShiftLeft:
-        case TOperator::EOpBitShiftRight:
         case TOperator::EOpBitwiseAnd:
         case TOperator::EOpBitwiseXor:
         case TOperator::EOpBitwiseOr:
@@ -3701,10 +3854,8 @@ void ProgramPrelude::visitOperator(TOperator op,
         case TOperator::EOpLogicalNot:
         case TOperator::EOpNotComponentWise:
         case TOperator::EOpBitwiseNot:
-        case TOperator::EOpVectorTimesScalarAssign:
         case TOperator::EOpVectorTimesMatrixAssign:
         case TOperator::EOpMatrixTimesScalarAssign:
-        case TOperator::EOpVectorTimesScalar:
         case TOperator::EOpVectorTimesMatrix:
         case TOperator::EOpMatrixTimesVector:
         case TOperator::EOpMatrixTimesScalar:
@@ -3775,6 +3926,10 @@ void ProgramPrelude::visitOperator(TOperator op,
             ASSERT(!func);
             break;
 
+        case TOperator::EOpLoopForwardProgress:
+            loopForwardProgress();
+            break;
+
         case TOperator::EOpCallFunctionInAST:
         case TOperator::EOpCallInternalRawFunction:
         default:
@@ -3872,6 +4027,17 @@ bool ProgramPrelude::visitAggregate(Visit visit, TIntermAggregate *node)
 
     const TFunction *func = node->getFunction();
 
+    if (node->isConstructor() && argCount == 1)
+    {
+        const TType &retType = node->getType();
+        const TType &argType = getArgType(0);
+        if (((retType.isScalar() || retType.isVector()) && IsInteger(retType.getBasicType())) &&
+            ((argType.isScalar() || argType.isVector()) && argType.getBasicType() == EbtFloat))
+        {
+            ftoi();
+        }
+    }
+
     switch (node->getChildCount())
     {
         case 0:
diff --git a/src/compiler/translator/tree_ops/RewriteStructSamplers.cpp b/src/compiler/translator/tree_ops/RewriteStructSamplers.cpp
index 77262ed6e5b598fde791b1b4b9ce9e76afaf288f..4fe85335464b239c04da3f100c57962c10426e46 100644
--- a/src/compiler/translator/tree_ops/RewriteStructSamplers.cpp
+++ b/src/compiler/translator/tree_ops/RewriteStructSamplers.cpp
@@ -39,18 +39,20 @@ using StructureMap        = angle::HashMap<const TStructure *, StructureData>;
 using StructureUniformMap = angle::HashMap<const TVariable *, const TVariable *>;
 using ExtractedSamplerMap = angle::HashMap<std::string, const TVariable *>;
 
-TIntermTyped *RewriteModifiedStructFieldSelectionExpression(
+bool RewriteModifiedStructFieldSelectionExpression(
     TCompiler *compiler,
     TIntermBinary *node,
     const StructureMap &structureMap,
     const StructureUniformMap &structureUniformMap,
-    const ExtractedSamplerMap &extractedSamplers);
+    const ExtractedSamplerMap &extractedSamplers,
+    TIntermTyped **rewritten);
 
-TIntermTyped *RewriteExpressionVisitBinaryHelper(TCompiler *compiler,
+bool RewriteExpressionVisitBinaryHelper(TCompiler *compiler,
                                                  TIntermBinary *node,
                                                  const StructureMap &structureMap,
                                                  const StructureUniformMap &structureUniformMap,
-                                                 const ExtractedSamplerMap &extractedSamplers)
+                                                 const ExtractedSamplerMap &extractedSamplers,
+                                                 TIntermTyped **rewritten)
 {
     // Only interested in EOpIndex* binary nodes.
     switch (node->getOp())
@@ -61,20 +63,22 @@ TIntermTyped *RewriteExpressionVisitBinaryHelper(TCompiler *compiler,
         case EOpIndexDirectStruct:
             break;
         default:
-            return nullptr;
+			*rewritten = nullptr;
+            return true;
     }
 
     const TStructure *structure = node->getLeft()->getType().getStruct();
     if (structure == nullptr)
     {
-        return nullptr;
+        return true;
     }
 
     // If the result of the index is not a sampler and the struct is not replaced, there's nothing
     // to do.
     if (!node->getType().isSampler() && structureMap.find(structure) == structureMap.end())
     {
-        return nullptr;
+		*rewritten = nullptr;
+        return true;
     }
 
     // Otherwise, replace the whole expression such that:
@@ -84,8 +88,14 @@ TIntermTyped *RewriteExpressionVisitBinaryHelper(TCompiler *compiler,
     //   the intermediate nodes would have the correct type (and therefore fields).
     ASSERT(structureMap.find(structure) != structureMap.end());
 
-    return RewriteModifiedStructFieldSelectionExpression(compiler, node, structureMap,
-                                                         structureUniformMap, extractedSamplers);
+    if (!RewriteModifiedStructFieldSelectionExpression(compiler, node, structureMap,
+                                                       structureUniformMap, extractedSamplers,
+                                                       rewritten))
+    {
+        return false;
+    }
+
+    return true;
 }
 
 // Given an expression, this traverser calculates a new expression where sampler-in-structs are
@@ -103,13 +113,17 @@ class RewriteExpressionTraverser final : public TIntermTraverser
           mCompiler(compiler),
           mStructureMap(structureMap),
           mStructureUniformMap(structureUniformMap),
-          mExtractedSamplers(extractedSamplers)
+          mExtractedSamplers(extractedSamplers),
+          mUnsupportedError(false)
     {}
 
     bool visitBinary(Visit visit, TIntermBinary *node) override
     {
-        TIntermTyped *rewritten = RewriteExpressionVisitBinaryHelper(
-            mCompiler, node, mStructureMap, mStructureUniformMap, mExtractedSamplers);
+        TIntermTyped *rewritten = nullptr;
+        if (!RewriteExpressionVisitBinaryHelper(mCompiler, node, mStructureMap, mStructureUniformMap, mExtractedSamplers, &rewritten))
+        {
+            mUnsupportedError = true;
+        }
 
         if (rewritten == nullptr)
         {
@@ -138,6 +152,10 @@ class RewriteExpressionTraverser final : public TIntermTraverser
     const StructureMap &mStructureMap;
     const StructureUniformMap &mStructureUniformMap;
     const ExtractedSamplerMap &mExtractedSamplers;
+
+    // FIXME: Used to communicate that an error occurred during the rewrite process that is currently not
+    // supported so that a failure can be returned to callers of sh::RewriteStructSamplers().
+    bool mUnsupportedError;
 };
 
 // Rewrite the index of an EOpIndexIndirect expression.  The root can never need replacing, because
@@ -179,12 +197,13 @@ void RewriteIndexExpression(TCompiler *compiler,
 //
 // If the expression is not a sampler, it only replaces the struct with the modified one, while
 // still processing the EOpIndexIndirect expressions (which may contain more structs to map).
-TIntermTyped *RewriteModifiedStructFieldSelectionExpression(
+bool RewriteModifiedStructFieldSelectionExpression(
     TCompiler *compiler,
     TIntermBinary *node,
     const StructureMap &structureMap,
     const StructureUniformMap &structureUniformMap,
-    const ExtractedSamplerMap &extractedSamplers)
+    const ExtractedSamplerMap &extractedSamplers,
+    TIntermTyped **rewritten)
 {
     const bool isSampler = node->getType().isSampler();
 
@@ -221,18 +240,17 @@ TIntermTyped *RewriteModifiedStructFieldSelectionExpression(
         iter = iter->getLeft()->getAsBinaryNode();
     }
 
-    TIntermTyped *rewritten = nullptr;
 
     if (isSampler)
     {
         ASSERT(extractedSamplers.find(samplerName) != extractedSamplers.end());
-        rewritten = new TIntermSymbol(extractedSamplers.at(samplerName));
+        *rewritten = new TIntermSymbol(extractedSamplers.at(samplerName));
     }
     else
     {
         const TVariable *baseUniformVar = &baseUniform->variable();
         ASSERT(structureUniformMap.find(baseUniformVar) != structureUniformMap.end());
-        rewritten = new TIntermSymbol(structureUniformMap.at(baseUniformVar));
+        *rewritten = new TIntermSymbol(structureUniformMap.at(baseUniformVar));
     }
 
     // Iterate again and build the expression from bottom up.
@@ -245,13 +263,27 @@ TIntermTyped *RewriteModifiedStructFieldSelectionExpression(
             case EOpIndexDirectStruct:
                 if (!isSampler)
                 {
-                    rewritten =
-                        new TIntermBinary(EOpIndexDirectStruct, rewritten, indexNode->getRight());
+                    // FIXME: Fix accessing fields of structs containing other structs that only contain samplers.
+                    // Currently, given the following example definitions:
+                    //   (e.g., struct S1 { sampler2D sampler; }; struct S2 { int i; S1 s; }; uniform S2 uni;)
+                    // an out of bounds access can occur when trying to access uni.s.sampler because s has been stripped
+                    // out of the replacement structure definition for S2. For now, check that indexing into the field
+                    // list of a structure will not result in an out of bounds array access before attempting to
+                    // create the binary operator node.
+                    const TFieldList &fields = (*rewritten)->getType().getStruct()->fields();
+                    const size_t fieldIndex  = indexNode->getRight()->getAsConstantUnion()->getIConst(0);
+                    if (fieldIndex >= fields.size())
+                    {
+                        return false;
+                    }
+
+                    *rewritten =
+                        new TIntermBinary(EOpIndexDirectStruct, *rewritten, indexNode->getRight());
                 }
                 break;
 
             case EOpIndexDirect:
-                rewritten = new TIntermBinary(EOpIndexDirect, rewritten, indexNode->getRight());
+                *rewritten = new TIntermBinary(EOpIndexDirect, *rewritten, indexNode->getRight());
                 break;
 
             case EOpIndexIndirect:
@@ -262,7 +294,7 @@ TIntermTyped *RewriteModifiedStructFieldSelectionExpression(
                 TIntermTyped *indexExpression = indexNode->getRight();
                 RewriteIndexExpression(compiler, indexExpression, structureMap, structureUniformMap,
                                        extractedSamplers);
-                rewritten = new TIntermBinary(EOpIndexIndirect, rewritten, indexExpression);
+                *rewritten = new TIntermBinary(EOpIndexIndirect, *rewritten, indexExpression);
                 break;
             }
 
@@ -272,7 +304,7 @@ TIntermTyped *RewriteModifiedStructFieldSelectionExpression(
         }
     }
 
-    return rewritten;
+    return true;
 }
 
 class RewriteStructSamplersTraverser final : public TIntermTraverser
@@ -281,7 +313,8 @@ class RewriteStructSamplersTraverser final : public TIntermTraverser
     explicit RewriteStructSamplersTraverser(TCompiler *compiler, TSymbolTable *symbolTable)
         : TIntermTraverser(true, false, false, symbolTable),
           mCompiler(compiler),
-          mRemovedUniformsCount(0)
+          mRemovedUniformsCount(0),
+          mUnsupportedError(false)
     {}
 
     int removedUniformsCount() const { return mRemovedUniformsCount; }
@@ -344,8 +377,11 @@ class RewriteStructSamplersTraverser final : public TIntermTraverser
     // Same implementation as in RewriteExpressionTraverser.  That traverser cannot replace root.
     bool visitBinary(Visit visit, TIntermBinary *node) override
     {
-        TIntermTyped *rewritten = RewriteExpressionVisitBinaryHelper(
-            mCompiler, node, mStructureMap, mStructureUniformMap, mExtractedSamplers);
+        TIntermTyped *rewritten = nullptr;
+        if (!RewriteExpressionVisitBinaryHelper(mCompiler, node, mStructureMap, mStructureUniformMap, mExtractedSamplers, &rewritten))
+        {
+            mUnsupportedError = true;
+        }
 
         if (rewritten == nullptr)
         {
@@ -369,6 +405,8 @@ class RewriteStructSamplersTraverser final : public TIntermTraverser
         }
     }
 
+    bool hasUnsupportedError() const { return mUnsupportedError; }
+
   private:
     bool isActiveUniform(const ImmutableString &rootStructureName)
     {
@@ -635,6 +673,10 @@ class RewriteStructSamplersTraverser final : public TIntermTraverser
 
     // Caches the names of all inactive uniforms.
     TSet<ImmutableString> *mActiveUniforms = nullptr;
+
+	// FIXME: Used to communicate that an error occurred during the rewrite process that is currently not
+    // supported so that a failure can be returned to callers of sh::RewriteStructSamplers().
+    bool mUnsupportedError;
 };
 }  // anonymous namespace
 
@@ -645,6 +687,8 @@ bool RewriteStructSamplers(TCompiler *compiler,
 {
     RewriteStructSamplersTraverser traverser(compiler, symbolTable);
     root->traverse(&traverser);
+    if (traverser.hasUnsupportedError())
+        return false;
     *removedUniformsCountOut = traverser.removedUniformsCount();
     return traverser.updateTree(compiler, root);
 }
diff --git a/src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.cpp b/src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..98a4c8ca63918659ad0133f80101c0625a069baf
--- /dev/null
+++ b/src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.cpp
@@ -0,0 +1,252 @@
+//
+// Copyright 2025 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// EnsureLoopForwardProgress is an AST traverser that inserts volatile variable
+// access inside loops which it cannot prove to be finite.
+//
+
+#include "compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.h"
+
+#include "compiler/translator/Compiler.h"
+#include "compiler/translator/StaticType.h"
+#include "compiler/translator/tree_util/IntermNodePatternMatcher.h"
+#include "compiler/translator/tree_util/IntermNode_util.h"
+#include "compiler/translator/tree_util/IntermTraverse.h"
+
+namespace sh
+{
+
+namespace
+{
+
+const TVariable *ViewSymbolVariable(TIntermTyped &node)
+{
+    TIntermSymbol *symbol = node.getAsSymbolNode();
+    if (symbol == nullptr)
+    {
+        return nullptr;
+    }
+    return &symbol->variable();
+}
+
+bool IsReadOnlyExpr(TIntermTyped &node)
+{
+    switch (node.getQualifier())
+    {
+        case EvqConst:
+        case EvqAttribute:
+        case EvqUniform:
+        case EvqVaryingIn:
+        case EvqSmoothIn:
+        case EvqFlatIn:
+        case EvqNoPerspectiveIn:
+        case EvqCentroidIn:
+        case EvqSampleIn:
+        case EvqNoPerspectiveCentroidIn:
+        case EvqNoPerspectiveSampleIn:
+            return true;
+        default:
+            break;
+    }
+    return false;
+}
+
+const TVariable *computeFiniteLoopVariable(TIntermLoop *loop)
+{
+    // Currently matches only to loop of form:
+    // for (**; cond ; expr)
+    // where
+    //   cond is `variable` `relation` `readonly symbol` and `variable`is of type int or uint
+    //   expr increments or decrements the variable by one.
+    // Assumes ints wrap around in a defined way.
+    TIntermTyped *cond = loop->getCondition();
+    if (cond == nullptr)
+    {
+        return nullptr;
+    }
+    TIntermTyped *expr = loop->getExpression();
+    if (expr == nullptr)
+    {
+        return nullptr;
+    }
+    TIntermBinary *binCond = cond->getAsBinaryNode();
+    if (binCond == nullptr)
+    {
+        return nullptr;
+    }
+    const TVariable *variable = ViewSymbolVariable(*binCond->getLeft());
+    if (variable == nullptr)
+    {
+        return nullptr;
+    }
+    if (!IsInteger(variable->getType().getBasicType()))
+    {
+        return nullptr;
+    }
+    switch (binCond->getOp())
+    {
+        case EOpEqual:
+        case EOpNotEqual:
+        case EOpLessThan:
+        case EOpGreaterThan:
+        case EOpLessThanEqual:
+        case EOpGreaterThanEqual:
+            break;
+        default:
+            return nullptr;
+    }
+    // Loop index must be compared with a constant or uniform or similar read-only variable.
+    if (!IsReadOnlyExpr(*binCond->getRight()))
+    {
+        return nullptr;
+    }
+    if (TIntermUnary *unary = expr->getAsUnaryNode())
+    {
+        switch (unary->getOp())
+        {
+            case EOpPostIncrement:
+            case EOpPreIncrement:
+            case EOpPreDecrement:
+            case EOpPostDecrement:
+                break;
+            default:
+                return nullptr;
+        }
+        if (variable != ViewSymbolVariable(*unary->getOperand()))
+        {
+            return nullptr;
+        }
+    }
+    else if (TIntermBinary *binExpr = expr->getAsBinaryNode())
+    {
+        switch (binExpr->getOp())
+        {
+            case EOpAddAssign:
+            case EOpSubAssign:
+                break;
+            default:
+                return nullptr;
+        }
+        if (variable != ViewSymbolVariable(*binExpr->getLeft()))
+        {
+            return nullptr;
+        }
+        const TConstantUnion *value = binExpr->getRight()->getConstantValue();
+        if (value == nullptr)
+        {
+            return nullptr;
+        }
+        switch (value->getType())
+        {
+            case EbtInt:
+                if (value->getIConst() == -1 || value->getIConst() == 1)
+                {
+                    break;
+                }
+                return nullptr;
+            case EbtUInt:
+                if (value->getUConst() == 1)
+                {
+                    break;
+                }
+                return nullptr;
+            default:
+                UNREACHABLE();
+                return nullptr;
+        }
+    }
+    return variable;
+}
+
+class LoopInfoStack
+{
+  public:
+    LoopInfoStack(TIntermLoop *node, LoopInfoStack *parent);
+    bool isFinite() const { return mVariable != nullptr; }
+    LoopInfoStack *getParent() const { return mParent; }
+    void setNotFinite() { mVariable = nullptr; }
+    LoopInfoStack *findLoopForVariable(const TVariable *variable);
+
+  private:
+    LoopInfoStack *mParent     = nullptr;
+    const TVariable *mVariable = nullptr;
+};
+
+LoopInfoStack::LoopInfoStack(TIntermLoop *node, LoopInfoStack *parent)
+    : mParent(parent), mVariable(computeFiniteLoopVariable(node))
+{}
+
+LoopInfoStack *LoopInfoStack::findLoopForVariable(const TVariable *variable)
+{
+    LoopInfoStack *info = this;
+    do
+    {
+        if (info->mVariable == variable)
+        {
+            return info;
+        }
+        info = info->mParent;
+    } while (info != nullptr);
+    return nullptr;
+}
+
+class EnsureLoopForwardProgressTraverser final : public TLValueTrackingTraverser
+{
+  public:
+    EnsureLoopForwardProgressTraverser(TSymbolTable *symbolTable);
+    void visitSymbol(TIntermSymbol *node) override;
+    void traverseLoop(TIntermLoop *node) override;
+
+  private:
+    LoopInfoStack *mLoopInfoStack = nullptr;
+};
+
+EnsureLoopForwardProgressTraverser::EnsureLoopForwardProgressTraverser(TSymbolTable *symbolTable)
+    : TLValueTrackingTraverser(true, false, false, symbolTable)
+{}
+
+void EnsureLoopForwardProgressTraverser::traverseLoop(TIntermLoop *node)
+{
+    LoopInfoStack loopInfo{node, mLoopInfoStack};
+    mLoopInfoStack = &loopInfo;
+
+    ScopedNodeInTraversalPath addToPath(this, node);
+    node->getBody()->traverse(this);
+
+    if (!loopInfo.isFinite())
+    {
+        TIntermBlock *newBody     = new TIntermBlock();
+        TIntermSequence *sequence = newBody->getSequence();
+        sequence->push_back(CreateBuiltInFunctionCallNode("loopForwardProgress", {}, *mSymbolTable,
+                                                          kESSLInternalBackendBuiltIns));
+        sequence->push_back(node->getBody());
+        node->setBody(newBody);
+    }
+    mLoopInfoStack = mLoopInfoStack->getParent();
+}
+
+void EnsureLoopForwardProgressTraverser::visitSymbol(TIntermSymbol *node)
+{
+    if (!mLoopInfoStack)
+    {
+        return;
+    }
+    LoopInfoStack *loop = mLoopInfoStack->findLoopForVariable(&node->variable());
+    if (loop != nullptr && isLValueRequiredHere())
+    {
+        loop->setNotFinite();
+    }
+}
+
+}  // namespace
+
+bool EnsureLoopForwardProgress(TCompiler *compiler, TIntermNode *root)
+{
+    EnsureLoopForwardProgressTraverser traverser(&compiler->getSymbolTable());
+    root->traverse(&traverser);
+    return traverser.updateTree(compiler, root);
+}
+
+}  // namespace sh
diff --git a/src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.h b/src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.h
new file mode 100644
index 0000000000000000000000000000000000000000..7f789569ef5c2bc2a6c91392c341fdc142d33d21
--- /dev/null
+++ b/src/compiler/translator/tree_ops/msl/EnsureLoopForwardProgress.h
@@ -0,0 +1,32 @@
+//
+// Copyright 2025 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// EnsureLoopForwardProgress is an AST traverser that ensures that loops are either finite or
+// invoke side-effects.
+//
+
+#ifndef COMPILER_TRANSLATOR_TREEOPS_MSL_ENSURELOOPFORWARDPROGRESS_H_
+#define COMPILER_TRANSLATOR_TREEOPS_MSL_ENSURELOOPFORWARDPROGRESS_H_
+
+#include "common/angleutils.h"
+#include "common/debug.h"
+
+namespace sh
+{
+class TCompiler;
+class TIntermNode;
+
+#ifdef ANGLE_ENABLE_METAL
+[[nodiscard]] bool EnsureLoopForwardProgress(TCompiler *compiler, TIntermNode *root);
+#else
+[[nodiscard]] ANGLE_INLINE bool EnsureLoopForwardProgress(TCompiler *compiler, TIntermNode *root)
+{
+    UNREACHABLE();
+    return false;
+}
+#endif
+}  // namespace sh
+
+#endif  // COMPILER_TRANSLATOR_TREEOPS_MSL_ENSURELOOPFORWARDPROGRESS_H_
diff --git a/src/compiler/translator/tree_util/BuiltIn_autogen.h b/src/compiler/translator/tree_util/BuiltIn_autogen.h
index c0d785c84e2867a8f0a85dbd496aa07a78e05a98..34c660a3be6d52363f90ba686938414929333a90 100644
--- a/src/compiler/translator/tree_util/BuiltIn_autogen.h
+++ b/src/compiler/translator/tree_util/BuiltIn_autogen.h
@@ -2844,262 +2844,263 @@ class BuiltInId
     static constexpr const TSymbolUniqueId interpolateAtCenter_Float2       = TSymbolUniqueId(1805);
     static constexpr const TSymbolUniqueId interpolateAtCenter_Float3       = TSymbolUniqueId(1806);
     static constexpr const TSymbolUniqueId interpolateAtCenter_Float4       = TSymbolUniqueId(1807);
-    static constexpr const TSymbolUniqueId saturate_Float1                  = TSymbolUniqueId(1808);
-    static constexpr const TSymbolUniqueId saturate_Float2                  = TSymbolUniqueId(1809);
-    static constexpr const TSymbolUniqueId saturate_Float3                  = TSymbolUniqueId(1810);
-    static constexpr const TSymbolUniqueId saturate_Float4                  = TSymbolUniqueId(1811);
-    static constexpr const TSymbolUniqueId gl_DepthRangeParameters          = TSymbolUniqueId(1812);
-    static constexpr const TSymbolUniqueId gl_DepthRange                    = TSymbolUniqueId(1813);
-    static constexpr const TSymbolUniqueId gl_NumSamples                    = TSymbolUniqueId(1814);
-    static constexpr const TSymbolUniqueId gl_NumSamplesES3_2               = TSymbolUniqueId(1815);
-    static constexpr const TSymbolUniqueId gl_MaxVertexAttribs              = TSymbolUniqueId(1816);
-    static constexpr const TSymbolUniqueId gl_MaxVertexUniformVectors       = TSymbolUniqueId(1817);
-    static constexpr const TSymbolUniqueId gl_MaxVertexTextureImageUnits    = TSymbolUniqueId(1818);
-    static constexpr const TSymbolUniqueId gl_MaxCombinedTextureImageUnits  = TSymbolUniqueId(1819);
-    static constexpr const TSymbolUniqueId gl_MaxTextureImageUnits          = TSymbolUniqueId(1820);
-    static constexpr const TSymbolUniqueId gl_MaxFragmentUniformVectors     = TSymbolUniqueId(1821);
-    static constexpr const TSymbolUniqueId gl_MaxVaryingVectors             = TSymbolUniqueId(1822);
-    static constexpr const TSymbolUniqueId gl_MaxDrawBuffers                = TSymbolUniqueId(1823);
-    static constexpr const TSymbolUniqueId gl_MaxDualSourceDrawBuffersEXT   = TSymbolUniqueId(1824);
-    static constexpr const TSymbolUniqueId gl_MaxVertexOutputVectors        = TSymbolUniqueId(1825);
-    static constexpr const TSymbolUniqueId gl_MaxFragmentInputVectors       = TSymbolUniqueId(1826);
-    static constexpr const TSymbolUniqueId gl_MinProgramTexelOffset         = TSymbolUniqueId(1827);
-    static constexpr const TSymbolUniqueId gl_MaxProgramTexelOffset         = TSymbolUniqueId(1828);
-    static constexpr const TSymbolUniqueId gl_MaxImageUnits                 = TSymbolUniqueId(1829);
-    static constexpr const TSymbolUniqueId gl_MaxVertexImageUniforms        = TSymbolUniqueId(1830);
-    static constexpr const TSymbolUniqueId gl_MaxFragmentImageUniforms      = TSymbolUniqueId(1831);
-    static constexpr const TSymbolUniqueId gl_MaxComputeImageUniforms       = TSymbolUniqueId(1832);
-    static constexpr const TSymbolUniqueId gl_MaxCombinedImageUniforms      = TSymbolUniqueId(1833);
+    static constexpr const TSymbolUniqueId loopForwardProgress              = TSymbolUniqueId(1808);
+    static constexpr const TSymbolUniqueId saturate_Float1                  = TSymbolUniqueId(1809);
+    static constexpr const TSymbolUniqueId saturate_Float2                  = TSymbolUniqueId(1810);
+    static constexpr const TSymbolUniqueId saturate_Float3                  = TSymbolUniqueId(1811);
+    static constexpr const TSymbolUniqueId saturate_Float4                  = TSymbolUniqueId(1812);
+    static constexpr const TSymbolUniqueId gl_DepthRangeParameters          = TSymbolUniqueId(1813);
+    static constexpr const TSymbolUniqueId gl_DepthRange                    = TSymbolUniqueId(1814);
+    static constexpr const TSymbolUniqueId gl_NumSamples                    = TSymbolUniqueId(1815);
+    static constexpr const TSymbolUniqueId gl_NumSamplesES3_2               = TSymbolUniqueId(1816);
+    static constexpr const TSymbolUniqueId gl_MaxVertexAttribs              = TSymbolUniqueId(1817);
+    static constexpr const TSymbolUniqueId gl_MaxVertexUniformVectors       = TSymbolUniqueId(1818);
+    static constexpr const TSymbolUniqueId gl_MaxVertexTextureImageUnits    = TSymbolUniqueId(1819);
+    static constexpr const TSymbolUniqueId gl_MaxCombinedTextureImageUnits  = TSymbolUniqueId(1820);
+    static constexpr const TSymbolUniqueId gl_MaxTextureImageUnits          = TSymbolUniqueId(1821);
+    static constexpr const TSymbolUniqueId gl_MaxFragmentUniformVectors     = TSymbolUniqueId(1822);
+    static constexpr const TSymbolUniqueId gl_MaxVaryingVectors             = TSymbolUniqueId(1823);
+    static constexpr const TSymbolUniqueId gl_MaxDrawBuffers                = TSymbolUniqueId(1824);
+    static constexpr const TSymbolUniqueId gl_MaxDualSourceDrawBuffersEXT   = TSymbolUniqueId(1825);
+    static constexpr const TSymbolUniqueId gl_MaxVertexOutputVectors        = TSymbolUniqueId(1826);
+    static constexpr const TSymbolUniqueId gl_MaxFragmentInputVectors       = TSymbolUniqueId(1827);
+    static constexpr const TSymbolUniqueId gl_MinProgramTexelOffset         = TSymbolUniqueId(1828);
+    static constexpr const TSymbolUniqueId gl_MaxProgramTexelOffset         = TSymbolUniqueId(1829);
+    static constexpr const TSymbolUniqueId gl_MaxImageUnits                 = TSymbolUniqueId(1830);
+    static constexpr const TSymbolUniqueId gl_MaxVertexImageUniforms        = TSymbolUniqueId(1831);
+    static constexpr const TSymbolUniqueId gl_MaxFragmentImageUniforms      = TSymbolUniqueId(1832);
+    static constexpr const TSymbolUniqueId gl_MaxComputeImageUniforms       = TSymbolUniqueId(1833);
+    static constexpr const TSymbolUniqueId gl_MaxCombinedImageUniforms      = TSymbolUniqueId(1834);
     static constexpr const TSymbolUniqueId gl_MaxCombinedShaderOutputResources =
-        TSymbolUniqueId(1834);
-    static constexpr const TSymbolUniqueId gl_MaxComputeWorkGroupCount    = TSymbolUniqueId(1835);
-    static constexpr const TSymbolUniqueId gl_MaxComputeWorkGroupSize     = TSymbolUniqueId(1836);
-    static constexpr const TSymbolUniqueId gl_MaxComputeUniformComponents = TSymbolUniqueId(1837);
-    static constexpr const TSymbolUniqueId gl_MaxComputeTextureImageUnits = TSymbolUniqueId(1838);
-    static constexpr const TSymbolUniqueId gl_MaxComputeAtomicCounters    = TSymbolUniqueId(1839);
+        TSymbolUniqueId(1835);
+    static constexpr const TSymbolUniqueId gl_MaxComputeWorkGroupCount    = TSymbolUniqueId(1836);
+    static constexpr const TSymbolUniqueId gl_MaxComputeWorkGroupSize     = TSymbolUniqueId(1837);
+    static constexpr const TSymbolUniqueId gl_MaxComputeUniformComponents = TSymbolUniqueId(1838);
+    static constexpr const TSymbolUniqueId gl_MaxComputeTextureImageUnits = TSymbolUniqueId(1839);
+    static constexpr const TSymbolUniqueId gl_MaxComputeAtomicCounters    = TSymbolUniqueId(1840);
     static constexpr const TSymbolUniqueId gl_MaxComputeAtomicCounterBuffers =
-        TSymbolUniqueId(1840);
-    static constexpr const TSymbolUniqueId gl_MaxVertexAtomicCounters       = TSymbolUniqueId(1841);
-    static constexpr const TSymbolUniqueId gl_MaxFragmentAtomicCounters     = TSymbolUniqueId(1842);
-    static constexpr const TSymbolUniqueId gl_MaxCombinedAtomicCounters     = TSymbolUniqueId(1843);
-    static constexpr const TSymbolUniqueId gl_MaxAtomicCounterBindings      = TSymbolUniqueId(1844);
-    static constexpr const TSymbolUniqueId gl_MaxVertexAtomicCounterBuffers = TSymbolUniqueId(1845);
+        TSymbolUniqueId(1841);
+    static constexpr const TSymbolUniqueId gl_MaxVertexAtomicCounters       = TSymbolUniqueId(1842);
+    static constexpr const TSymbolUniqueId gl_MaxFragmentAtomicCounters     = TSymbolUniqueId(1843);
+    static constexpr const TSymbolUniqueId gl_MaxCombinedAtomicCounters     = TSymbolUniqueId(1844);
+    static constexpr const TSymbolUniqueId gl_MaxAtomicCounterBindings      = TSymbolUniqueId(1845);
+    static constexpr const TSymbolUniqueId gl_MaxVertexAtomicCounterBuffers = TSymbolUniqueId(1846);
     static constexpr const TSymbolUniqueId gl_MaxFragmentAtomicCounterBuffers =
-        TSymbolUniqueId(1846);
-    static constexpr const TSymbolUniqueId gl_MaxCombinedAtomicCounterBuffers =
         TSymbolUniqueId(1847);
-    static constexpr const TSymbolUniqueId gl_MaxAtomicCounterBufferSize = TSymbolUniqueId(1848);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryInputComponents = TSymbolUniqueId(1849);
+    static constexpr const TSymbolUniqueId gl_MaxCombinedAtomicCounterBuffers =
+        TSymbolUniqueId(1848);
+    static constexpr const TSymbolUniqueId gl_MaxAtomicCounterBufferSize = TSymbolUniqueId(1849);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryInputComponents = TSymbolUniqueId(1850);
     static constexpr const TSymbolUniqueId gl_MaxGeometryInputComponentsES3_2 =
-        TSymbolUniqueId(1850);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryOutputComponents = TSymbolUniqueId(1851);
+        TSymbolUniqueId(1851);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryOutputComponents = TSymbolUniqueId(1852);
     static constexpr const TSymbolUniqueId gl_MaxGeometryOutputComponentsES3_2 =
-        TSymbolUniqueId(1852);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryImageUniforms      = TSymbolUniqueId(1853);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryImageUniformsES3_2 = TSymbolUniqueId(1854);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryTextureImageUnits  = TSymbolUniqueId(1855);
+        TSymbolUniqueId(1853);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryImageUniforms      = TSymbolUniqueId(1854);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryImageUniformsES3_2 = TSymbolUniqueId(1855);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryTextureImageUnits  = TSymbolUniqueId(1856);
     static constexpr const TSymbolUniqueId gl_MaxGeometryTextureImageUnitsES3_2 =
-        TSymbolUniqueId(1856);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryOutputVertices = TSymbolUniqueId(1857);
+        TSymbolUniqueId(1857);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryOutputVertices = TSymbolUniqueId(1858);
     static constexpr const TSymbolUniqueId gl_MaxGeometryOutputVerticesES3_2 =
-        TSymbolUniqueId(1858);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryTotalOutputComponents =
         TSymbolUniqueId(1859);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryTotalOutputComponentsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxGeometryTotalOutputComponents =
         TSymbolUniqueId(1860);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryUniformComponents = TSymbolUniqueId(1861);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryTotalOutputComponentsES3_2 =
+        TSymbolUniqueId(1861);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryUniformComponents = TSymbolUniqueId(1862);
     static constexpr const TSymbolUniqueId gl_MaxGeometryUniformComponentsES3_2 =
-        TSymbolUniqueId(1862);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCounters = TSymbolUniqueId(1863);
+        TSymbolUniqueId(1863);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCounters = TSymbolUniqueId(1864);
     static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCountersES3_2 =
-        TSymbolUniqueId(1864);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCounterBuffers =
         TSymbolUniqueId(1865);
-    static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCounterBuffersES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCounterBuffers =
         TSymbolUniqueId(1866);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlInputComponents = TSymbolUniqueId(1867);
+    static constexpr const TSymbolUniqueId gl_MaxGeometryAtomicCounterBuffersES3_2 =
+        TSymbolUniqueId(1867);
+    static constexpr const TSymbolUniqueId gl_MaxTessControlInputComponents = TSymbolUniqueId(1868);
     static constexpr const TSymbolUniqueId gl_MaxTessControlInputComponentsES3_2 =
-        TSymbolUniqueId(1868);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlOutputComponents =
         TSymbolUniqueId(1869);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlOutputComponentsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlOutputComponents =
         TSymbolUniqueId(1870);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlTextureImageUnits =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlOutputComponentsES3_2 =
         TSymbolUniqueId(1871);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlTextureImageUnitsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlTextureImageUnits =
         TSymbolUniqueId(1872);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlUniformComponents =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlTextureImageUnitsES3_2 =
         TSymbolUniqueId(1873);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlUniformComponentsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlUniformComponents =
         TSymbolUniqueId(1874);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlTotalOutputComponents =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlUniformComponentsES3_2 =
         TSymbolUniqueId(1875);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlTotalOutputComponentsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlTotalOutputComponents =
         TSymbolUniqueId(1876);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlImageUniforms = TSymbolUniqueId(1877);
+    static constexpr const TSymbolUniqueId gl_MaxTessControlTotalOutputComponentsES3_2 =
+        TSymbolUniqueId(1877);
+    static constexpr const TSymbolUniqueId gl_MaxTessControlImageUniforms = TSymbolUniqueId(1878);
     static constexpr const TSymbolUniqueId gl_MaxTessControlImageUniformsES3_2 =
-        TSymbolUniqueId(1878);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCounters = TSymbolUniqueId(1879);
+        TSymbolUniqueId(1879);
+    static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCounters = TSymbolUniqueId(1880);
     static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCountersES3_2 =
-        TSymbolUniqueId(1880);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCounterBuffers =
         TSymbolUniqueId(1881);
-    static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCounterBuffersES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCounterBuffers =
         TSymbolUniqueId(1882);
-    static constexpr const TSymbolUniqueId gl_MaxTessPatchComponents      = TSymbolUniqueId(1883);
-    static constexpr const TSymbolUniqueId gl_MaxTessPatchComponentsES3_2 = TSymbolUniqueId(1884);
-    static constexpr const TSymbolUniqueId gl_MaxPatchVertices            = TSymbolUniqueId(1885);
-    static constexpr const TSymbolUniqueId gl_MaxPatchVerticesES3_2       = TSymbolUniqueId(1886);
-    static constexpr const TSymbolUniqueId gl_MaxTessGenLevel             = TSymbolUniqueId(1887);
-    static constexpr const TSymbolUniqueId gl_MaxTessGenLevelES3_2        = TSymbolUniqueId(1888);
+    static constexpr const TSymbolUniqueId gl_MaxTessControlAtomicCounterBuffersES3_2 =
+        TSymbolUniqueId(1883);
+    static constexpr const TSymbolUniqueId gl_MaxTessPatchComponents      = TSymbolUniqueId(1884);
+    static constexpr const TSymbolUniqueId gl_MaxTessPatchComponentsES3_2 = TSymbolUniqueId(1885);
+    static constexpr const TSymbolUniqueId gl_MaxPatchVertices            = TSymbolUniqueId(1886);
+    static constexpr const TSymbolUniqueId gl_MaxPatchVerticesES3_2       = TSymbolUniqueId(1887);
+    static constexpr const TSymbolUniqueId gl_MaxTessGenLevel             = TSymbolUniqueId(1888);
+    static constexpr const TSymbolUniqueId gl_MaxTessGenLevelES3_2        = TSymbolUniqueId(1889);
     static constexpr const TSymbolUniqueId gl_MaxTessEvaluationInputComponents =
-        TSymbolUniqueId(1889);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationInputComponentsES3_2 =
         TSymbolUniqueId(1890);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationOutputComponents =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationInputComponentsES3_2 =
         TSymbolUniqueId(1891);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationOutputComponentsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationOutputComponents =
         TSymbolUniqueId(1892);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationTextureImageUnits =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationOutputComponentsES3_2 =
         TSymbolUniqueId(1893);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationTextureImageUnitsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationTextureImageUnits =
         TSymbolUniqueId(1894);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationUniformComponents =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationTextureImageUnitsES3_2 =
         TSymbolUniqueId(1895);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationUniformComponentsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationUniformComponents =
         TSymbolUniqueId(1896);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationImageUniforms =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationUniformComponentsES3_2 =
         TSymbolUniqueId(1897);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationImageUniformsES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationImageUniforms =
         TSymbolUniqueId(1898);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCounters =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationImageUniformsES3_2 =
         TSymbolUniqueId(1899);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCountersES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCounters =
         TSymbolUniqueId(1900);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCounterBuffers =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCountersES3_2 =
         TSymbolUniqueId(1901);
-    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCounterBuffersES3_2 =
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCounterBuffers =
         TSymbolUniqueId(1902);
-    static constexpr const TSymbolUniqueId gl_MaxSamples            = TSymbolUniqueId(1903);
-    static constexpr const TSymbolUniqueId gl_MaxSamplesES3_2       = TSymbolUniqueId(1904);
-    static constexpr const TSymbolUniqueId gl_MaxClipDistancesAPPLE = TSymbolUniqueId(1905);
-    static constexpr const TSymbolUniqueId gl_MaxClipDistances      = TSymbolUniqueId(1906);
-    static constexpr const TSymbolUniqueId gl_MaxCullDistances      = TSymbolUniqueId(1907);
+    static constexpr const TSymbolUniqueId gl_MaxTessEvaluationAtomicCounterBuffersES3_2 =
+        TSymbolUniqueId(1903);
+    static constexpr const TSymbolUniqueId gl_MaxSamples            = TSymbolUniqueId(1904);
+    static constexpr const TSymbolUniqueId gl_MaxSamplesES3_2       = TSymbolUniqueId(1905);
+    static constexpr const TSymbolUniqueId gl_MaxClipDistancesAPPLE = TSymbolUniqueId(1906);
+    static constexpr const TSymbolUniqueId gl_MaxClipDistances      = TSymbolUniqueId(1907);
+    static constexpr const TSymbolUniqueId gl_MaxCullDistances      = TSymbolUniqueId(1908);
     static constexpr const TSymbolUniqueId gl_MaxCombinedClipAndCullDistances =
-        TSymbolUniqueId(1908);
-    static constexpr const TSymbolUniqueId gl_FragCoord                 = TSymbolUniqueId(1909);
-    static constexpr const TSymbolUniqueId gl_FrontFacing               = TSymbolUniqueId(1910);
-    static constexpr const TSymbolUniqueId gl_PointCoord                = TSymbolUniqueId(1911);
-    static constexpr const TSymbolUniqueId gl_FragColor                 = TSymbolUniqueId(1912);
-    static constexpr const TSymbolUniqueId gl_FragData                  = TSymbolUniqueId(1913);
-    static constexpr const TSymbolUniqueId gl_FragDepth                 = TSymbolUniqueId(1914);
-    static constexpr const TSymbolUniqueId gl_HelperInvocation          = TSymbolUniqueId(1915);
-    static constexpr const TSymbolUniqueId gl_FragCoord300              = TSymbolUniqueId(1916);
-    static constexpr const TSymbolUniqueId gl_SecondaryFragColorEXT     = TSymbolUniqueId(1917);
-    static constexpr const TSymbolUniqueId gl_SecondaryFragDataEXT      = TSymbolUniqueId(1918);
-    static constexpr const TSymbolUniqueId gl_FragDepthEXT              = TSymbolUniqueId(1919);
-    static constexpr const TSymbolUniqueId gl_LastFragData              = TSymbolUniqueId(1920);
-    static constexpr const TSymbolUniqueId gl_LastFragColor             = TSymbolUniqueId(1921);
-    static constexpr const TSymbolUniqueId gl_LastFragDataNV            = TSymbolUniqueId(1922);
-    static constexpr const TSymbolUniqueId gl_LastFragColorARM          = TSymbolUniqueId(1923);
-    static constexpr const TSymbolUniqueId gl_LastFragDepthARM          = TSymbolUniqueId(1924);
-    static constexpr const TSymbolUniqueId gl_LastFragStencilARM        = TSymbolUniqueId(1925);
-    static constexpr const TSymbolUniqueId gl_PrimitiveID               = TSymbolUniqueId(1926);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDES3_2          = TSymbolUniqueId(1927);
-    static constexpr const TSymbolUniqueId gl_Layer                     = TSymbolUniqueId(1928);
-    static constexpr const TSymbolUniqueId gl_LayerES3_2                = TSymbolUniqueId(1929);
-    static constexpr const TSymbolUniqueId gl_SampleID                  = TSymbolUniqueId(1930);
-    static constexpr const TSymbolUniqueId gl_SampleIDES3_2             = TSymbolUniqueId(1931);
-    static constexpr const TSymbolUniqueId gl_SamplePosition            = TSymbolUniqueId(1932);
-    static constexpr const TSymbolUniqueId gl_SamplePositionES3_2       = TSymbolUniqueId(1933);
-    static constexpr const TSymbolUniqueId gl_SampleMaskIn              = TSymbolUniqueId(1934);
-    static constexpr const TSymbolUniqueId gl_SampleMaskInES3_2         = TSymbolUniqueId(1935);
-    static constexpr const TSymbolUniqueId gl_SampleMask                = TSymbolUniqueId(1936);
-    static constexpr const TSymbolUniqueId gl_SampleMaskES3_2           = TSymbolUniqueId(1937);
-    static constexpr const TSymbolUniqueId gl_Position                  = TSymbolUniqueId(1938);
-    static constexpr const TSymbolUniqueId gl_PointSize                 = TSymbolUniqueId(1939);
-    static constexpr const TSymbolUniqueId gl_InstanceID                = TSymbolUniqueId(1940);
-    static constexpr const TSymbolUniqueId gl_InstanceIndex             = TSymbolUniqueId(1941);
-    static constexpr const TSymbolUniqueId gl_VertexID                  = TSymbolUniqueId(1942);
-    static constexpr const TSymbolUniqueId gl_VertexIndex               = TSymbolUniqueId(1943);
-    static constexpr const TSymbolUniqueId gl_LayerVS                   = TSymbolUniqueId(1944);
-    static constexpr const TSymbolUniqueId gl_PointSize300              = TSymbolUniqueId(1945);
-    static constexpr const TSymbolUniqueId gl_DrawID                    = TSymbolUniqueId(1946);
-    static constexpr const TSymbolUniqueId gl_BaseVertex                = TSymbolUniqueId(1947);
-    static constexpr const TSymbolUniqueId gl_BaseInstance              = TSymbolUniqueId(1948);
-    static constexpr const TSymbolUniqueId angle_BaseVertex             = TSymbolUniqueId(1949);
-    static constexpr const TSymbolUniqueId angle_BaseInstance           = TSymbolUniqueId(1950);
-    static constexpr const TSymbolUniqueId gl_ClipDistanceAPPLE         = TSymbolUniqueId(1951);
-    static constexpr const TSymbolUniqueId gl_NumWorkGroups             = TSymbolUniqueId(1952);
-    static constexpr const TSymbolUniqueId gl_WorkGroupSize             = TSymbolUniqueId(1953);
-    static constexpr const TSymbolUniqueId gl_WorkGroupID               = TSymbolUniqueId(1954);
-    static constexpr const TSymbolUniqueId gl_LocalInvocationID         = TSymbolUniqueId(1955);
-    static constexpr const TSymbolUniqueId gl_GlobalInvocationID        = TSymbolUniqueId(1956);
-    static constexpr const TSymbolUniqueId gl_LocalInvocationIndex      = TSymbolUniqueId(1957);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDIn             = TSymbolUniqueId(1958);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDInES3_2        = TSymbolUniqueId(1959);
-    static constexpr const TSymbolUniqueId gl_InvocationID              = TSymbolUniqueId(1960);
-    static constexpr const TSymbolUniqueId gl_InvocationIDES3_2         = TSymbolUniqueId(1961);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDGS             = TSymbolUniqueId(1962);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDGSES3_2        = TSymbolUniqueId(1963);
-    static constexpr const TSymbolUniqueId gl_LayerGS                   = TSymbolUniqueId(1964);
-    static constexpr const TSymbolUniqueId gl_LayerGSES3_2              = TSymbolUniqueId(1965);
-    static constexpr const TSymbolUniqueId gl_PerVertex                 = TSymbolUniqueId(1966);
-    static constexpr const TSymbolUniqueId gl_PerVertexES3_2            = TSymbolUniqueId(1967);
-    static constexpr const TSymbolUniqueId gl_in                        = TSymbolUniqueId(1968);
-    static constexpr const TSymbolUniqueId gl_inES3_2                   = TSymbolUniqueId(1969);
-    static constexpr const TSymbolUniqueId gl_PerVertexOutBlock         = TSymbolUniqueId(1970);
-    static constexpr const TSymbolUniqueId gl_PerVertexOutBlockES3_2    = TSymbolUniqueId(1971);
-    static constexpr const TSymbolUniqueId gl_PositionGS                = TSymbolUniqueId(1972);
-    static constexpr const TSymbolUniqueId gl_PositionGSES3_2           = TSymbolUniqueId(1973);
-    static constexpr const TSymbolUniqueId gl_PatchVerticesInTCS        = TSymbolUniqueId(1974);
-    static constexpr const TSymbolUniqueId gl_PatchVerticesInTCSES3_2   = TSymbolUniqueId(1975);
-    static constexpr const TSymbolUniqueId gl_InvocationIDTCS           = TSymbolUniqueId(1976);
-    static constexpr const TSymbolUniqueId gl_InvocationIDTCSES3_2      = TSymbolUniqueId(1977);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDTCS            = TSymbolUniqueId(1978);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDTCSES3_2       = TSymbolUniqueId(1979);
-    static constexpr const TSymbolUniqueId gl_TessLevelOuterTCS         = TSymbolUniqueId(1980);
-    static constexpr const TSymbolUniqueId gl_TessLevelOuterTCSES3_2    = TSymbolUniqueId(1981);
-    static constexpr const TSymbolUniqueId gl_TessLevelInnerTCS         = TSymbolUniqueId(1982);
-    static constexpr const TSymbolUniqueId gl_TessLevelInnerTCSES3_2    = TSymbolUniqueId(1983);
-    static constexpr const TSymbolUniqueId gl_PerVertexTCS              = TSymbolUniqueId(1984);
-    static constexpr const TSymbolUniqueId gl_PerVertexTCSES3_2         = TSymbolUniqueId(1985);
-    static constexpr const TSymbolUniqueId gl_inTCS                     = TSymbolUniqueId(1986);
-    static constexpr const TSymbolUniqueId gl_inTCSES3_2                = TSymbolUniqueId(1987);
-    static constexpr const TSymbolUniqueId gl_outTCS                    = TSymbolUniqueId(1988);
-    static constexpr const TSymbolUniqueId gl_outTCSES3_2               = TSymbolUniqueId(1989);
-    static constexpr const TSymbolUniqueId gl_BoundingBoxTCS            = TSymbolUniqueId(1990);
-    static constexpr const TSymbolUniqueId gl_BoundingBoxTCSES3_2       = TSymbolUniqueId(1991);
-    static constexpr const TSymbolUniqueId gl_PerVertexOutTcsBlock      = TSymbolUniqueId(1992);
-    static constexpr const TSymbolUniqueId gl_PerVertexOutTcsBlockES3_2 = TSymbolUniqueId(1993);
-    static constexpr const TSymbolUniqueId gl_PositionTCS               = TSymbolUniqueId(1994);
-    static constexpr const TSymbolUniqueId gl_PositionTCSES3_2          = TSymbolUniqueId(1995);
-    static constexpr const TSymbolUniqueId gl_BoundingBoxEXTTCS         = TSymbolUniqueId(1996);
-    static constexpr const TSymbolUniqueId gl_BoundingBoxEXTTCSES3_2    = TSymbolUniqueId(1997);
-    static constexpr const TSymbolUniqueId gl_BoundingBoxOESTCS         = TSymbolUniqueId(1998);
-    static constexpr const TSymbolUniqueId gl_BoundingBoxOESTCSES3_2    = TSymbolUniqueId(1999);
-    static constexpr const TSymbolUniqueId gl_PatchVerticesInTES        = TSymbolUniqueId(2000);
-    static constexpr const TSymbolUniqueId gl_PatchVerticesInTESES3_2   = TSymbolUniqueId(2001);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDTES            = TSymbolUniqueId(2002);
-    static constexpr const TSymbolUniqueId gl_PrimitiveIDTESES3_2       = TSymbolUniqueId(2003);
-    static constexpr const TSymbolUniqueId gl_TessCoord                 = TSymbolUniqueId(2004);
-    static constexpr const TSymbolUniqueId gl_TessLevelOuterTES         = TSymbolUniqueId(2005);
-    static constexpr const TSymbolUniqueId gl_TessLevelOuterTESES3_2    = TSymbolUniqueId(2006);
-    static constexpr const TSymbolUniqueId gl_TessLevelInnerTES         = TSymbolUniqueId(2007);
-    static constexpr const TSymbolUniqueId gl_TessLevelInnerTESES3_2    = TSymbolUniqueId(2008);
-    static constexpr const TSymbolUniqueId gl_PerVertexTES              = TSymbolUniqueId(2009);
-    static constexpr const TSymbolUniqueId gl_PerVertexTESES3_2         = TSymbolUniqueId(2010);
-    static constexpr const TSymbolUniqueId gl_inTES                     = TSymbolUniqueId(2011);
-    static constexpr const TSymbolUniqueId gl_inTESES3_2                = TSymbolUniqueId(2012);
-    static constexpr const TSymbolUniqueId gl_outTES                    = TSymbolUniqueId(2013);
-    static constexpr const TSymbolUniqueId gl_outTESES3_2               = TSymbolUniqueId(2014);
-    static constexpr const TSymbolUniqueId gl_PerVertexOutTesBlock      = TSymbolUniqueId(2015);
-    static constexpr const TSymbolUniqueId gl_PerVertexOutTesBlockES3_2 = TSymbolUniqueId(2016);
-    static constexpr const TSymbolUniqueId gl_PositionTES               = TSymbolUniqueId(2017);
-    static constexpr const TSymbolUniqueId gl_PositionTESES3_2          = TSymbolUniqueId(2018);
-    static constexpr const TSymbolUniqueId gl_ViewID_OVR                = TSymbolUniqueId(2019);
-    static constexpr const TSymbolUniqueId gl_ClipDistance              = TSymbolUniqueId(2020);
-    static constexpr const TSymbolUniqueId gl_CullDistance              = TSymbolUniqueId(2021);
+        TSymbolUniqueId(1909);
+    static constexpr const TSymbolUniqueId gl_FragCoord                 = TSymbolUniqueId(1910);
+    static constexpr const TSymbolUniqueId gl_FrontFacing               = TSymbolUniqueId(1911);
+    static constexpr const TSymbolUniqueId gl_PointCoord                = TSymbolUniqueId(1912);
+    static constexpr const TSymbolUniqueId gl_FragColor                 = TSymbolUniqueId(1913);
+    static constexpr const TSymbolUniqueId gl_FragData                  = TSymbolUniqueId(1914);
+    static constexpr const TSymbolUniqueId gl_FragDepth                 = TSymbolUniqueId(1915);
+    static constexpr const TSymbolUniqueId gl_HelperInvocation          = TSymbolUniqueId(1916);
+    static constexpr const TSymbolUniqueId gl_FragCoord300              = TSymbolUniqueId(1917);
+    static constexpr const TSymbolUniqueId gl_SecondaryFragColorEXT     = TSymbolUniqueId(1918);
+    static constexpr const TSymbolUniqueId gl_SecondaryFragDataEXT      = TSymbolUniqueId(1919);
+    static constexpr const TSymbolUniqueId gl_FragDepthEXT              = TSymbolUniqueId(1920);
+    static constexpr const TSymbolUniqueId gl_LastFragData              = TSymbolUniqueId(1921);
+    static constexpr const TSymbolUniqueId gl_LastFragColor             = TSymbolUniqueId(1922);
+    static constexpr const TSymbolUniqueId gl_LastFragDataNV            = TSymbolUniqueId(1923);
+    static constexpr const TSymbolUniqueId gl_LastFragColorARM          = TSymbolUniqueId(1924);
+    static constexpr const TSymbolUniqueId gl_LastFragDepthARM          = TSymbolUniqueId(1925);
+    static constexpr const TSymbolUniqueId gl_LastFragStencilARM        = TSymbolUniqueId(1926);
+    static constexpr const TSymbolUniqueId gl_PrimitiveID               = TSymbolUniqueId(1927);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDES3_2          = TSymbolUniqueId(1928);
+    static constexpr const TSymbolUniqueId gl_Layer                     = TSymbolUniqueId(1929);
+    static constexpr const TSymbolUniqueId gl_LayerES3_2                = TSymbolUniqueId(1930);
+    static constexpr const TSymbolUniqueId gl_SampleID                  = TSymbolUniqueId(1931);
+    static constexpr const TSymbolUniqueId gl_SampleIDES3_2             = TSymbolUniqueId(1932);
+    static constexpr const TSymbolUniqueId gl_SamplePosition            = TSymbolUniqueId(1933);
+    static constexpr const TSymbolUniqueId gl_SamplePositionES3_2       = TSymbolUniqueId(1934);
+    static constexpr const TSymbolUniqueId gl_SampleMaskIn              = TSymbolUniqueId(1935);
+    static constexpr const TSymbolUniqueId gl_SampleMaskInES3_2         = TSymbolUniqueId(1936);
+    static constexpr const TSymbolUniqueId gl_SampleMask                = TSymbolUniqueId(1937);
+    static constexpr const TSymbolUniqueId gl_SampleMaskES3_2           = TSymbolUniqueId(1938);
+    static constexpr const TSymbolUniqueId gl_Position                  = TSymbolUniqueId(1939);
+    static constexpr const TSymbolUniqueId gl_PointSize                 = TSymbolUniqueId(1940);
+    static constexpr const TSymbolUniqueId gl_InstanceID                = TSymbolUniqueId(1941);
+    static constexpr const TSymbolUniqueId gl_InstanceIndex             = TSymbolUniqueId(1942);
+    static constexpr const TSymbolUniqueId gl_VertexID                  = TSymbolUniqueId(1943);
+    static constexpr const TSymbolUniqueId gl_VertexIndex               = TSymbolUniqueId(1944);
+    static constexpr const TSymbolUniqueId gl_LayerVS                   = TSymbolUniqueId(1945);
+    static constexpr const TSymbolUniqueId gl_PointSize300              = TSymbolUniqueId(1946);
+    static constexpr const TSymbolUniqueId gl_DrawID                    = TSymbolUniqueId(1947);
+    static constexpr const TSymbolUniqueId gl_BaseVertex                = TSymbolUniqueId(1948);
+    static constexpr const TSymbolUniqueId gl_BaseInstance              = TSymbolUniqueId(1949);
+    static constexpr const TSymbolUniqueId angle_BaseVertex             = TSymbolUniqueId(1950);
+    static constexpr const TSymbolUniqueId angle_BaseInstance           = TSymbolUniqueId(1951);
+    static constexpr const TSymbolUniqueId gl_ClipDistanceAPPLE         = TSymbolUniqueId(1952);
+    static constexpr const TSymbolUniqueId gl_NumWorkGroups             = TSymbolUniqueId(1953);
+    static constexpr const TSymbolUniqueId gl_WorkGroupSize             = TSymbolUniqueId(1954);
+    static constexpr const TSymbolUniqueId gl_WorkGroupID               = TSymbolUniqueId(1955);
+    static constexpr const TSymbolUniqueId gl_LocalInvocationID         = TSymbolUniqueId(1956);
+    static constexpr const TSymbolUniqueId gl_GlobalInvocationID        = TSymbolUniqueId(1957);
+    static constexpr const TSymbolUniqueId gl_LocalInvocationIndex      = TSymbolUniqueId(1958);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDIn             = TSymbolUniqueId(1959);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDInES3_2        = TSymbolUniqueId(1960);
+    static constexpr const TSymbolUniqueId gl_InvocationID              = TSymbolUniqueId(1961);
+    static constexpr const TSymbolUniqueId gl_InvocationIDES3_2         = TSymbolUniqueId(1962);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDGS             = TSymbolUniqueId(1963);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDGSES3_2        = TSymbolUniqueId(1964);
+    static constexpr const TSymbolUniqueId gl_LayerGS                   = TSymbolUniqueId(1965);
+    static constexpr const TSymbolUniqueId gl_LayerGSES3_2              = TSymbolUniqueId(1966);
+    static constexpr const TSymbolUniqueId gl_PerVertex                 = TSymbolUniqueId(1967);
+    static constexpr const TSymbolUniqueId gl_PerVertexES3_2            = TSymbolUniqueId(1968);
+    static constexpr const TSymbolUniqueId gl_in                        = TSymbolUniqueId(1969);
+    static constexpr const TSymbolUniqueId gl_inES3_2                   = TSymbolUniqueId(1970);
+    static constexpr const TSymbolUniqueId gl_PerVertexOutBlock         = TSymbolUniqueId(1971);
+    static constexpr const TSymbolUniqueId gl_PerVertexOutBlockES3_2    = TSymbolUniqueId(1972);
+    static constexpr const TSymbolUniqueId gl_PositionGS                = TSymbolUniqueId(1973);
+    static constexpr const TSymbolUniqueId gl_PositionGSES3_2           = TSymbolUniqueId(1974);
+    static constexpr const TSymbolUniqueId gl_PatchVerticesInTCS        = TSymbolUniqueId(1975);
+    static constexpr const TSymbolUniqueId gl_PatchVerticesInTCSES3_2   = TSymbolUniqueId(1976);
+    static constexpr const TSymbolUniqueId gl_InvocationIDTCS           = TSymbolUniqueId(1977);
+    static constexpr const TSymbolUniqueId gl_InvocationIDTCSES3_2      = TSymbolUniqueId(1978);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDTCS            = TSymbolUniqueId(1979);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDTCSES3_2       = TSymbolUniqueId(1980);
+    static constexpr const TSymbolUniqueId gl_TessLevelOuterTCS         = TSymbolUniqueId(1981);
+    static constexpr const TSymbolUniqueId gl_TessLevelOuterTCSES3_2    = TSymbolUniqueId(1982);
+    static constexpr const TSymbolUniqueId gl_TessLevelInnerTCS         = TSymbolUniqueId(1983);
+    static constexpr const TSymbolUniqueId gl_TessLevelInnerTCSES3_2    = TSymbolUniqueId(1984);
+    static constexpr const TSymbolUniqueId gl_PerVertexTCS              = TSymbolUniqueId(1985);
+    static constexpr const TSymbolUniqueId gl_PerVertexTCSES3_2         = TSymbolUniqueId(1986);
+    static constexpr const TSymbolUniqueId gl_inTCS                     = TSymbolUniqueId(1987);
+    static constexpr const TSymbolUniqueId gl_inTCSES3_2                = TSymbolUniqueId(1988);
+    static constexpr const TSymbolUniqueId gl_outTCS                    = TSymbolUniqueId(1989);
+    static constexpr const TSymbolUniqueId gl_outTCSES3_2               = TSymbolUniqueId(1990);
+    static constexpr const TSymbolUniqueId gl_BoundingBoxTCS            = TSymbolUniqueId(1991);
+    static constexpr const TSymbolUniqueId gl_BoundingBoxTCSES3_2       = TSymbolUniqueId(1992);
+    static constexpr const TSymbolUniqueId gl_PerVertexOutTcsBlock      = TSymbolUniqueId(1993);
+    static constexpr const TSymbolUniqueId gl_PerVertexOutTcsBlockES3_2 = TSymbolUniqueId(1994);
+    static constexpr const TSymbolUniqueId gl_PositionTCS               = TSymbolUniqueId(1995);
+    static constexpr const TSymbolUniqueId gl_PositionTCSES3_2          = TSymbolUniqueId(1996);
+    static constexpr const TSymbolUniqueId gl_BoundingBoxEXTTCS         = TSymbolUniqueId(1997);
+    static constexpr const TSymbolUniqueId gl_BoundingBoxEXTTCSES3_2    = TSymbolUniqueId(1998);
+    static constexpr const TSymbolUniqueId gl_BoundingBoxOESTCS         = TSymbolUniqueId(1999);
+    static constexpr const TSymbolUniqueId gl_BoundingBoxOESTCSES3_2    = TSymbolUniqueId(2000);
+    static constexpr const TSymbolUniqueId gl_PatchVerticesInTES        = TSymbolUniqueId(2001);
+    static constexpr const TSymbolUniqueId gl_PatchVerticesInTESES3_2   = TSymbolUniqueId(2002);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDTES            = TSymbolUniqueId(2003);
+    static constexpr const TSymbolUniqueId gl_PrimitiveIDTESES3_2       = TSymbolUniqueId(2004);
+    static constexpr const TSymbolUniqueId gl_TessCoord                 = TSymbolUniqueId(2005);
+    static constexpr const TSymbolUniqueId gl_TessLevelOuterTES         = TSymbolUniqueId(2006);
+    static constexpr const TSymbolUniqueId gl_TessLevelOuterTESES3_2    = TSymbolUniqueId(2007);
+    static constexpr const TSymbolUniqueId gl_TessLevelInnerTES         = TSymbolUniqueId(2008);
+    static constexpr const TSymbolUniqueId gl_TessLevelInnerTESES3_2    = TSymbolUniqueId(2009);
+    static constexpr const TSymbolUniqueId gl_PerVertexTES              = TSymbolUniqueId(2010);
+    static constexpr const TSymbolUniqueId gl_PerVertexTESES3_2         = TSymbolUniqueId(2011);
+    static constexpr const TSymbolUniqueId gl_inTES                     = TSymbolUniqueId(2012);
+    static constexpr const TSymbolUniqueId gl_inTESES3_2                = TSymbolUniqueId(2013);
+    static constexpr const TSymbolUniqueId gl_outTES                    = TSymbolUniqueId(2014);
+    static constexpr const TSymbolUniqueId gl_outTESES3_2               = TSymbolUniqueId(2015);
+    static constexpr const TSymbolUniqueId gl_PerVertexOutTesBlock      = TSymbolUniqueId(2016);
+    static constexpr const TSymbolUniqueId gl_PerVertexOutTesBlockES3_2 = TSymbolUniqueId(2017);
+    static constexpr const TSymbolUniqueId gl_PositionTES               = TSymbolUniqueId(2018);
+    static constexpr const TSymbolUniqueId gl_PositionTESES3_2          = TSymbolUniqueId(2019);
+    static constexpr const TSymbolUniqueId gl_ViewID_OVR                = TSymbolUniqueId(2020);
+    static constexpr const TSymbolUniqueId gl_ClipDistance              = TSymbolUniqueId(2021);
+    static constexpr const TSymbolUniqueId gl_CullDistance              = TSymbolUniqueId(2022);
 
 };  // class BuiltInId
 
diff --git a/src/gpu_info_util/SystemInfo_internal.h b/src/gpu_info_util/SystemInfo_internal.h
index 5cef5d49eea1b1f1e6c22543446b2e5391ee88f2..5bfff7a4587126abada2d0a2560fb32cce79bd37 100644
--- a/src/gpu_info_util/SystemInfo_internal.h
+++ b/src/gpu_info_util/SystemInfo_internal.h
@@ -41,11 +41,10 @@ uint64_t GetGpuIDFromDisplayID(uint32_t displayID);
 uint64_t GetGpuIDFromOpenGLDisplayMask(uint32_t displayMask);
 #    endif
 
-#endif
-
-#if defined(ANGLE_PLATFORM_MACOS) && ANGLE_ENABLE_METAL
+#    if ANGLE_ENABLE_METAL
 // Get VendorID from metal device's registry ID
 VendorID GetVendorIDFromMetalDeviceRegistryID(uint64_t registryID);
+#    endif
 #endif
 
 
diff --git a/src/libANGLE/Context.cpp b/src/libANGLE/Context.cpp
index 3064b432fb56454058cd1709b30c1d39ef81dfda..c394a7bfc262f204dcd6d154345f29f74d9658fc 100644
--- a/src/libANGLE/Context.cpp
+++ b/src/libANGLE/Context.cpp
@@ -9755,6 +9755,33 @@ void Context::textureFoveationParameters(TextureID texturePacked,
     texture->setFocalPoint(layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
 }
 
+void Context::framebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                   GLenum attachment,
+                                                   GLenum renderbuffertarget,
+                                                   RenderbufferID renderbuffer)
+{
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    Framebuffer *framebuffer = mState.getTargetFramebuffer(target);
+    ASSERT(framebuffer);
+
+    if (renderbuffer.value != 0)
+    {
+        Renderbuffer *renderbufferObject = getRenderbuffer(renderbuffer);
+
+        framebuffer->setAttachmentResolve(this, GL_RENDERBUFFER, attachment, gl::ImageIndex(),
+                                          renderbufferObject);
+    }
+    else
+    {
+        framebuffer->resetAttachmentResolve(this, attachment);
+    }
+
+    mState.setObjectDirty(target);
+#else
+    UNIMPLEMENTED();
+#endif
+}
+
 void Context::endTiling(GLbitfield preserveMask)
 {
     ANGLE_CONTEXT_TRY(mImplementation->endTiling(this, preserveMask));
@@ -9829,6 +9856,16 @@ void Context::blobCacheCallbacks(GLSETBLOBPROCANGLE set,
     mState.getBlobCacheCallbacks() = {set, get, userParam};
 }
 
+void Context::bindMetalRasterizationRateMap(GLuint renderbufferHandle,
+                                            GLMTLRasterizationRateMapANGLE map)
+{
+    Renderbuffer *renderbuffer = getRenderbuffer({renderbufferHandle});
+    rx::RenderbufferImpl *renderbufferImpl =
+        renderbuffer ? renderbuffer->getImplementation() : nullptr;
+    ANGLE_CONTEXT_TRY(mImplementation->bindMetalRasterizationRateMap(this, renderbufferImpl, map));
+    getMutablePrivateState()->setVariableRasterizationRateMap(map);
+}
+
 void Context::texStorageAttribs2D(GLenum target,
                                   GLsizei levels,
                                   GLenum internalFormat,
diff --git a/src/libANGLE/Context_gles_ext_autogen.h b/src/libANGLE/Context_gles_ext_autogen.h
index b193973b20b3b3dfc184bd316e178999e333d2af..b0a9d0b19386447c8b1b6c020a34975f5db0cf01 100644
--- a/src/libANGLE/Context_gles_ext_autogen.h
+++ b/src/libANGLE/Context_gles_ext_autogen.h
@@ -644,6 +644,8 @@
     void invalidateTexture(TextureType targetPacked);                                              \
     /* GL_ANGLE_texture_multisample */                                                             \
     /* GL_ANGLE_texture_rectangle */                                                               \
+    /* GL_ANGLE_variable_rasterization_rate_metal */                                               \
+    void bindMetalRasterizationRateMap(GLuint framebuffer, GLMTLRasterizationRateMapANGLE map);    \
     /* GL_ANGLE_vulkan_image */                                                                    \
     void acquireTextures(GLuint numTextures, const TextureID *texturesPacked,                      \
                          const GLenum *layouts);                                                   \
@@ -670,6 +672,10 @@
                         GLboolean unpackUnmultiplyAlpha);                                          \
     /* GL_CHROMIUM_framebuffer_mixed_samples */                                                    \
     /* GL_CHROMIUM_lose_context */                                                                 \
-    void loseContext(GraphicsResetStatus currentPacked, GraphicsResetStatus otherPacked);
+    void loseContext(GraphicsResetStatus currentPacked, GraphicsResetStatus otherPacked);          \
+    /* GL_WEBKIT_explicit_resolve_target */                                                        \
+    void framebufferResolveRenderbufferWEBKIT(GLenum target, GLenum attachment,                    \
+                                              GLenum renderbuffertarget,                           \
+                                              RenderbufferID renderbufferPacked);
 
 #endif  // ANGLE_CONTEXT_API_EXT_AUTOGEN_H_
diff --git a/src/libANGLE/Display.cpp b/src/libANGLE/Display.cpp
index 739f3ca4c3d9e6c4c00b194f2ab02999959f0fc4..87255a5fa88eada042cb7bd6130ec9101a6f6166 100644
--- a/src/libANGLE/Display.cpp
+++ b/src/libANGLE/Display.cpp
@@ -2289,7 +2289,7 @@ Error Display::validateImageClientBuffer(const gl::Context *context,
     return mImplementation->validateImageClientBuffer(context, target, clientBuffer, attribs);
 }
 
-Error Display::valdiatePixmap(const Config *config,
+Error Display::validatePixmap(const Config *config,
                               EGLNativePixmapType pixmap,
                               const AttributeMap &attributes) const
 {
diff --git a/src/libANGLE/Display.h b/src/libANGLE/Display.h
index aea0acc7cb8b630ee9092ffde7bfae8e46503b4b..5c6ff476f4f7328a806d159dac0a531b8b5f6431 100644
--- a/src/libANGLE/Display.h
+++ b/src/libANGLE/Display.h
@@ -217,7 +217,7 @@ class Display final : public LabeledObject,
                                     EGLenum target,
                                     EGLClientBuffer clientBuffer,
                                     const egl::AttributeMap &attribs) const;
-    Error valdiatePixmap(const Config *config,
+    Error validatePixmap(const Config *config,
                          EGLNativePixmapType pixmap,
                          const AttributeMap &attributes) const;
 
diff --git a/src/libANGLE/Framebuffer.cpp b/src/libANGLE/Framebuffer.cpp
index 6641ac2a2b925b8d3ec8cf1e3be0efca45fd379c..61c1b28bcc46e41f04fa74f5d307ecc117a40a07 100644
--- a/src/libANGLE/Framebuffer.cpp
+++ b/src/libANGLE/Framebuffer.cpp
@@ -167,6 +167,48 @@ FramebufferStatus CheckAttachmentCompleteness(const Context *context,
     return FramebufferStatus::Complete();
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+// Check the |checkAttachment| in reference to |firstAttachment| for the sake of explicit resolve
+// target framebuffer completeness.
+FramebufferStatus CheckResolveTargetMatchesForCompleteness(
+    const Context *context,
+    const FramebufferAttachment &firstAttachment,
+    const FramebufferAttachment &checkAttachment)
+{
+    ASSERT(firstAttachment.isAttached() && checkAttachment.isAttached());
+
+    FramebufferStatus attachmentCompleteness =
+        CheckAttachmentCompleteness(context, checkAttachment);
+    if (!attachmentCompleteness.isComplete())
+    {
+        return attachmentCompleteness;
+    }
+
+    if (checkAttachment.getSamples() != 0)
+    {
+        return FramebufferStatus::Incomplete(
+            GL_FRAMEBUFFER_UNSUPPORTED,
+            "Framebuffer is incomplete: Resolve attachments have multiple samples.");
+    }
+
+    if (firstAttachment.getSize() != checkAttachment.getSize())
+    {
+        return gl::FramebufferStatus::Incomplete(
+            GL_FRAMEBUFFER_UNSUPPORTED,
+            gl::err::kFramebufferIncompleteUnsupportedMissmatchedDimensions);
+    }
+
+    if (!Format::EquivalentForBlit(firstAttachment.getFormat(), checkAttachment.getFormat()))
+    {
+        return gl::FramebufferStatus::Incomplete(GL_FRAMEBUFFER_UNSUPPORTED,
+                                                 "Framebuffer is incomplete: Attempting to resolve "
+                                                 "to target with non-equivalent format for blit");
+    }
+
+    return FramebufferStatus::Complete();
+}
+#endif
+
 FramebufferStatus CheckAttachmentSampleCounts(const Context *context,
                                               GLsizei currAttachmentSamples,
                                               GLsizei samples,
@@ -396,6 +438,9 @@ FramebufferState::FramebufferState(rx::UniqueSerial serial)
       mFramebufferSerial(serial),
       mLabel(),
       mColorAttachments(1),
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+      mColorResolveAttachments(1),
+#endif
       mColorAttachmentsMask(0),
       mDrawBufferStates(1, GL_BACK),
       mReadBufferState(GL_BACK),
@@ -419,6 +464,9 @@ FramebufferState::FramebufferState(const Caps &caps, FramebufferID id, rx::Uniqu
       mFramebufferSerial(serial),
       mLabel(),
       mColorAttachments(caps.maxColorAttachments),
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+      mColorResolveAttachments(caps.maxColorAttachments),
+#endif
       mColorAttachmentsMask(0),
       mDrawBufferStates(caps.maxDrawBuffers, GL_NONE),
       mReadBufferState(GL_COLOR_ATTACHMENT0_EXT),
@@ -589,6 +637,27 @@ const FramebufferAttachment *FramebufferState::getDepthStencilAttachment() const
     return nullptr;
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+const FramebufferAttachment *FramebufferState::getColorResolveAttachment(
+    size_t colorAttachment) const
+{
+    ASSERT(colorAttachment < mColorResolveAttachments.size());
+    return mColorResolveAttachments[colorAttachment].isAttached()
+               ? &mColorResolveAttachments[colorAttachment]
+               : nullptr;
+}
+
+const FramebufferAttachment *FramebufferState::getDepthResolveAttachment() const
+{
+    return mDepthResolveAttachment.isAttached() ? &mDepthResolveAttachment : nullptr;
+}
+
+const FramebufferAttachment *FramebufferState::getStencilResolveAttachment() const
+{
+    return mStencilResolveAttachment.isAttached() ? &mStencilResolveAttachment : nullptr;
+}
+#endif
+
 const Extents FramebufferState::getAttachmentExtentsIntersection() const
 {
     int32_t width  = std::numeric_limits<int32_t>::max();
@@ -819,6 +888,10 @@ Framebuffer::Framebuffer(const Context *context, rx::GLImplFactory *factory, Fra
     ASSERT(mImpl != nullptr);
     ASSERT(mState.mColorAttachments.size() ==
            static_cast<size_t>(context->getCaps().maxColorAttachments));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    ASSERT(mState.mColorResolveAttachments.size() ==
+           static_cast<size_t>(context->getCaps().maxColorAttachments));
+#endif
 
     for (uint32_t colorIndex = 0;
          colorIndex < static_cast<uint32_t>(mState.mColorAttachments.size()); ++colorIndex)
@@ -853,6 +926,15 @@ void Framebuffer::onDestroy(const Context *context)
     mState.mWebGLStencilAttachment.detach(context, mState.mFramebufferSerial);
     mState.mWebGLDepthStencilAttachment.detach(context, mState.mFramebufferSerial);
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    for (auto &attachment : mState.mColorResolveAttachments)
+    {
+        attachment.detach(context, mState.mFramebufferSerial);
+    }
+    mState.mDepthResolveAttachment.detach(context, mState.mFramebufferSerial);
+    mState.mStencilResolveAttachment.detach(context, mState.mFramebufferSerial);
+#endif
+
     if (mPixelLocalStorage)
     {
         mPixelLocalStorage->onFramebufferDestroyed(context);
@@ -1142,6 +1224,23 @@ size_t Framebuffer::getDrawbufferStateCount() const
     return mState.mDrawBufferStates.size();
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+const FramebufferAttachment *Framebuffer::getColorResolveAttachment(size_t colorAttachment) const
+{
+    return mState.getColorResolveAttachment(colorAttachment);
+}
+
+const FramebufferAttachment *Framebuffer::getDepthResolveAttachment() const
+{
+    return mState.getDepthResolveAttachment();
+}
+
+const FramebufferAttachment *Framebuffer::getStencilResolveAttachment() const
+{
+    return mState.getStencilResolveAttachment();
+}
+#endif
+
 GLenum Framebuffer::getDrawBufferState(size_t drawBuffer) const
 {
     ASSERT(drawBuffer < mState.mDrawBufferStates.size());
@@ -1393,6 +1492,25 @@ FramebufferStatus Framebuffer::checkStatusWithGLFrontEnd(const Context *context)
         }
     }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    for (size_t index = 0; index < mState.mColorAttachments.size(); ++index)
+    {
+        const FramebufferAttachment &colorAttachment = mState.mColorAttachments[index];
+        const FramebufferAttachment &colorResolveAttachment =
+            mState.mColorResolveAttachments[index];
+        if (colorResolveAttachment.isAttached() && colorAttachment.isAttached())
+        {
+            FramebufferStatus resolveAttachmentCompleteness =
+                CheckResolveTargetMatchesForCompleteness(context, colorAttachment,
+                                                         colorResolveAttachment);
+            if (!resolveAttachmentCompleteness.isComplete())
+            {
+                return resolveAttachmentCompleteness;
+            }
+        }
+    }
+#endif
+
     const FramebufferAttachment &depthAttachment = mState.mDepthAttachment;
     if (depthAttachment.isAttached())
     {
@@ -1446,6 +1564,20 @@ FramebufferStatus Framebuffer::checkStatusWithGLFrontEnd(const Context *context)
                     err::kFramebufferIncompleteMismatchedLayeredAttachments);
             }
         }
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        const FramebufferAttachment &depthResolveAttachment = mState.mDepthResolveAttachment;
+        if (depthResolveAttachment.isAttached())
+        {
+            FramebufferStatus resolveAttachmentCompleteness =
+                CheckResolveTargetMatchesForCompleteness(context, depthAttachment,
+                                                         depthResolveAttachment);
+            if (!resolveAttachmentCompleteness.isComplete())
+            {
+                return resolveAttachmentCompleteness;
+            }
+        }
+#endif
     }
 
     const FramebufferAttachment &stencilAttachment = mState.mStencilAttachment;
@@ -1501,6 +1633,20 @@ FramebufferStatus Framebuffer::checkStatusWithGLFrontEnd(const Context *context)
                     err::kFramebufferIncompleteMismatchedLayeredAttachments);
             }
         }
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        const FramebufferAttachment &stencilResolveAttachment = mState.mStencilResolveAttachment;
+        if (stencilResolveAttachment.isAttached())
+        {
+            FramebufferStatus resolveAttachmentCompleteness =
+                CheckResolveTargetMatchesForCompleteness(context, stencilAttachment,
+                                                         stencilResolveAttachment);
+            if (!resolveAttachmentCompleteness.isComplete())
+            {
+                return resolveAttachmentCompleteness;
+            }
+        }
+#endif
     }
 
     // Starting from ES 3.0 stencil and depth, if present, should be the same image
@@ -1971,6 +2117,66 @@ void Framebuffer::setAttachmentMultiview(const Context *context,
                   FramebufferAttachment::kDefaultRenderToTextureSamples);
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void Framebuffer::setAttachmentResolve(const Context *context,
+                                       GLenum type,
+                                       GLenum binding,
+                                       const ImageIndex &textureIndex,
+                                       FramebufferAttachmentObject *resource)
+{
+    switch (binding)
+    {
+        case GL_DEPTH_STENCIL:
+        case GL_DEPTH_STENCIL_ATTACHMENT:
+            updateAttachmentResolve(context, &mState.mDepthResolveAttachment,
+                                    DIRTY_BIT_DEPTH_ATTACHMENT, &mDirtyDepthAttachmentBinding, type,
+                                    binding, textureIndex, resource);
+            updateAttachmentResolve(context, &mState.mStencilResolveAttachment,
+                                    DIRTY_BIT_STENCIL_ATTACHMENT, &mDirtyStencilAttachmentBinding,
+                                    type, binding, textureIndex, resource);
+            break;
+        case GL_DEPTH:
+        case GL_DEPTH_ATTACHMENT:
+            updateAttachmentResolve(context, &mState.mDepthResolveAttachment,
+                                    DIRTY_BIT_DEPTH_ATTACHMENT, &mDirtyDepthAttachmentBinding, type,
+                                    binding, textureIndex, resource);
+            if (context->isWebGL1())
+            {
+                updateAttachmentResolve(context, &mState.mStencilResolveAttachment,
+                                        DIRTY_BIT_STENCIL_ATTACHMENT,
+                                        &mDirtyStencilAttachmentBinding, GL_NONE,
+                                        GL_STENCIL_ATTACHMENT, ImageIndex(), nullptr);
+            }
+            break;
+
+        case GL_STENCIL:
+        case GL_STENCIL_ATTACHMENT:
+            updateAttachmentResolve(context, &mState.mStencilResolveAttachment,
+                                    DIRTY_BIT_STENCIL_ATTACHMENT, &mDirtyStencilAttachmentBinding,
+                                    type, binding, textureIndex, resource);
+            if (context->isWebGL1())
+            {
+                updateAttachmentResolve(context, &mState.mDepthResolveAttachment,
+                                        DIRTY_BIT_DEPTH_ATTACHMENT, &mDirtyDepthAttachmentBinding,
+                                        GL_NONE, GL_DEPTH_ATTACHMENT, ImageIndex(), nullptr);
+            }
+            break;
+
+        default:
+        {
+            const size_t colorIndex = binding - GL_COLOR_ATTACHMENT0;
+            ASSERT(colorIndex < mState.mColorResolveAttachments.size());
+
+            const size_t dirtyBit = DIRTY_BIT_COLOR_ATTACHMENT_0 + colorIndex;
+            updateAttachmentResolve(context, &mState.mColorResolveAttachments[colorIndex], dirtyBit,
+                                    &mDirtyColorAttachmentBindings[colorIndex], type, binding,
+                                    textureIndex, resource);
+        }
+        break;
+    }
+}
+#endif
+
 void Framebuffer::commitWebGL1DepthStencilIfConsistent(const Context *context,
                                                        GLsizei numViews,
                                                        GLuint baseViewIndex,
@@ -2148,11 +2354,40 @@ void Framebuffer::updateAttachment(const Context *context,
     invalidateCompletenessCache();
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void Framebuffer::updateAttachmentResolve(const Context *context,
+                                          FramebufferAttachment *attachment,
+                                          size_t dirtyBit,
+                                          angle::ObserverBinding *onDirtyBinding,
+                                          GLenum type,
+                                          GLenum binding,
+                                          const ImageIndex &textureIndex,
+                                          FramebufferAttachmentObject *resource)
+{
+    attachment->attach(
+        context, type, binding, textureIndex, resource, FramebufferAttachment::kDefaultNumViews,
+        FramebufferAttachment::kDefaultBaseViewIndex, false,
+        FramebufferAttachment::kDefaultRenderToTextureSamples, mState.mFramebufferSerial);
+    mDirtyBits.set(dirtyBit);
+    onDirtyBinding->bind(resource);
+    mAttachmentChangedAfterEnablingFoveation = isFoveationEnabled();
+
+    invalidateCompletenessCache();
+}
+#endif
+
 void Framebuffer::resetAttachment(const Context *context, GLenum binding)
 {
     setAttachment(context, GL_NONE, binding, ImageIndex(), nullptr);
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void Framebuffer::resetAttachmentResolve(const Context *context, GLenum binding)
+{
+    setAttachmentResolve(context, GL_NONE, binding, ImageIndex(), nullptr);
+}
+#endif
+
 void Framebuffer::setWriteControlMode(SrgbWriteControlMode srgbWriteControlMode)
 {
     if (srgbWriteControlMode != mState.getWriteControlMode())
@@ -2808,4 +3043,5 @@ angle::Result Framebuffer::syncAttachmentState(const Context *context,
 
     return angle::Result::Continue;
 }
+
 }  // namespace gl
diff --git a/src/libANGLE/Framebuffer.h b/src/libANGLE/Framebuffer.h
index 5bb706c9a19c72f8c4c37b9bfc6677851a4ef201..2172770ea95bb3d3a6b4bb6b133bf43cf63564b5 100644
--- a/src/libANGLE/Framebuffer.h
+++ b/src/libANGLE/Framebuffer.h
@@ -82,6 +82,13 @@ class FramebufferState final : angle::NonCopyable
     const FramebufferAttachment *getDepthStencilAttachment() const;
     const FramebufferAttachment *getReadPixelsAttachment(GLenum readFormat) const;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    const FramebufferAttachment *getColorResolveAttachment(size_t colorAttachment) const;
+    const FramebufferAttachment *getDepthResolveAttachment() const;
+    const FramebufferAttachment *getStencilResolveAttachment() const;
+#endif
+
     const DrawBuffersVector<GLenum> &getDrawBufferStates() const { return mDrawBufferStates; }
     DrawBufferMask getEnabledDrawBuffers() const { return mEnabledDrawBuffers; }
     GLenum getReadBufferState() const { return mReadBufferState; }
@@ -155,6 +162,13 @@ class FramebufferState final : angle::NonCopyable
     FramebufferAttachment mDepthAttachment;
     FramebufferAttachment mStencilAttachment;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target;
+    DrawBuffersVector<FramebufferAttachment> mColorResolveAttachments;
+    FramebufferAttachment mDepthResolveAttachment;
+    FramebufferAttachment mStencilResolveAttachment;
+#endif
+
     // Tracks all the color buffers attached to this FramebufferDesc
     DrawBufferMask mColorAttachmentsMask;
 
@@ -237,6 +251,16 @@ class Framebuffer final : public angle::ObserverInterface,
                                 GLint baseViewIndex);
     void resetAttachment(const Context *context, GLenum binding);
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    void setAttachmentResolve(const Context *context,
+                              GLenum type,
+                              GLenum binding,
+                              const ImageIndex &textureIndex,
+                              FramebufferAttachmentObject *resource);
+    void resetAttachmentResolve(const Context *context, GLenum binding);
+#endif
+
     bool detachTexture(Context *context, TextureID texture);
     bool detachRenderbuffer(Context *context, RenderbufferID renderbuffer);
 
@@ -251,9 +275,16 @@ class Framebuffer final : public angle::ObserverInterface,
     const FramebufferAttachment *getFirstColorAttachment() const;
     const FramebufferAttachment *getFirstNonNullAttachment() const;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    const FramebufferAttachment *getColorResolveAttachment(size_t colorAttachment) const;
+    const FramebufferAttachment *getDepthResolveAttachment() const;
+    const FramebufferAttachment *getStencilResolveAttachment() const;
+#endif
+
     const DrawBuffersVector<FramebufferAttachment> &getColorAttachments() const
     {
-        return mState.mColorAttachments;
+        return mState.getColorAttachments();
     }
 
     const FramebufferState &getState() const { return mState; }
@@ -522,6 +553,18 @@ class Framebuffer final : public angle::ObserverInterface,
                           bool isMultiview,
                           GLsizei samples);
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    void updateAttachmentResolve(const Context *context,
+                                 FramebufferAttachment *attachment,
+                                 size_t dirtyBit,
+                                 angle::ObserverBinding *onDirtyBinding,
+                                 GLenum type,
+                                 GLenum binding,
+                                 const ImageIndex &textureIndex,
+                                 FramebufferAttachmentObject *resource);
+#endif
+
     void markAttachmentsInitialized(const DrawBufferMask &color, bool depth, bool stencil);
 
     // Checks that we have a partially masked clear:
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index d8aa5471ff995f673a52dc9f5841cc7c4314166f..a4a1a7d395a638c170747221eab2a08dfb6ce93c 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
@@ -368,6 +371,8 @@ PrivateState::PrivateState(const Version &clientVersion,
       mLogicOp(LogicalOperation::Copy),
       mPatchVertices(3),
       mPixelLocalStorageActivePlanes(0),
+      mVariableRasterizationRateEnabled(false),
+      mVariableRasterizationRateMap(nullptr),
       mNoSimultaneousConstantColorAndAlphaBlendFunc(false),
       mSetBlendIndexedInvoked(false),
       mSetBlendFactorsIndexedInvoked(false),
@@ -1399,6 +1404,26 @@ void PrivateState::setLogicOp(LogicalOperation opcode)
     }
 }
 
+void PrivateState::setVariableRasterizationRateEnabled(bool enabled)
+{
+    if (mVariableRasterizationRateEnabled != enabled)
+    {
+        mVariableRasterizationRateEnabled = enabled;
+        mDirtyBits.set(state::DIRTY_BIT_EXTENDED);
+        mExtendedDirtyBits.set(state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+    }
+}
+
+void PrivateState::setVariableRasterizationRateMap(GLMTLRasterizationRateMapANGLE map)
+{
+    if (mVariableRasterizationRateMap != map)
+    {
+        mVariableRasterizationRateMap = map;
+        mDirtyBits.set(state::DIRTY_BIT_EXTENDED);
+        mExtendedDirtyBits.set(state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+    }
+}
+
 void PrivateState::setVertexAttribf(GLuint index, const GLfloat values[4])
 {
     ASSERT(static_cast<size_t>(index) < mVertexAttribCurrentValues.size());
@@ -1531,6 +1556,9 @@ void PrivateState::setEnableFeature(GLenum feature, bool enabled)
         case GL_FETCH_PER_SAMPLE_ARM:
             mFetchPerSample = enabled;
             return;
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            setVariableRasterizationRateEnabled(enabled);
+            return;
         default:
             break;
     }
@@ -1697,6 +1725,8 @@ bool PrivateState::getEnableFeature(GLenum feature) const
             return mShadingRatePreserveAspectRatio;
         case GL_FETCH_PER_SAMPLE_ARM:
             return mFetchPerSample;
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            return mVariableRasterizationRateEnabled;
     }
 
     ASSERT(mClientVersion < ES_2_0);
@@ -3618,6 +3648,9 @@ void State::getPointerv(const Context *context, GLenum pname, void **params) con
         case GL_BLOB_CACHE_USER_PARAM_ANGLE:
             *params = const_cast<void *>(getBlobCacheCallbacks().userParam);
             break;
+        case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+            *params = privateState().getVariableRasterizationRateMap();
+            break;
         default:
             UNREACHABLE();
             break;
diff --git a/src/libANGLE/State.h b/src/libANGLE/State.h
index f47439c48bf20a9f4265c2ea9c7a5eb1355a527a..6ce86ea835dbba2535c86e7cbdf10837fb7a4687 100644
--- a/src/libANGLE/State.h
+++ b/src/libANGLE/State.h
@@ -173,6 +173,7 @@ enum ExtendedDirtyBitType
     EXTENDED_DIRTY_BIT_LOGIC_OP_ENABLED,              // ANGLE_logic_op
     EXTENDED_DIRTY_BIT_LOGIC_OP,                      // ANGLE_logic_op
     EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT,       // KHR_blend_operation_advanced_coherent
+    EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE,   // ANGLE_variable_rasterization_rate_metal
 
     EXTENDED_DIRTY_BIT_INVALID,
     EXTENDED_DIRTY_BIT_MAX = EXTENDED_DIRTY_BIT_INVALID,
@@ -473,6 +474,15 @@ class PrivateState : angle::NonCopyable
     bool hasActivelyOverriddenPLSDrawBuffers(GLint *firstActivePLSDrawBuffer) const;
     bool isActivelyOverriddenPLSDrawBuffer(GLint drawbuffer) const;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    void setVariableRasterizationRateEnabled(bool enabled);
+    bool isVariableRasterizationRateEnabled() const { return mVariableRasterizationRateEnabled; }
+    void setVariableRasterizationRateMap(GLMTLRasterizationRateMapANGLE map);
+    GLMTLRasterizationRateMapANGLE getVariableRasterizationRateMap() const
+    {
+        return mVariableRasterizationRateMap;
+    }
+
     // Line width state setter
     void setLineWidth(GLfloat width);
     float getLineWidth() const { return mLineWidth; }
@@ -705,6 +715,10 @@ class PrivateState : angle::NonCopyable
     DrawBufferMask mPLSDeferredBlendEnables;
     BlendStateExt::ColorMaskStorage::Type mPLSDeferredColorMasks;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    bool mVariableRasterizationRateEnabled;
+    GLMTLRasterizationRateMapANGLE mVariableRasterizationRateMap;
+
     // GLES1 emulation: state specific to GLES1
     GLES1State mGLES1State;
 
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.cpp b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
index 049a5d3bf056d9a0d2be7be976ba8cd2d5f071b6..9a7dc7cfa522f343f996d6f73f275931281ca0fd 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.cpp
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
@@ -5221,6 +5221,20 @@ CallCapture CaptureGetTranslatedShaderSourceANGLE(const State &glState,
     return CallCapture(angle::EntryPoint::GLGetTranslatedShaderSourceANGLE, std::move(paramBuffer));
 }
 
+CallCapture CaptureBindMetalRasterizationRateMapANGLE(const State &glState,
+                                                      bool isCallValid,
+                                                      GLuint framebuffer,
+                                                      GLMTLRasterizationRateMapANGLE map)
+{
+    ParamBuffer paramBuffer;
+
+    paramBuffer.addValueParam("framebuffer", ParamType::TGLuint, framebuffer);
+    paramBuffer.addValueParam("map", ParamType::TGLMTLRasterizationRateMapANGLE, map);
+
+    return CallCapture(angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE,
+                       std::move(paramBuffer));
+}
+
 CallCapture CaptureAcquireTexturesANGLE(const State &glState,
                                         bool isCallValid,
                                         GLuint numTextures,
@@ -12411,4 +12425,23 @@ CallCapture CaptureStartTilingQCOM(const State &glState,
     return CallCapture(angle::EntryPoint::GLStartTilingQCOM, std::move(paramBuffer));
 }
 
+CallCapture CaptureFramebufferResolveRenderbufferWEBKIT(const State &glState,
+                                                        bool isCallValid,
+                                                        GLenum target,
+                                                        GLenum attachment,
+                                                        GLenum renderbuffertarget,
+                                                        RenderbufferID renderbufferPacked)
+{
+    ParamBuffer paramBuffer;
+
+    paramBuffer.addEnumParam("target", GLESEnum::AllEnums, ParamType::TGLenum, target);
+    paramBuffer.addEnumParam("attachment", GLESEnum::AllEnums, ParamType::TGLenum, attachment);
+    paramBuffer.addEnumParam("renderbuffertarget", GLESEnum::AllEnums, ParamType::TGLenum,
+                             renderbuffertarget);
+    paramBuffer.addValueParam("renderbufferPacked", ParamType::TRenderbufferID, renderbufferPacked);
+
+    return CallCapture(angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT,
+                       std::move(paramBuffer));
+}
+
 }  // namespace gl
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.h b/src/libANGLE/capture/capture_gles_ext_autogen.h
index 992366283a381160d05d51482ec358308f50104e..e6342ba14107509322cb17ea1b2e220841b652ef 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.h
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.h
@@ -1007,6 +1007,12 @@ angle::CallCapture CaptureGetTranslatedShaderSourceANGLE(const State &glState,
                                                          GLsizei *length,
                                                          GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+angle::CallCapture CaptureBindMetalRasterizationRateMapANGLE(const State &glState,
+                                                             bool isCallValid,
+                                                             GLuint framebuffer,
+                                                             GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 angle::CallCapture CaptureAcquireTexturesANGLE(const State &glState,
                                                bool isCallValid,
@@ -2932,6 +2938,14 @@ angle::CallCapture CaptureStartTilingQCOM(const State &glState,
                                           GLuint height,
                                           GLbitfield preserveMask);
 
+// GL_WEBKIT_explicit_resolve_target
+angle::CallCapture CaptureFramebufferResolveRenderbufferWEBKIT(const State &glState,
+                                                               bool isCallValid,
+                                                               GLenum target,
+                                                               GLenum attachment,
+                                                               GLenum renderbuffertarget,
+                                                               RenderbufferID renderbufferPacked);
+
 // Parameter Captures
 
 void CaptureDeletePerfMonitorsAMD_monitors(const State &glState,
diff --git a/src/libANGLE/features.h b/src/libANGLE/features.h
index a6fe076c72d043dba3fc347bf020ebf8ec895f51..add46e99c91d19bbd790d2de0d8768b8953d633e 100644
--- a/src/libANGLE/features.h
+++ b/src/libANGLE/features.h
@@ -44,4 +44,11 @@
 #    define ANGLE_PROGRAM_LINK_VALIDATE_UNIFORM_PRECISION 1
 #endif
 
+// Lose context on Metal command queue error
+// ENABLED check Metal command buffer status on completion for error and lose context on error.
+// DISABLED Metal backed contexts are never lost.
+#if !defined(ANGLE_METAL_LOSE_CONTEXT_ON_ERROR)
+#    define ANGLE_METAL_LOSE_CONTEXT_ON_ERROR ANGLE_ENABLED
+#endif
+
 #endif  // LIBANGLE_FEATURES_H_
diff --git a/src/libANGLE/formatutils.cpp b/src/libANGLE/formatutils.cpp
index 0545f11dbf48a0ddab1de69dea6047d03e9f506f..fc5006a6ee70bfe034cd791a542c28d64e53c43e 100644
--- a/src/libANGLE/formatutils.cpp
+++ b/src/libANGLE/formatutils.cpp
@@ -583,6 +583,7 @@ static GLenum EquivalentBlitInternalFormat(GLenum internalformat)
     // multisampled RGBA8 renderbuffer to a BGRA8 texture). This could
     // be expanded and/or autogenerated if that is found necessary.
     if (internalformat == GL_BGRA_EXT || internalformat == GL_BGRA8_EXT ||
+        internalformat == GL_SRGB8_ALPHA8_EXT || internalformat == GL_BGRA8_EXT ||
         internalformat == GL_BGRA8_SRGB_ANGLEX)
     {
         return GL_RGBA8;
diff --git a/src/libANGLE/gles_extensions_autogen.cpp b/src/libANGLE/gles_extensions_autogen.cpp
index 76e8d0348694d83155cac13e07045558aacac015..fc2efc15c66b07a1452453d0f4d9daae4e4fcaf8 100644
--- a/src/libANGLE/gles_extensions_autogen.cpp
+++ b/src/libANGLE/gles_extensions_autogen.cpp
@@ -243,6 +243,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_CHROMIUM_copy_compressed_texture"] = esOnlyExtension(&Extensions::copyCompressedTextureCHROMIUM);
         map["GL_CHROMIUM_copy_texture"] = esOnlyExtension(&Extensions::copyTextureCHROMIUM);
         map["GL_ANGLE_copy_texture_3d"] = enableableExtension(&Extensions::copyTexture3dANGLE);
+        map["GL_WEBKIT_explicit_resolve_target"] = enableableExtension(&Extensions::explicitResolveTargetWEBKIT);
         map["GL_CHROMIUM_framebuffer_mixed_samples"] = esOnlyExtension(&Extensions::framebufferMixedSamplesCHROMIUM);
         map["GL_ANGLE_framebuffer_multisample"] = enableableExtension(&Extensions::framebufferMultisampleANGLE);
         map["GL_ANGLE_get_image"] = enableableExtension(&Extensions::getImageANGLE);
@@ -279,6 +280,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_ANGLE_texture_external_update"] = enableableExtension(&Extensions::textureExternalUpdateANGLE);
         map["GL_ANGLE_texture_multisample"] = enableableExtension(&Extensions::textureMultisampleANGLE);
         map["GL_ANGLE_texture_rectangle"] = enableableExtension(&Extensions::textureRectangleANGLE);
+        map["GL_ANGLE_variable_rasterization_rate_metal"] = enableableExtension(&Extensions::variableRasterizationRateMetalANGLE);
         map["GL_ANGLE_vulkan_image"] = enableableExtension(&Extensions::vulkanImageANGLE);
         map["GL_ANGLE_webgl_compatibility"] = esOnlyExtension(&Extensions::webglCompatibilityANGLE);
         map["GL_ANGLE_yuv_internal_format"] = enableableExtension(&Extensions::yuvInternalFormatANGLE);
diff --git a/src/libANGLE/gles_extensions_autogen.h b/src/libANGLE/gles_extensions_autogen.h
index 0b18727c1a1826e673fad65960ac98dd10065b40..f3ef2beb3b63e2b4a9621065fdfe55a3e6e9e4a9 100644
--- a/src/libANGLE/gles_extensions_autogen.h
+++ b/src/libANGLE/gles_extensions_autogen.h
@@ -689,6 +689,9 @@ struct Extensions
     // GL_ANGLE_copy_texture_3d
     bool copyTexture3dANGLE = false;
 
+    // GL_WEBKIT_explicit_resolve_target
+    bool explicitResolveTargetWEBKIT = false;
+
     // GL_CHROMIUM_framebuffer_mixed_samples
     bool framebufferMixedSamplesCHROMIUM = false;
 
@@ -797,6 +800,9 @@ struct Extensions
     // GL_ANGLE_texture_rectangle
     bool textureRectangleANGLE = false;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    bool variableRasterizationRateMetalANGLE = false;
+
     // GL_ANGLE_vulkan_image
     bool vulkanImageANGLE = false;
 
diff --git a/src/libANGLE/renderer/ContextImpl.cpp b/src/libANGLE/renderer/ContextImpl.cpp
index 5a02f1d07a4145c6bb208495fb65a494a1d91437..4218674eea7b162060593a8714987db7e289e7e1 100644
--- a/src/libANGLE/renderer/ContextImpl.cpp
+++ b/src/libANGLE/renderer/ContextImpl.cpp
@@ -108,4 +108,13 @@ const angle::PerfMonitorCounterGroups &ContextImpl::getPerfMonitorCounters()
     static angle::base::NoDestructor<angle::PerfMonitorCounterGroups> sCounters;
     return *sCounters;
 }
+
+angle::Result ContextImpl::bindMetalRasterizationRateMap(gl::Context *,
+                                                         RenderbufferImpl *renderbuffer,
+                                                         GLMTLRasterizationRateMapANGLE map)
+{
+    UNREACHABLE();
+    return angle::Result::Stop;
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/ContextImpl.h b/src/libANGLE/renderer/ContextImpl.h
index dbfd9c5600f402d462564e4f4f447a82d9482d18..a7e3fa9132f5297bbe2ade4eed37716de6a0b1dd 100644
--- a/src/libANGLE/renderer/ContextImpl.h
+++ b/src/libANGLE/renderer/ContextImpl.h
@@ -280,6 +280,11 @@ class ContextImpl : public GLImplFactory
     // AMD_performance_monitor
     virtual const angle::PerfMonitorCounterGroups &getPerfMonitorCounters();
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    virtual angle::Result bindMetalRasterizationRateMap(gl::Context *,
+                                                        RenderbufferImpl *renderbuffer,
+                                                        GLMTLRasterizationRateMapANGLE map);
+
   protected:
     const gl::State &mState;
     gl::MemoryProgramCache *mMemoryProgramCache;
diff --git a/src/libANGLE/renderer/DisplayImpl.cpp b/src/libANGLE/renderer/DisplayImpl.cpp
index 6deb8709420e8f0ac9b8f8331856033992b1f6bc..1b94d64d332bf5b98138f0715c8572b4eaaa5186 100644
--- a/src/libANGLE/renderer/DisplayImpl.cpp
+++ b/src/libANGLE/renderer/DisplayImpl.cpp
@@ -102,7 +102,7 @@ egl::Error DisplayImpl::validatePixmap(const egl::Config *config,
                                        const egl::AttributeMap &attributes) const
 {
     UNREACHABLE();
-    return egl::Error(EGL_BAD_DISPLAY, "DisplayImpl::valdiatePixmap unimplemented.");
+    return egl::Error(EGL_BAD_DISPLAY, "DisplayImpl::validatePixmap unimplemented.");
 }
 
 const egl::Caps &DisplayImpl::getCaps() const
diff --git a/src/libANGLE/renderer/gl/FunctionsGL.cpp b/src/libANGLE/renderer/gl/FunctionsGL.cpp
index 7b6aa2a7a1f66dd8c06353959823d23dd17ae9c4..6798c79869bea01ee270764c234d7d216336bb3a 100644
--- a/src/libANGLE/renderer/gl/FunctionsGL.cpp
+++ b/src/libANGLE/renderer/gl/FunctionsGL.cpp
@@ -55,7 +55,11 @@ static std::vector<std::string> GetIndexedExtensions(PFNGLGETINTEGERVPROC getInt
 
     for (GLint i = 0; i < numExtensions; i++)
     {
-        result.push_back(reinterpret_cast<const char *>(getStringIFunction(GL_EXTENSIONS, i)));
+        if (const char *extensionString =
+                reinterpret_cast<const char *>(getStringIFunction(GL_EXTENSIONS, i)))
+        {
+            result.push_back(extensionString);
+        }
     }
 
     return result;
diff --git a/src/libANGLE/renderer/gl/StateManagerGL.cpp b/src/libANGLE/renderer/gl/StateManagerGL.cpp
index b8a1656397f0b2ac6322d80103cef966e16f8e48..63f747465cf4733dfb442da542f9610779fca4c0 100644
--- a/src/libANGLE/renderer/gl/StateManagerGL.cpp
+++ b/src/libANGLE/renderer/gl/StateManagerGL.cpp
@@ -2529,6 +2529,9 @@ angle::Result StateManagerGL::syncState(const gl::Context *context,
                         case gl::state::EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT:
                             setBlendAdvancedCoherent(state.isBlendAdvancedCoherentEnabled());
                             break;
+                        case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                            // Unimplemented extensions.
+                            break;
                         default:
                             UNREACHABLE();
                             break;
diff --git a/src/libANGLE/renderer/metal/BUILD.gn b/src/libANGLE/renderer/metal/BUILD.gn
index 96e9ee8420810f6a3ca9a0c290d4a654200eb7b9..8725219587ee8afc25e803bfd84f0fb117176372 100644
--- a/src/libANGLE/renderer/metal/BUILD.gn
+++ b/src/libANGLE/renderer/metal/BUILD.gn
@@ -15,7 +15,10 @@ assert(is_mac || is_ios)
 assert(angle_enable_metal)
 
 config("angle_metal_backend_config") {
-  defines = [ "ANGLE_ENABLE_METAL" ]
+  defines = [
+    "ANGLE_ENABLE_METAL",
+    "ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED=1",
+  ]
   ldflags = [
     "-weak_framework",
     "Metal",
diff --git a/src/libANGLE/renderer/metal/BufferMtl.mm b/src/libANGLE/renderer/metal/BufferMtl.mm
index d7a8d303e14b84a1682efdf7c5f9d178cf0602cd..4f0fe2073edd0ca256ad96c358d7b656fa4181b1 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.mm
+++ b/src/libANGLE/renderer/metal/BufferMtl.mm
@@ -400,7 +400,7 @@ ConversionBufferMtl *BufferMtl::getUniformConversionBuffer(ContextMtl *context,
         {
             if (buffer.offset.second <= offset.second &&
                 (offset.second - buffer.offset.second) % buffer.uniformBufferBlockSize == 0)
-                return &buffer;
+                return static_cast<ConversionBufferMtl *>(&buffer);
         }
     }
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.h b/src/libANGLE/renderer/metal/ContextMtl.h
index 65cde4caf7c08051bd50aac215d5925acb4218e9..503fc7b5213fb5cadd0d64a57b1dcc912448a690 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.h
+++ b/src/libANGLE/renderer/metal/ContextMtl.h
@@ -272,6 +272,10 @@ class ContextMtl : public ContextImpl, public mtl::Context
     angle::Result memoryBarrier(const gl::Context *context, GLbitfield barriers) override;
     angle::Result memoryBarrierByRegion(const gl::Context *context, GLbitfield barriers) override;
 
+    angle::Result bindMetalRasterizationRateMap(gl::Context *context,
+                                                RenderbufferImpl *renderbuffer,
+                                                GLMTLRasterizationRateMapANGLE map) override;
+
     // override mtl::ErrorHandler
     void handleError(GLenum error,
                      const char *message,
@@ -555,6 +559,7 @@ class ContextMtl : public ContextImpl, public mtl::Context
         DIRTY_BIT_RENDER_PIPELINE,
         DIRTY_BIT_UNIFORM_BUFFERS_BINDING,
         DIRTY_BIT_RASTERIZER_DISCARD,
+        DIRTY_BIT_VARIABLE_RASTERIZATION_RATE,
 
         DIRTY_BIT_INVALID,
         DIRTY_BIT_MAX = DIRTY_BIT_INVALID,
@@ -648,6 +653,9 @@ class ContextMtl : public ContextImpl, public mtl::Context
     IncompleteTextureSet mIncompleteTextures;
     ProvokingVertexHelper mProvokingVertexHelper;
 
+    angle::ObjCPtr<id<MTLRasterizationRateMap>> mRasterizationRateMap;
+    id<MTLTexture> mRasterizationRateMapTexture;
+
     mtl::ContextDevice mContextDevice;
 };
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index f70c884921da44eb214456f3f42c5a818e7587b2..035aed0ae4802d45f3a970dc1896c2a6c718fcba 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -246,6 +246,8 @@ void ContextMtl::onDestroy(const gl::Context *context)
     mIncompleteTextures.onDestroy(context);
     mProvokingVertexHelper.onDestroy(this);
     mDummyXFBRenderTexture = nullptr;
+    mRasterizationRateMap.reset();
+    mRasterizationRateMapTexture = nil;
 
     mContextDevice.reset();
 }
@@ -1056,6 +1058,13 @@ angle::Result ContextMtl::multiDrawElementsInstancedBaseVertexBaseInstance(
 // Device loss
 gl::GraphicsResetStatus ContextMtl::getResetStatus()
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    if (cmdQueue().isDeviceLost())
+    {
+        return gl::GraphicsResetStatus::UnknownContextReset;
+    }
+#endif
+
     return gl::GraphicsResetStatus::NoError;
 }
 
@@ -1394,6 +1403,9 @@ void ContextMtl::updateExtendedState(const gl::State &glState,
             case gl::state::EXTENDED_DIRTY_BIT_POLYGON_OFFSET_LINE_ENABLED:
                 mDirtyBits.set(DIRTY_BIT_DEPTH_BIAS);
                 break;
+            case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                mDirtyBits.set(DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+                break;
             default:
                 break;
         }
@@ -1648,6 +1660,37 @@ angle::Result ContextMtl::memoryBarrierByRegion(const gl::Context *context, GLbi
     return angle::Result::Stop;
 }
 
+angle::Result ContextMtl::bindMetalRasterizationRateMap(gl::Context *context,
+                                                        RenderbufferImpl *renderbuffer,
+                                                        GLMTLRasterizationRateMapANGLE map)
+{
+    id<MTLRasterizationRateMap> rateMap = (__bridge id<MTLRasterizationRateMap>)(map);
+    if (rateMap && rateMap.device != mContextDevice.get())
+    {
+        return angle::Result::Stop;
+    }
+
+    if (auto *metalRenderbuffer = static_cast<RenderbufferMtl *>(renderbuffer))
+    {
+        FramebufferAttachmentRenderTarget *rtOut = nullptr;
+        gl::ImageIndex index;
+        GLenum binding = 0;
+        if (angle::Result::Continue ==
+            metalRenderbuffer->getAttachmentRenderTarget(context, binding, index, 1, &rtOut))
+        {
+            if (auto *renderTargetMetal = static_cast<RenderTargetMtl *>(rtOut))
+            {
+                mtl::RenderPassAttachmentDesc desc;
+                renderTargetMetal->toRenderPassAttachmentDesc(&desc);
+                mRasterizationRateMapTexture = desc.texture.get()->get();
+            }
+        }
+    }
+
+    mRasterizationRateMap = std::move(rateMap);
+    return angle::Result::Continue;
+}
+
 // override mtl::ErrorHandler
 void ContextMtl::handleError(GLenum glErrorCode,
                              const char *message,
@@ -2496,8 +2539,22 @@ angle::Result ContextMtl::setupDraw(const gl::Context *context,
             return checkCommandBufferError();
         }
         // Setup with flushed state should either produce a working encoder or fail with an error
-        // result.
-        ASSERT(mRenderEncoder.valid());
+        // result. if that's not the case, something's gone seriously wrong. Try to
+        // recover from the error by bailing out of the draw call, and finishing the command buffer.
+        // This will result in an unfinished / corrupted draw, but will avoid a browser/GPU process
+        // crash.
+        if (ANGLE_UNLIKELY(!mRenderEncoder.valid() || !mRenderEncoder.hasPipelineState()))
+        {
+            // Completely flush the command buffer, waiting synchronously.
+            flushCommandBuffer(mtl::WaitUntilFinished);
+            // Invalidate all state
+            invalidateState(context);
+            // Return fail, and drop the draw call. This is
+            // a worst case scenario. If in a debug roots situation,
+            // we should try to catch the call stack.
+            ERR() << "Draw call is unusable - please report a bug on bugs.webkit.org";
+            return angle::Result::Stop;
+        }
     }
     return angle::Result::Continue;
 }
@@ -2606,10 +2663,14 @@ angle::Result ContextMtl::setupDrawImpl(const gl::Context *context,
                     mState.getBlendColor().blue, mState.getBlendColor().alpha);
                 break;
             case DIRTY_BIT_VIEWPORT:
-                mRenderEncoder.setViewport(mViewport);
+                mRenderEncoder.setViewport(
+                    mViewport, mRenderEncoder.rasterizationRateMapForPass(
+                                   mRasterizationRateMap, mRasterizationRateMapTexture));
                 break;
             case DIRTY_BIT_SCISSOR:
-                mRenderEncoder.setScissorRect(mScissorRect);
+                mRenderEncoder.setScissorRect(
+                    mScissorRect, mRenderEncoder.rasterizationRateMapForPass(
+                                      mRasterizationRateMap, mRasterizationRateMapTexture));
                 break;
             case DIRTY_BIT_DRAW_FRAMEBUFFER:
                 // Already handled.
@@ -2634,6 +2695,15 @@ angle::Result ContextMtl::setupDrawImpl(const gl::Context *context,
             case DIRTY_BIT_RASTERIZER_DISCARD:
                 // Already handled.
                 break;
+            case DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                if (getState().privateState().isVariableRasterizationRateEnabled() &&
+                    mRasterizationRateMap)
+                {
+                    mRenderEncoder.setRasterizationRateMap(
+                        mRenderEncoder.rasterizationRateMapForPass(mRasterizationRateMap,
+                                                                   mRasterizationRateMapTexture));
+                }
+                break;
             default:
                 UNREACHABLE();
                 break;
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.h b/src/libANGLE/renderer/metal/DisplayMtl.h
index c8b8ac3a69962eca7b567814167a86a5e8871a25..f601b886205b02975a9240fa8b8c8a3c23d836ea 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.h
+++ b/src/libANGLE/renderer/metal/DisplayMtl.h
@@ -140,6 +140,7 @@ class DisplayMtl : public DisplayImpl
     bool supportsDepth24Stencil8PixelFormat() const;
     bool supports32BitFloatFiltering() const;
     bool supportsBCTextureCompression() const;
+    bool supportsVariableRasterizationRate() const;
     bool isAMD() const;
     bool isAMDBronzeDriver() const;
     bool isAMDFireProDevice() const;
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index 7b68a30a42b4506c92a22044b73aa819b4cd7a13..ec218d1f058df17f6554a6ded0782b986d671667 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -176,12 +176,22 @@ void DisplayMtl::terminate()
 
 bool DisplayMtl::testDeviceLost()
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    return mCmdQueue.isDeviceLost();
+#else
     return false;
+#endif
 }
 
 egl::Error DisplayMtl::restoreLostDevice(const egl::Display *display)
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    // A Metal device cannot be restored, the entire context would have to be
+    // re-created along with any other EGL objects that reference it.
+    return egl::Error(EGL_BAD_DISPLAY);
+#else
     return egl::NoError();
+#endif
 }
 
 std::string DisplayMtl::getRendererDescription()
@@ -1134,6 +1144,15 @@ void DisplayMtl::initializeExtensions() const
             mNativeCaps.maxImageUnits = gl::IMPLEMENTATION_MAX_PIXEL_LOCAL_STORAGE_PLANES;
         }
     }
+
+    // GL_ANGLE_variable_rasterization_rate_metal
+    mNativeExtensions.variableRasterizationRateMetalANGLE =
+        mFeatures.hasVariableRasterizationRate.enabled;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    mNativeExtensions.explicitResolveTargetWEBKIT = true;
+#endif
+
     // "The GPUs in Apple3 through Apple8 families only support memory barriers for compute command
     // encoders, and for vertex-to-vertex and vertex-to-fragment stages of render command encoders."
     mHasFragmentMemoryBarriers = !supportsAppleGPUFamily(3);
@@ -1205,6 +1224,8 @@ void DisplayMtl::initializeFeatures()
     ANGLE_FEATURE_CONDITION((&mFeatures), hasExplicitMemBarrier, (isOSX || isCatalyst) && !isARM);
     ANGLE_FEATURE_CONDITION((&mFeatures), hasDepthAutoResolve, supportsEitherGPUFamily(3, 2));
     ANGLE_FEATURE_CONDITION((&mFeatures), hasStencilAutoResolve, supportsEitherGPUFamily(5, 2));
+    ANGLE_FEATURE_CONDITION((&mFeatures), hasVariableRasterizationRate,
+                            supportsVariableRasterizationRate());
     ANGLE_FEATURE_CONDITION((&mFeatures), allowMultisampleStoreAndResolve,
                             supportsEitherGPUFamily(3, 1));
 
@@ -1318,9 +1339,15 @@ void DisplayMtl::initializeFeatures()
 
     // Metal compiler optimizations may remove infinite loops causing crashes later in shader
     // execution. http://crbug.com/1513738
-    // Disabled on Mac11 due to test failures. http://crbug.com/1522730
+    ANGLE_FEATURE_CONDITION((&mFeatures), ensureLoopForwardProgress, false);
+
+    // Once not used, injectAsmStatementIntoLoopBodies should be removed and
+    // ensureLoopForwardProgress should default to true. Disabled on Mac11 due to test failures.
+    // http://crbug.com/1522730
+    bool shouldUseInjectAsmIntoLoopBodies = !mFeatures.ensureLoopForwardProgress.enabled &&
+                                            (!isOSX || GetMacOSVersion() >= OSVersion(12, 0, 0));
     ANGLE_FEATURE_CONDITION((&mFeatures), injectAsmStatementIntoLoopBodies,
-                            !isOSX || GetMacOSVersion() >= OSVersion(12, 0, 0));
+                            shouldUseInjectAsmIntoLoopBodies);
 }
 
 angle::Result DisplayMtl::initializeShaderLibrary()
@@ -1395,6 +1422,17 @@ bool DisplayMtl::supportsDepth24Stencil8PixelFormat() const
     return false;
 #endif
 }
+
+bool DisplayMtl::supportsVariableRasterizationRate() const
+{
+    if (@available(ios 13.0, macOS 10.15.4, macCatalyst 13.4, tvOS 16.0, *))
+    {
+        return [mMetalDevice supportsRasterizationRateMapWithLayerCount:1];
+    }
+
+    return false;
+}
+
 bool DisplayMtl::isAMD() const
 {
     return angle::IsAMD(mMetalDeviceVendorId);
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.h b/src/libANGLE/renderer/metal/FrameBufferMtl.h
index 84e5326b7270f29630d2c353a6ebadb5d10b6a21..0afffbbb5ad7f3961d49addf1f74d44bd1312e95 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.h
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.h
@@ -211,6 +211,14 @@ class FramebufferMtl : public FramebufferImpl
     angle::FixedVector<RenderTargetMtl *, mtl::kMaxRenderTargets> mColorRenderTargets;
     RenderTargetMtl *mDepthRenderTarget   = nullptr;
     RenderTargetMtl *mStencilRenderTarget = nullptr;
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    angle::FixedVector<RenderTargetMtl *, mtl::kMaxRenderTargets> mColorResolveRenderTargets;
+    RenderTargetMtl *mDepthResolveRenderTarget   = nullptr;
+    RenderTargetMtl *mStencilResolveRenderTarget = nullptr;
+#endif
+
     mtl::RenderPassDesc mRenderPassDesc;
 
     const mtl::Format *mRenderPassFirstColorAttachmentFormat = nullptr;
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index 32a297309845f4f9779ffc70f6a61f20c4d4d94b..5520cd467ada81fbd794afcdff8c361cd8d766eb 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -128,6 +128,9 @@ angle::Result Copy2DTextureSlice0Level0ToTempTexture(const gl::Context *context,
 FramebufferMtl::FramebufferMtl(const gl::FramebufferState &state, ContextMtl *context, bool flipY)
     : FramebufferImpl(state),
       mColorRenderTargets(context->getNativeCaps().maxColorAttachments, nullptr),
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+      mColorResolveRenderTargets(context->getNativeCaps().maxColorAttachments, nullptr),
+#endif
       mBackbuffer(nullptr),
       mFlipY(flipY)
 {
@@ -144,6 +147,14 @@ void FramebufferMtl::reset()
     }
     mDepthRenderTarget = mStencilRenderTarget = nullptr;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    for (auto &rt : mColorResolveRenderTargets)
+    {
+        rt = nullptr;
+    }
+    mDepthResolveRenderTarget = mStencilResolveRenderTarget = nullptr;
+#endif
+
     mRenderPassFirstColorAttachmentFormat = nullptr;
 
     mReadPixelBuffer = nullptr;
@@ -943,7 +954,7 @@ void FramebufferMtl::setLoadStoreActionOnRenderPassFirstStart(
         attachment.loadAction = MTLLoadActionLoad;
     }
 
-    if (attachment.hasImplicitMSTexture())
+    if (attachment.hasResolveTexture())
     {
         attachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
     }
@@ -1010,22 +1021,47 @@ angle::Result FramebufferMtl::updateColorRenderTarget(const gl::Context *context
     ASSERT(colorIndexGL < mColorRenderTargets.size());
     // Reset load store action
     mRenderPassDesc.colorAttachments[colorIndexGL].reset();
-    return updateCachedRenderTarget(context, mState.getColorAttachment(colorIndexGL),
-                                    &mColorRenderTargets[colorIndexGL]);
+    ANGLE_TRY(updateCachedRenderTarget(context, mState.getColorAttachment(colorIndexGL),
+                                       &mColorRenderTargets[colorIndexGL]));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (mState.getColorResolveAttachment(colorIndexGL))
+    {
+        ANGLE_TRY(updateCachedRenderTarget(context, mState.getColorResolveAttachment(colorIndexGL),
+                                           &mColorResolveRenderTargets[colorIndexGL]));
+    }
+#endif
+    return angle::Result::Continue;
 }
 
 angle::Result FramebufferMtl::updateDepthRenderTarget(const gl::Context *context)
 {
     // Reset load store action
     mRenderPassDesc.depthAttachment.reset();
-    return updateCachedRenderTarget(context, mState.getDepthAttachment(), &mDepthRenderTarget);
+    ANGLE_TRY(updateCachedRenderTarget(context, mState.getDepthAttachment(), &mDepthRenderTarget));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (mState.getDepthResolveAttachment())
+    {
+        ANGLE_TRY(updateCachedRenderTarget(context, mState.getDepthResolveAttachment(),
+                                           &mDepthResolveRenderTarget));
+    }
+#endif
+    return angle::Result::Continue;
 }
 
 angle::Result FramebufferMtl::updateStencilRenderTarget(const gl::Context *context)
 {
     // Reset load store action
     mRenderPassDesc.stencilAttachment.reset();
-    return updateCachedRenderTarget(context, mState.getStencilAttachment(), &mStencilRenderTarget);
+    ANGLE_TRY(
+        updateCachedRenderTarget(context, mState.getStencilAttachment(), &mStencilRenderTarget));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (mState.getStencilResolveAttachment())
+    {
+        ANGLE_TRY(updateCachedRenderTarget(context, mState.getStencilResolveAttachment(),
+                                           &mStencilResolveRenderTarget));
+    }
+#endif
+    return angle::Result::Continue;
 }
 
 angle::Result FramebufferMtl::updateCachedRenderTarget(const gl::Context *context,
@@ -1067,6 +1103,9 @@ angle::Result FramebufferMtl::prepareRenderPass(const gl::Context *context,
 
         mtl::RenderPassColorAttachmentDesc &colorAttachment = desc.colorAttachments[colorIndexGL];
         const RenderTargetMtl *colorRenderTarget            = mColorRenderTargets[colorIndexGL];
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        const RenderTargetMtl *colorResolveRenderTarget = mColorResolveRenderTargets[colorIndexGL];
+#endif
 
         // GL allows data types of fragment shader color outputs to be incompatible with disabled
         // color attachments. To prevent various Metal validation issues, assign textures only to
@@ -1074,6 +1113,12 @@ angle::Result FramebufferMtl::prepareRenderPass(const gl::Context *context,
         if (colorRenderTarget && enabledDrawBuffers.test(colorIndexGL))
         {
             colorRenderTarget->toRenderPassAttachmentDesc(&colorAttachment);
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+            if (colorResolveRenderTarget)
+            {
+                colorResolveRenderTarget->toRenderPassResolveAttachmentDesc(&colorAttachment);
+            }
+#endif
 
             desc.numColorAttachments = std::max(desc.numColorAttachments, colorIndexGL + 1);
             desc.rasterSampleCount =
@@ -1103,6 +1148,12 @@ angle::Result FramebufferMtl::prepareRenderPass(const gl::Context *context,
     if (mDepthRenderTarget)
     {
         mDepthRenderTarget->toRenderPassAttachmentDesc(&desc.depthAttachment);
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        if (mDepthResolveRenderTarget)
+        {
+            mDepthResolveRenderTarget->toRenderPassResolveAttachmentDesc(&desc.depthAttachment);
+        }
+#endif
         desc.rasterSampleCount =
             std::max(desc.rasterSampleCount, mDepthRenderTarget->getRenderSamples());
     }
@@ -1114,6 +1165,12 @@ angle::Result FramebufferMtl::prepareRenderPass(const gl::Context *context,
     if (mStencilRenderTarget)
     {
         mStencilRenderTarget->toRenderPassAttachmentDesc(&desc.stencilAttachment);
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        if (mStencilResolveRenderTarget)
+        {
+            mStencilResolveRenderTarget->toRenderPassResolveAttachmentDesc(&desc.stencilAttachment);
+        }
+#endif
         desc.rasterSampleCount =
             std::max(desc.rasterSampleCount, mStencilRenderTarget->getRenderSamples());
     }
@@ -1188,7 +1245,7 @@ angle::Result FramebufferMtl::clearWithLoadOpRenderPassNotStarted(
             colorAttachment.loadAction = MTLLoadActionLoad;
         }
 
-        if (colorAttachment.hasImplicitMSTexture())
+        if (colorAttachment.hasResolveTexture())
         {
             colorAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
         }
@@ -1208,7 +1265,7 @@ angle::Result FramebufferMtl::clearWithLoadOpRenderPassNotStarted(
         tempDesc.depthAttachment.loadAction = MTLLoadActionLoad;
     }
 
-    if (tempDesc.depthAttachment.hasImplicitMSTexture())
+    if (tempDesc.depthAttachment.hasResolveTexture())
     {
         tempDesc.depthAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
     }
@@ -1227,7 +1284,7 @@ angle::Result FramebufferMtl::clearWithLoadOpRenderPassNotStarted(
         tempDesc.stencilAttachment.loadAction = MTLLoadActionLoad;
     }
 
-    if (tempDesc.stencilAttachment.hasImplicitMSTexture())
+    if (tempDesc.stencilAttachment.hasResolveTexture())
     {
         tempDesc.stencilAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
     }
@@ -1465,31 +1522,54 @@ angle::Result FramebufferMtl::invalidateImpl(const gl::Context *context,
                 }
             }
 
-            mtl::RenderPassColorAttachmentDesc &colorAttachment =
-                mRenderPassDesc.colorAttachments[i];
+            // If the invalidated color buffer has an associated resolve target
+            // then resolve the MSAA samples, otherwise discard the data.
+            auto &colorAttachment = mRenderPassDesc.colorAttachments[i];
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+            auto *resolveRenderTarget = mColorResolveRenderTargets[i];
+            colorAttachment.storeAction =
+                resolveRenderTarget ? MTLStoreActionMultisampleResolve : MTLStoreActionDontCare;
+#else
             colorAttachment.storeAction = MTLStoreActionDontCare;
+#endif
             if (renderPassStarted)
             {
-                encoder->setColorStoreAction(MTLStoreActionDontCare, i);
+                encoder->setColorStoreAction(colorAttachment.storeAction, i);
             }
         }
     }
 
     if (invalidateDepthBuffer && mDepthRenderTarget)
     {
-        mRenderPassDesc.depthAttachment.storeAction = MTLStoreActionDontCare;
+        // If the invalidated depth buffer has an associated resolve target then
+        // resolve the MSAA samples, otherwise discard the data.
+        auto &depthAttachment = mRenderPassDesc.depthAttachment;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        depthAttachment.storeAction =
+            mDepthResolveRenderTarget ? MTLStoreActionMultisampleResolve : MTLStoreActionDontCare;
+#else
+        depthAttachment.storeAction = MTLStoreActionDontCare;
+#endif
         if (renderPassStarted)
         {
-            encoder->setDepthStoreAction(MTLStoreActionDontCare);
+            encoder->setDepthStoreAction(depthAttachment.storeAction);
         }
     }
 
     if (invalidateStencilBuffer && mStencilRenderTarget)
     {
-        mRenderPassDesc.stencilAttachment.storeAction = MTLStoreActionDontCare;
+        // If the invalidated stencil buffer has an associated resolve target
+        // then resolve the MSAA samples, otherwise discard the data.
+        auto &stencilAttachment = mRenderPassDesc.stencilAttachment;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        stencilAttachment.storeAction =
+            mStencilResolveRenderTarget ? MTLStoreActionMultisampleResolve : MTLStoreActionDontCare;
+#else
+        stencilAttachment.storeAction = MTLStoreActionDontCare;
+#endif
         if (renderPassStarted)
         {
-            encoder->setStencilStoreAction(MTLStoreActionDontCare);
+            encoder->setStencilStoreAction(stencilAttachment.storeAction);
         }
     }
 
@@ -1675,7 +1755,8 @@ angle::Result FramebufferMtl::readPixelsToPBO(const gl::Context *context,
     ContextMtl *contextMtl = mtl::GetImpl(context);
 
     ANGLE_CHECK_GL_MATH(contextMtl,
-                        packPixelsParams.offset <= std::numeric_limits<uint32_t>::max());
+                        static_cast<std::make_unsigned_t<decltype(packPixelsParams.offset)>>(
+                            packPixelsParams.offset) <= std::numeric_limits<uint32_t>::max());
     uint32_t offset = static_cast<uint32_t>(packPixelsParams.offset);
 
     BufferMtl *packBufferMtl = mtl::GetImpl(packPixelsParams.packBuffer);
@@ -1823,9 +1904,8 @@ angle::Result FramebufferMtl::unresolveIfNeeded(const gl::Context *context,
         const mtl::RenderPassColorAttachmentDesc &colorAttachment =
             renderPassDesc.colorAttachments[colorIndexGL];
 
-        if (colorAttachment.loadAction != MTLLoadActionLoad ||
-            !colorAttachment.hasImplicitMSTexture() ||
-            !colorAttachment.implicitMSTexture->shouldNotLoadStore())
+        if (colorAttachment.loadAction != MTLLoadActionLoad || !colorAttachment.texture ||
+            !colorAttachment.texture->shouldNotLoadStore())
         {
             continue;
         }
@@ -1833,9 +1913,9 @@ angle::Result FramebufferMtl::unresolveIfNeeded(const gl::Context *context,
         const angle::Format &angleFormat = colorRenderTarget->getFormat().actualAngleFormat();
 
         // Blit the resolve texture to the MS texture.
-        colorBlitParams.src      = colorAttachment.texture;
-        colorBlitParams.srcLevel = colorAttachment.level;
-        colorBlitParams.srcLayer = colorAttachment.sliceOrDepth;
+        colorBlitParams.src      = colorAttachment.resolveTexture;
+        colorBlitParams.srcLevel = colorAttachment.resolveLevel;
+        colorBlitParams.srcLayer = colorAttachment.resolveSliceOrDepth;
 
         colorBlitParams.enabledBuffers.reset();
         colorBlitParams.enabledBuffers.set(colorIndexGL);
@@ -1850,19 +1930,18 @@ angle::Result FramebufferMtl::unresolveIfNeeded(const gl::Context *context,
     mtl::DepthStencilBlitParams dsBlitParams;
     dsBlitParams.BlitParams::operator=(baseParams);
     const mtl::RenderPassDepthAttachmentDesc &depthAttachment = renderPassDesc.depthAttachment;
-    if (depthAttachment.loadAction == MTLLoadActionLoad && depthAttachment.hasImplicitMSTexture() &&
-        depthAttachment.implicitMSTexture->shouldNotLoadStore())
+    if (depthAttachment.loadAction == MTLLoadActionLoad && depthAttachment.texture &&
+        depthAttachment.texture->shouldNotLoadStore())
     {
-        dsBlitParams.src      = depthAttachment.texture;
-        dsBlitParams.srcLevel = depthAttachment.level;
-        dsBlitParams.srcLayer = depthAttachment.sliceOrDepth;
+        dsBlitParams.src      = depthAttachment.resolveTexture;
+        dsBlitParams.srcLevel = depthAttachment.resolveLevel;
+        dsBlitParams.srcLayer = depthAttachment.resolveSliceOrDepth;
     }
 
     const mtl::RenderPassStencilAttachmentDesc &stencilAttachment =
         renderPassDesc.stencilAttachment;
-    if (stencilAttachment.loadAction == MTLLoadActionLoad &&
-        stencilAttachment.hasImplicitMSTexture() &&
-        stencilAttachment.implicitMSTexture->shouldNotLoadStore())
+    if (stencilAttachment.loadAction == MTLLoadActionLoad && stencilAttachment.texture &&
+        stencilAttachment.texture->shouldNotLoadStore())
     {
         if (mState.hasSeparateDepthAndStencilAttachments())
         {
@@ -1872,9 +1951,9 @@ angle::Result FramebufferMtl::unresolveIfNeeded(const gl::Context *context,
             dsBlitParams.src = nullptr;
         }
 
-        dsBlitParams.srcStencil = stencilAttachment.texture->getStencilView();
-        dsBlitParams.srcLevel   = stencilAttachment.level;
-        dsBlitParams.srcLayer   = stencilAttachment.sliceOrDepth;
+        dsBlitParams.srcStencil = stencilAttachment.resolveTexture->getStencilView();
+        dsBlitParams.srcLevel   = stencilAttachment.resolveLevel;
+        dsBlitParams.srcLayer   = stencilAttachment.resolveSliceOrDepth;
     }
 
     if (dsBlitParams.src || dsBlitParams.srcStencil)
diff --git a/src/libANGLE/renderer/metal/ImageMtl.mm b/src/libANGLE/renderer/metal/ImageMtl.mm
index 29f8f59906801cf6218a1517f9b749ce0b1e1d3e..fe46dfb83c88da315557aba10b607eac21b94ce3 100644
--- a/src/libANGLE/renderer/metal/ImageMtl.mm
+++ b/src/libANGLE/renderer/metal/ImageMtl.mm
@@ -86,7 +86,9 @@ egl::Error TextureImageSiblingMtl::ValidateClientBuffer(const DisplayMtl *displa
         return egl::Error(EGL_BAD_ATTRIBUTE, "Unrecognized format");
     }
 
-    if (format.metalFormat != texture.pixelFormat)
+    angle::FormatID srcAngleFormatId = mtl::Format::MetalToAngleFormatID(texture.pixelFormat);
+    const mtl::Format &srcFormat     = display->getPixelFormat(srcAngleFormatId);
+    if (!format.isViewCompatible(srcFormat))
     {
         return egl::Error(EGL_BAD_ATTRIBUTE, "Incompatible format");
     }
@@ -123,18 +125,19 @@ angle::Result TextureImageSiblingMtl::initImpl(DisplayMtl *displayMtl)
 {
     mNativeTexture = mtl::Texture::MakeFromMetal((__bridge id<MTLTexture>)(mBuffer));
 
-    if (mNativeTexture->textureType() == MTLTextureType2DArray)
+    angle::FormatID angleFormatId = intendedFormatForMTLTexture(mNativeTexture->get(), mAttribs);
+    mFormat                       = displayMtl->getPixelFormat(angleFormatId);
+
+    if (mNativeTexture->textureType() == MTLTextureType2DArray ||
+        mNativeTexture->pixelFormat() != mFormat.metalFormat)
     {
         mtl::TextureRef baseTexture = std::move(mNativeTexture);
         unsigned textureArraySlice =
             static_cast<unsigned>(mAttribs.getAsInt(EGL_METAL_TEXTURE_ARRAY_SLICE_ANGLE, 0));
-        mNativeTexture =
-            baseTexture->createSliceMipView(textureArraySlice, mtl::kZeroNativeMipLevel);
+        mNativeTexture = baseTexture->createSliceMipViewWithCompatibleFormat(
+            textureArraySlice, mtl::kZeroNativeMipLevel, mFormat.metalFormat);
     }
 
-    angle::FormatID angleFormatId = intendedFormatForMTLTexture(mNativeTexture->get(), mAttribs);
-    mFormat                       = displayMtl->getPixelFormat(angleFormatId);
-
     if (mNativeTexture)
     {
         size_t resourceSize = EstimateTextureSizeInBytes(
diff --git a/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm b/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm
index b574cf199428badfcf884771ed32cebcccb11e30..850c69932fb255e68455978d8b7517a01340b9e5 100644
--- a/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm
+++ b/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm
@@ -878,7 +878,7 @@ angle::Result ProgramExecutableMtl::setupDraw(const gl::Context *glContext,
 {
     ContextMtl *context = mtl::GetImpl(glContext);
 
-    if (pipelineDescChanged)
+    if (pipelineDescChanged || !cmdEncoder->hasPipelineState())
     {
         id<MTLFunction> vertexShader = nil;
         ANGLE_TRY(
diff --git a/src/libANGLE/renderer/metal/RenderTargetMtl.h b/src/libANGLE/renderer/metal/RenderTargetMtl.h
index 281085bbc46eb7d96dabf73b9c75ee0a61125bab..a07218bc78473252b0b2b9e561ec74799959177e 100644
--- a/src/libANGLE/renderer/metal/RenderTargetMtl.h
+++ b/src/libANGLE/renderer/metal/RenderTargetMtl.h
@@ -51,6 +51,9 @@ class RenderTargetMtl final : public FramebufferAttachmentRenderTarget
     const mtl::Format &getFormat() const { return mFormat; }
 
     void toRenderPassAttachmentDesc(mtl::RenderPassAttachmentDesc *rpaDescOut) const;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    void toRenderPassResolveAttachmentDesc(mtl::RenderPassAttachmentDesc *rpaDescOut) const;
+#endif
 
   private:
     mtl::TextureWeakRef mTexture;
diff --git a/src/libANGLE/renderer/metal/RenderTargetMtl.mm b/src/libANGLE/renderer/metal/RenderTargetMtl.mm
index 18e62da867b2916085794ba3b68ee4a3812d3929..6cbf2a58812184edb425d11689bdbce5574917f0 100644
--- a/src/libANGLE/renderer/metal/RenderTargetMtl.mm
+++ b/src/libANGLE/renderer/metal/RenderTargetMtl.mm
@@ -73,10 +73,33 @@ uint32_t RenderTargetMtl::getRenderSamples() const
 
 void RenderTargetMtl::toRenderPassAttachmentDesc(mtl::RenderPassAttachmentDesc *rpaDescOut) const
 {
-    rpaDescOut->texture           = mTexture.lock();
-    rpaDescOut->implicitMSTexture = mImplicitMSTexture.lock();
+    mtl::TextureRef implicitMSTex = getImplicitMSTexture();
+    mtl::TextureRef tex           = getTexture();
+    if (implicitMSTex)
+    {
+        rpaDescOut->texture             = implicitMSTex;
+        rpaDescOut->resolveTexture      = tex;
+        rpaDescOut->resolveLevel        = mLevelIndex;
+        rpaDescOut->resolveSliceOrDepth = mLayerIndex;
+    }
+    else
+    {
+        rpaDescOut->texture      = tex;
         rpaDescOut->level        = mLevelIndex;
         rpaDescOut->sliceOrDepth = mLayerIndex;
+    }
     rpaDescOut->blendable = mFormat.getCaps().blendable;
 }
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void RenderTargetMtl::toRenderPassResolveAttachmentDesc(
+    mtl::RenderPassAttachmentDesc *rpaDescOut) const
+{
+    ASSERT(!getImplicitMSTexture());
+    ASSERT(getRenderSamples() == 1);
+    rpaDescOut->resolveTexture      = getTexture();
+    rpaDescOut->resolveLevel        = mLevelIndex;
+    rpaDescOut->resolveSliceOrDepth = mLayerIndex;
+}
+#endif
 }  // namespace rx
diff --git a/src/libANGLE/renderer/metal/ShaderMtl.mm b/src/libANGLE/renderer/metal/ShaderMtl.mm
index 6a26b6ccb5730cd6ed0c712f6463c96cd253aed0..9e27f7d9549cc01a9938e827735cf78979c949a2 100644
--- a/src/libANGLE/renderer/metal/ShaderMtl.mm
+++ b/src/libANGLE/renderer/metal/ShaderMtl.mm
@@ -114,6 +114,10 @@ std::shared_ptr<ShaderTranslateTask> ShaderMtl::compile(const gl::Context *conte
     {
         options->metal.injectAsmStatementIntoLoopBodies = true;
     }
+    if (displayMtl->getFeatures().ensureLoopForwardProgress.enabled)
+    {
+        options->ensureLoopForwardProgress = true;
+    }
 
     return std::shared_ptr<ShaderTranslateTask>(new ShaderTranslateTaskMtl(mCompiledState));
 }
diff --git a/src/libANGLE/renderer/metal/SurfaceMtl.mm b/src/libANGLE/renderer/metal/SurfaceMtl.mm
index 04bff707a1088897091e646c0c885f892548e639..49e8ea0e6607a96e00f531f0dc0d637a8a4daec5 100644
--- a/src/libANGLE/renderer/metal/SurfaceMtl.mm
+++ b/src/libANGLE/renderer/metal/SurfaceMtl.mm
@@ -694,8 +694,9 @@ angle::Result WindowSurfaceMtl::obtainNextDrawable(const gl::Context *context)
         }
         mColorTextureInitialized = false;
 
-        ANGLE_MTL_LOG("Current metal drawable size=%d,%d", mColorTexture->width(),
-                      mColorTexture->height());
+        ANGLE_MTL_LOG("Current metal drawable size=%d,%d",
+                      mColorTexture->width(mtl::MipmapNativeLevel(0)),
+                      mColorTexture->height(mtl::MipmapNativeLevel(0)));
 
         // Now we have to resize depth stencil buffers if required.
         ANGLE_TRY(ensureCompanionTexturesSizeCorrect(context));
diff --git a/src/libANGLE/renderer/metal/TextureMtl.h b/src/libANGLE/renderer/metal/TextureMtl.h
index 7593d5c591583213ebae9e655ec6ecd82eafa0bc..cc75417723848e9719cfbc4b77400ed3d72b9b9b 100644
--- a/src/libANGLE/renderer/metal/TextureMtl.h
+++ b/src/libANGLE/renderer/metal/TextureMtl.h
@@ -313,7 +313,7 @@ class TextureMtl : public TextureImpl
                                       const uint8_t *pixels,
                                       const mtl::TextureRef &image);
 
-    // Convert pixels to suported format before uploading to texture
+    // Convert pixels to supported format before uploading to texture.
     angle::Result convertAndSetPerSliceSubImage(const gl::Context *context,
                                                 int slice,
                                                 const MTLRegion &mtlArea,
diff --git a/src/libANGLE/renderer/metal/VertexArrayMtl.mm b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
index fefa460e446f7b627ab223e1405fe1b14a2c33b4..75b34c075208aa26c16f1ee5a54a8c04e3d8ee6f 100644
--- a/src/libANGLE/renderer/metal/VertexArrayMtl.mm
+++ b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
@@ -1086,16 +1086,27 @@ angle::Result VertexArrayMtl::convertVertexBufferGPU(const gl::Context *glContex
     ANGLE_TRY(conversion->data.allocate(contextMtl, numVertices * targetStride, nullptr, &newBuffer,
                                         &newBufferOffset));
 
-    ANGLE_CHECK_GL_MATH(contextMtl, binding.getOffset() <= std::numeric_limits<uint32_t>::max());
+    GLintptr bindingOffset = binding.getOffset();
+
+    if constexpr (sizeof(bindingOffset) > sizeof(uint32_t))
+    {
+        ANGLE_CHECK_GL_MATH(contextMtl, static_cast<std::make_unsigned_t<decltype(bindingOffset)>>(
+                                            bindingOffset) <= std::numeric_limits<uint32_t>::max());
+    }
     ANGLE_CHECK_GL_MATH(contextMtl, newBufferOffset <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, numVertices <= std::numeric_limits<uint32_t>::max());
 
     mtl::VertexFormatConvertParams params;
     VertexConversionBufferMtl *vertexConversion =
         static_cast<VertexConversionBufferMtl *>(conversion);
+    if constexpr (sizeof(vertexConversion->offset) > sizeof(uint32_t))
+    {
+        ANGLE_CHECK_GL_MATH(contextMtl,
+                            vertexConversion->offset <= std::numeric_limits<uint32_t>::max());
+    }
     params.srcBuffer            = srcBuffer->getCurrentBuffer();
-    params.srcBufferStartOffset = static_cast<uint32_t>(
-        MIN(static_cast<GLintptr>(vertexConversion->offset), binding.getOffset()));
+    params.srcBufferStartOffset = std::min(static_cast<uint32_t>(vertexConversion->offset),
+                                           static_cast<uint32_t>(bindingOffset));
     params.srcStride            = binding.getStride();
     params.srcDefaultAlphaData  = convertedFormat.defaultAlpha;
 
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.h b/src/libANGLE/renderer/metal/mtl_command_buffer.h
index 4251aade23897ef52d1bf340885684d28c9d6bac..74db2bf24c298136fde9b303608784709244a863 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.h
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.h
@@ -118,6 +118,8 @@ class CommandQueue final : public WrappedObject<id<MTLCommandQueue>>, angle::Non
     double getTimeElapsedEntryInSeconds(uint64_t id);
     MTLCommandBufferError popCmdBufferError() { return mCmdBufferError.pop(); }
 
+    bool isDeviceLost() const { return mIsDeviceLost; }
+
   private:
     void onCommandBufferCompleted(id<MTLCommandBuffer> buf,
                                   uint64_t serial,
@@ -162,6 +164,8 @@ class CommandQueue final : public WrappedObject<id<MTLCommandQueue>>, angle::Non
     void recordCommandBufferTimeElapsed(std::lock_guard<std::mutex> &lg,
                                         uint64_t id,
                                         double seconds);
+
+    std::atomic_bool mIsDeviceLost = false;
 };
 
 class CommandBuffer final : public WrappedObject<id<MTLCommandBuffer>>, angle::NonCopyable
@@ -436,8 +440,9 @@ class RenderCommandEncoder final : public CommandEncoder
     RenderCommandEncoder &setStencilRefVals(uint32_t frontRef, uint32_t backRef);
     RenderCommandEncoder &setStencilRefVal(uint32_t ref);
 
-    RenderCommandEncoder &setViewport(const MTLViewport &viewport);
-    RenderCommandEncoder &setScissorRect(const MTLScissorRect &rect);
+    RenderCommandEncoder &setViewport(const MTLViewport &viewport, id<MTLRasterizationRateMap> map);
+    RenderCommandEncoder &setScissorRect(const MTLScissorRect &rect,
+                                         id<MTLRasterizationRateMap> map);
 
     RenderCommandEncoder &setBlendColor(float r, float g, float b, float a);
 
@@ -586,6 +591,8 @@ class RenderCommandEncoder final : public CommandEncoder
     RenderCommandEncoder &setDepthLoadAction(MTLLoadAction action, double clearValue);
     RenderCommandEncoder &setStencilLoadAction(MTLLoadAction action, uint32_t clearValue);
 
+    RenderCommandEncoder &setRasterizationRateMap(id<MTLRasterizationRateMap> map);
+
     void setLabel(NSString *label);
 
     void pushDebugGroup(NSString *label) override;
@@ -593,8 +600,11 @@ class RenderCommandEncoder final : public CommandEncoder
 
     const RenderPassDesc &renderPassDesc() const { return mRenderPassDesc; }
     bool hasDrawCalls() const { return mHasDrawCalls; }
+    bool hasPipelineState() const { return mPipelineStateSet; }
 
     uint64_t getSerial() const { return mSerial; }
+    id<MTLRasterizationRateMap> rasterizationRateMapForPass(id<MTLRasterizationRateMap> map,
+                                                            id<MTLTexture> colorTexture) const;
 
   private:
     // Override CommandEncoder
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.mm b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
index 6855e93cfbdcc227790bd7126c73ca7afe104bb4..d817642838d8726335ea79592abce5a7e80fbda7 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.mm
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
@@ -647,6 +647,18 @@ void CommandQueue::onCommandBufferCompleted(id<MTLCommandBuffer> buf,
               << error.localizedDescription.UTF8String;
         mCmdBufferError.store(static_cast<MTLCommandBufferError>(error.code));
     }
+    MTLCommandBufferStatus status = buf.status;
+    if (status != MTLCommandBufferStatusCompleted)
+    {
+        // MTLCommandBufferErrorNotPermitted is non-fatal, all other errors
+        // result in device lost.
+        // TODO(djg): Should this also check error.domain for MTLCommandBufferErrorDomain?
+        mIsDeviceLost = !error || error.code != MTLCommandBufferErrorNotPermitted;
+        if (mIsDeviceLost)
+        {
+            return;
+        }
+    }
 
     if (timeElapsedEntry != 0)
     {
@@ -1361,6 +1373,7 @@ void RenderCommandEncoder::reset()
     CommandEncoder::reset();
     mRecording        = false;
     mPipelineStateSet = false;
+    setRasterizationRateMap(nil);
     mCommands.clear();
 }
 
@@ -1396,7 +1409,7 @@ bool RenderCommandEncoder::finalizeLoadStoreAction(
     }
 
     // Check if we need to disable MTLLoadActionLoad & MTLStoreActionStore
-    mtl::TextureRef mainTextureRef = cppRenderPassAttachment.getImplicitMSTextureIfAvailOrTexture();
+    mtl::TextureRef mainTextureRef = cppRenderPassAttachment.texture;
     ASSERT(mainTextureRef->get() == objCRenderPassAttachment.texture);
     if (mainTextureRef->shouldNotLoadStore())
     {
@@ -1540,13 +1553,13 @@ void RenderCommandEncoder::endEncodingImpl(bool considerDiscardSimulation)
 inline void RenderCommandEncoder::initAttachmentWriteDependencyAndScissorRect(
     const RenderPassAttachmentDesc &attachment)
 {
-    TextureRef texture = attachment.texture;
+    auto texture = attachment.hasResolveTexture() ? attachment.resolveTexture : attachment.texture;
+    auto &mipLevel = attachment.hasResolveTexture() ? attachment.resolveLevel : attachment.level;
+
     if (texture)
     {
         cmdBuffer().setWriteDependency(texture, /*isRenderCommand=*/true);
 
-        const MipmapNativeLevel &mipLevel = attachment.level;
-
         mRenderPassMaxScissorRect.width =
             std::min<NSUInteger>(mRenderPassMaxScissorRect.width, texture->width(mipLevel));
         mRenderPassMaxScissorRect.height =
@@ -1824,7 +1837,8 @@ RenderCommandEncoder &RenderCommandEncoder::setStencilRefVal(uint32_t ref)
     return setStencilRefVals(ref, ref);
 }
 
-RenderCommandEncoder &RenderCommandEncoder::setViewport(const MTLViewport &viewport)
+RenderCommandEncoder &RenderCommandEncoder::setViewport(const MTLViewport &viewport,
+                                                        id<MTLRasterizationRateMap> map)
 {
     if (mStateCache.viewport.valid() && mStateCache.viewport.value() == viewport)
     {
@@ -1837,12 +1851,25 @@ RenderCommandEncoder &RenderCommandEncoder::setViewport(const MTLViewport &viewp
     return *this;
 }
 
-RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect &rect)
+RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect &rect,
+                                                           id<MTLRasterizationRateMap> map)
 {
+    auto maxScissorRect =
+        MTLCoordinate2DMake(mRenderPassMaxScissorRect.width, mRenderPassMaxScissorRect.height);
+
+    if (map)
+    {
+        maxScissorRect = [map mapPhysicalToScreenCoordinates:maxScissorRect forLayer:0];
+        if (!(rect.width * rect.height))
+        {
+            return *this;
+        }
+    }
+
     NSUInteger clampedWidth =
-        rect.x > mRenderPassMaxScissorRect.width ? 0 : mRenderPassMaxScissorRect.width - rect.x;
+        rect.x > maxScissorRect.x ? 0 : (NSUInteger)ceilf(maxScissorRect.x) - rect.x;
     NSUInteger clampedHeight =
-        rect.y > mRenderPassMaxScissorRect.height ? 0 : mRenderPassMaxScissorRect.height - rect.y;
+        rect.y > maxScissorRect.y ? 0 : (NSUInteger)ceilf(maxScissorRect.y) - rect.y;
 
     MTLScissorRect clampedRect = {rect.x, rect.y, std::min(rect.width, clampedWidth),
                                   std::min(rect.height, clampedHeight)};
@@ -1854,6 +1881,23 @@ RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect
 
     mStateCache.scissorRect = clampedRect;
 
+    if (map)
+    {
+        auto adjustedOrigin =
+            [map mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(clampedRect.x, clampedRect.y)
+                                       forLayer:0];
+        auto adjustedSize =
+            [map mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(clampedRect.width,
+                                                                    clampedRect.height)
+                                       forLayer:0];
+
+        clampedRect.x      = (NSUInteger)roundf(adjustedOrigin.x);
+        clampedRect.y      = (NSUInteger)roundf(adjustedOrigin.y);
+        MTLSize screenSize = [map screenSize];
+        clampedRect.width  = std::min(screenSize.width, static_cast<NSUInteger>(roundf(adjustedSize.x)));
+        clampedRect.height = std::min(screenSize.height, static_cast<NSUInteger>(roundf(adjustedSize.y)));
+    }
+
     mCommands.push(CmdType::SetScissorRect).push(clampedRect);
 
     return *this;
@@ -2259,6 +2303,20 @@ void RenderCommandEncoder::popDebugGroup()
     mCommands.push(CmdType::PopDebugGroup);
 }
 
+id<MTLRasterizationRateMap> RenderCommandEncoder::rasterizationRateMapForPass(
+    id<MTLRasterizationRateMap> map,
+    id<MTLTexture> texture) const
+{
+    if (!mCachedRenderPassDescObjC.get())
+    {
+        return nil;
+    }
+
+    MTLSize size     = [map physicalSizeForLayer:0];
+    id<MTLTexture> t = mCachedRenderPassDescObjC.get().colorAttachments[0].texture;
+    return t.width == size.width && t.height == size.height ? map : nil;
+}
+
 RenderCommandEncoder &RenderCommandEncoder::setColorStoreAction(MTLStoreAction action,
                                                                 uint32_t colorAttachmentIndex)
 {
@@ -2354,6 +2412,16 @@ RenderCommandEncoder &RenderCommandEncoder::setStencilLoadAction(MTLLoadAction a
     return *this;
 }
 
+RenderCommandEncoder &RenderCommandEncoder::setRasterizationRateMap(id<MTLRasterizationRateMap> map)
+{
+    if (map != mCachedRenderPassDescObjC.get().rasterizationRateMap)
+    {
+        mCachedRenderPassDescObjC.get().rasterizationRateMap = map;
+    }
+
+    return *this;
+}
+
 void RenderCommandEncoder::setLabel(NSString *label)
 {
     mLabel = std::move(label);
diff --git a/src/libANGLE/renderer/metal/mtl_format_utils.h b/src/libANGLE/renderer/metal/mtl_format_utils.h
index db95298598177500cebd0eb81cfcb845656031b2..8cbd1014b7dd9c2886272df3ae0923ccec49b512 100644
--- a/src/libANGLE/renderer/metal/mtl_format_utils.h
+++ b/src/libANGLE/renderer/metal/mtl_format_utils.h
@@ -89,6 +89,10 @@ struct Format : public FormatBase
     // Need conversion between source format and this format?
     bool needConversion(angle::FormatID srcFormatId) const;
 
+    // Are the formats view compatible without requiring
+    // MTLTextureUsagePixelFormatView?
+    bool isViewCompatible(const Format &srcFormat) const;
+
     MTLPixelFormat metalFormat = MTLPixelFormatInvalid;
 
     LoadFunctionMap textureLoadFunctions       = nullptr;
diff --git a/src/libANGLE/renderer/metal/mtl_format_utils.mm b/src/libANGLE/renderer/metal/mtl_format_utils.mm
index b6fb44c79e2ed92c908b5b8997695d2253bbe2a2..4bc6932440e9493ae436f5b17c01400125c49bb7 100644
--- a/src/libANGLE/renderer/metal/mtl_format_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_format_utils.mm
@@ -161,6 +161,34 @@ bool Format::needConversion(angle::FormatID srcFormatId) const
     return srcFormatId != actualFormatId;
 }
 
+bool Format::isViewCompatible(const Format &srcFormat) const
+{
+    if (srcFormat.metalFormat == metalFormat)
+    {
+        return true;
+    }
+
+    // The pixel layout is considered different if the number of components differs,
+    if (srcFormat.caps.channels != caps.channels)
+    {
+        return false;
+    }
+
+    // ... or if their size or order is different from the components in the original pixel format.
+    if (srcFormat.caps.pixelBytes != caps.pixelBytes)
+    {
+        return false;
+    }
+
+    // This is overly conservative but reject compressed formats
+    if (srcFormat.caps.compressed || caps.compressed)
+    {
+        return false;
+    }
+
+    return true;
+}
+
 bool Format::isPVRTC() const
 {
     switch (metalFormat)
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index 6244308ff4cbce9567cc562c2fc78a56489577f2..6e40285bc32617781439d9e4de993a17bff6b665 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -556,7 +556,8 @@ void DispatchCompute(ContextMtl *contextMtl,
                      id<MTLComputePipelineState> pipelineState,
                      size_t numThreads)
 {
-    NSUInteger w = std::min<NSUInteger>(pipelineState.threadExecutionWidth, numThreads);
+    ASSERT(numThreads != 0);
+    NSUInteger w = std::clamp<NSUInteger>(numThreads, 1u, pipelineState.threadExecutionWidth);
     MTLSize threadsPerThreadgroup = MTLSizeMake(w, 1, 1);
 
     if (contextMtl->getDisplay()->getFeatures().hasNonUniformDispatch.enabled)
@@ -636,8 +637,9 @@ void SetupCommonBlitWithDrawStates(const gl::Context *context,
         GetViewport(params.dstRect, params.dstTextureSize.height, params.dstFlipY);
     MTLScissorRect scissorRectMtl =
         GetScissorRect(params.dstScissorRect, params.dstTextureSize.height, params.dstFlipY);
-    cmdEncoder->setViewport(viewportMtl);
-    cmdEncoder->setScissorRect(scissorRectMtl);
+
+    cmdEncoder->setViewport(viewportMtl, nil);
+    cmdEncoder->setScissorRect(scissorRectMtl, nil);
 
     if (params.src)
     {
@@ -1114,8 +1116,8 @@ angle::Result ClearUtils::setupClearWithDraw(const gl::Context *context,
 
     scissorRect = GetScissorRect(params.clearArea, params.dstTextureSize.height, params.flipY);
 
-    cmdEncoder->setViewport(viewport);
-    cmdEncoder->setScissorRect(scissorRect);
+    cmdEncoder->setViewport(viewport, nil);
+    cmdEncoder->setScissorRect(scissorRect, nil);
 
     // uniform
     ClearParamsUniform uniformParams;
@@ -2482,8 +2484,8 @@ angle::Result CopyPixelsUtils::unpackPixelsWithDraw(const gl::Context *context,
 
     scissorRect = GetScissorRect(rect);
 
-    cmdEncoder->setViewport(viewport);
-    cmdEncoder->setScissorRect(scissorRect);
+    cmdEncoder->setViewport(viewport, nil);
+    cmdEncoder->setScissorRect(scissorRect, nil);
 
     // uniform
     CopyPixelFromBufferUniforms options;
diff --git a/src/libANGLE/renderer/metal/mtl_resource_spi.h b/src/libANGLE/renderer/metal/mtl_resource_spi.h
index 3eaa9a64e79af26faa786102ece3f0bdea84d090..7ecb6db9d993df8985fcb6f701dfe7ca75857cae 100644
--- a/src/libANGLE/renderer/metal/mtl_resource_spi.h
+++ b/src/libANGLE/renderer/metal/mtl_resource_spi.h
@@ -1,9 +1,63 @@
-//
-// Copyright 2021 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (C) 2021 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 //
 // mtl_resource_spi.h:
-//    Used to set Metal resource ownership identity with SPI.
-//    Purposefully empty header file. Actual implementation will be hosted in WebKit.
+//    Used to set Metal resource ownership identity with SPI
 //
+
+#ifndef LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+#define LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+
+#import "common/apple/apple_platform.h"
+
+#if ANGLE_USE_METAL_OWNERSHIP_IDENTITY
+
+#    import <Metal/MTLResource_Private.h>
+#    import <Metal/Metal.h>
+#    import <mach/mach_types.h>
+
+namespace rx
+{
+namespace mtl
+{
+inline void setOwnerWithIdentity(id<MTLResource> resource, task_id_token_t identityToken)
+{
+    if (identityToken != TASK_ID_TOKEN_NULL)
+    {
+        kern_return_t kr = [(id<MTLResourceSPI>)resource setOwnerWithIdentity:identityToken];
+        if (ANGLE_UNLIKELY(kr != KERN_SUCCESS))
+        {
+            ERR() << "setOwnerWithIdentity failed with: %s (%x)" << mach_error_string(kr) << kr;
+            ASSERT(false);
+        }
+    }
+    return;
+}
+}  // namespace mtl
+}  // namespace rx
+#endif
+
+#endif /* LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_ */
diff --git a/src/libANGLE/renderer/metal/mtl_resources.h b/src/libANGLE/renderer/metal/mtl_resources.h
index f622b484570562e6eebf6507ed83b20770be42d8..1e8ce4bb456dbfcb48c3728465ea864d466058ff 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.h
+++ b/src/libANGLE/renderer/metal/mtl_resources.h
@@ -228,6 +228,11 @@ class Texture final : public Resource,
     TextureRef createCubeFaceView(uint32_t face);
     // Create a view of one slice at a level.
     TextureRef createSliceMipView(uint32_t slice, const MipmapNativeLevel &level);
+    // Same as createSliceMipView but the target format must be compatible, for example sRGB to
+    // linear. In this case texture doesn't need format view usage flag.
+    TextureRef createSliceMipViewWithCompatibleFormat(uint32_t slice,
+                                                      const MipmapNativeLevel &level,
+                                                      MTLPixelFormat format);
     // Create a levels range view
     TextureRef createMipsView(const MipmapNativeLevel &baseLevel, uint32_t levels);
     // Create a view of a level.
diff --git a/src/libANGLE/renderer/metal/mtl_resources.mm b/src/libANGLE/renderer/metal/mtl_resources.mm
index 1b97e18840d543d15cdbbeb42db18cb0a06973ec..3befac795680563d14f7ec1b925c9694812cf368 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.mm
+++ b/src/libANGLE/renderer/metal/mtl_resources.mm
@@ -78,12 +78,10 @@ MTLResourceOptions resourceOptionsForStorageMode(MTLStorageMode storageMode)
             return MTLResourceStorageModePrivate;
         case MTLStorageModeMemoryless:
             return MTLResourceStorageModeMemoryless;
-#if TARGET_OS_SIMULATOR
         default:
             // TODO(http://anglebug.com/42266474): Remove me once hacked SDKs are fixed.
             UNREACHABLE();
             return MTLResourceStorageModeShared;
-#endif
     }
 }
 
@@ -705,7 +703,9 @@ TextureRef Texture::createCubeFaceView(uint32_t face)
     }
 }
 
-TextureRef Texture::createSliceMipView(uint32_t slice, const MipmapNativeLevel &level)
+TextureRef Texture::createSliceMipViewWithCompatibleFormat(uint32_t slice,
+                                                           const MipmapNativeLevel &level,
+                                                           MTLPixelFormat format)
 {
     ANGLE_MTL_OBJC_SCOPE
     {
@@ -714,7 +714,7 @@ TextureRef Texture::createSliceMipView(uint32_t slice, const MipmapNativeLevel &
             case MTLTextureTypeCube:
             case MTLTextureType2D:
             case MTLTextureType2DArray:
-                return TextureRef(new Texture(this, pixelFormat(), MTLTextureType2D,
+                return TextureRef(new Texture(this, format, MTLTextureType2D,
                                               NSMakeRange(level.get(), 1), NSMakeRange(slice, 1)));
             default:
                 UNREACHABLE();
@@ -723,6 +723,11 @@ TextureRef Texture::createSliceMipView(uint32_t slice, const MipmapNativeLevel &
     }
 }
 
+TextureRef Texture::createSliceMipView(uint32_t slice, const MipmapNativeLevel &level)
+{
+    return createSliceMipViewWithCompatibleFormat(slice, level, pixelFormat());
+}
+
 TextureRef Texture::createMipView(const MipmapNativeLevel &level)
 {
     ANGLE_MTL_OBJC_SCOPE
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.h b/src/libANGLE/renderer/metal/mtl_state_cache.h
index 6a4300940aaa92f4a5ad0d35111adb30c75b1712..ed13c3068c01d21b9603c1f603d80e13f655539c 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.h
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.h
@@ -305,20 +305,21 @@ struct RenderPassAttachmentDesc
     bool equalIgnoreLoadStoreOptions(const RenderPassAttachmentDesc &other) const;
     bool operator==(const RenderPassAttachmentDesc &other) const;
 
-    ANGLE_INLINE bool hasImplicitMSTexture() const { return implicitMSTexture.get(); }
-
-    const TextureRef &getImplicitMSTextureIfAvailOrTexture() const
-    {
-        return hasImplicitMSTexture() ? implicitMSTexture : texture;
-    }
+    ANGLE_INLINE bool hasResolveTexture() const { return resolveTexture.get(); }
 
+    // When rendering with implicit multisample, |texture| is the texture that
+    // will be rendered into and discarded at the end of a render pass. Its
+    // result will be automatically resolved into |resolveTexture|.
     TextureRef texture;
     // Implicit multisample texture that will be rendered into and discarded at the end of
     // a render pass. Its result will be resolved into normal texture above.
-    TextureRef implicitMSTexture;
+    TextureRef resolveTexture;
     MipmapNativeLevel level;
     uint32_t sliceOrDepth;
 
+    MipmapNativeLevel resolveLevel;
+    uint32_t resolveSliceOrDepth;
+
     // This attachment is blendable or not.
     bool blendable;
     MTLLoadAction loadAction;
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.mm b/src/libANGLE/renderer/metal/mtl_state_cache.mm
index 4d89a6cdafe03400e215513882874faf00a248d4..c8bb7ceaafe9608c100c977f5ca4ea2cdc7b69a5 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.mm
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.mm
@@ -141,44 +141,29 @@ id<MTLTexture> ToObjC(const TextureRef &texture)
 void BaseRenderPassAttachmentDescToObjC(const RenderPassAttachmentDesc &src,
                                         MTLRenderPassAttachmentDescriptor *dst)
 {
-    const TextureRef &implicitMsTexture = src.implicitMSTexture;
-
-    if (implicitMsTexture)
-    {
-        dst.texture        = ToObjC(implicitMsTexture);
-        dst.level          = 0;
-        dst.slice          = 0;
-        dst.depthPlane     = 0;
-        dst.resolveTexture = ToObjC(src.texture);
-        dst.resolveLevel   = src.level.get();
-        if (dst.resolveTexture.textureType == MTLTextureType3D)
-        {
-            dst.resolveDepthPlane = src.sliceOrDepth;
-            dst.resolveSlice      = 0;
-        }
-        else
-        {
-            dst.resolveSlice      = src.sliceOrDepth;
-            dst.resolveDepthPlane = 0;
-        }
-    }
-    else
-    {
     dst.texture = ToObjC(src.texture);
     dst.level   = src.level.get();
     if (dst.texture.textureType == MTLTextureType3D)
     {
-            dst.depthPlane = src.sliceOrDepth;
         dst.slice      = 0;
+        dst.depthPlane = src.sliceOrDepth;
     }
     else
     {
         dst.slice      = src.sliceOrDepth;
         dst.depthPlane = 0;
     }
-        dst.resolveTexture    = nil;
-        dst.resolveLevel      = 0;
+
+    dst.resolveTexture = ToObjC(src.resolveTexture);
+    dst.resolveLevel   = src.resolveLevel.get();
+    if (dst.resolveTexture.textureType == MTLTextureType3D)
+    {
         dst.resolveSlice      = 0;
+        dst.resolveDepthPlane = src.resolveSliceOrDepth;
+    }
+    else
+    {
+        dst.resolveSlice      = src.resolveSliceOrDepth;
         dst.resolveDepthPlane = 0;
     }
 
@@ -668,9 +653,11 @@ RenderPassAttachmentDesc::RenderPassAttachmentDesc()
 void RenderPassAttachmentDesc::reset()
 {
     texture.reset();
-    implicitMSTexture.reset();
+    resolveTexture.reset();
     level               = mtl::kZeroNativeMipLevel;
     sliceOrDepth        = 0;
+    resolveLevel        = mtl::kZeroNativeMipLevel;
+    resolveSliceOrDepth = 0;
     blendable           = false;
     loadAction          = MTLLoadActionLoad;
     storeAction         = MTLStoreActionStore;
@@ -680,7 +667,7 @@ void RenderPassAttachmentDesc::reset()
 bool RenderPassAttachmentDesc::equalIgnoreLoadStoreOptions(
     const RenderPassAttachmentDesc &other) const
 {
-    return texture == other.texture && implicitMSTexture == other.implicitMSTexture &&
+    return texture == other.texture && resolveTexture == other.resolveTexture &&
            level == other.level && sliceOrDepth == other.sliceOrDepth &&
            blendable == other.blendable;
 }
diff --git a/src/libANGLE/renderer/metal/mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_utils.mm
index 3f449e39447af0b713d43ea210797942365e1ae6..cf5ba3e3895ea2168618fece5bdd546d117193a0 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_utils.mm
@@ -1401,6 +1401,24 @@ bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
     return [device supportsFamily:family];
 }
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) ||        \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0) || \
+    (defined(__TVOS_16_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_16_0)
+#    define ANGLE_MTL_FEATURE_SET_DEPRECATED 1
+#    define ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED 1
+#endif
+
+#if ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac2
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#elif TARGET_OS_MACCATALYST
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMacCatalyst1
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMacCatalyst2
+#else  // !ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED && !TARGET_OS_MACCATALYST
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac1
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#endif
+
 bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
@@ -1446,8 +1464,7 @@ static NSUInteger getNextLocationForAttachment(const mtl::RenderPassAttachmentDe
                                                const Context *context,
                                                NSUInteger currentRenderTargetSize)
 {
-    mtl::TextureRef texture =
-        attachment.implicitMSTexture ? attachment.implicitMSTexture : attachment.texture;
+    mtl::TextureRef texture = attachment.texture;
 
     if (texture)
     {
diff --git a/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
new file mode 100644
index 0000000000000000000000000000000000000000..23e8295bcc16412d3aef3fc8e85748fa4ad77a70
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
@@ -0,0 +1,65 @@
+#!/usr/bin/python3
+# Copyright 2021 The ANGLE Project Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# create_mtl_internal_shaders.py:
+#   Script to compile a metalLib into NSData, for including the compilded
+#       library in the ANGLE dylib.
+
+import os
+import sys
+import json
+from datetime import datetime
+
+sys.path.append('../..')
+
+template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
+// Generated by {script_name}
+//
+// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+"""
+
+
+# Convert content of a file to byte array and store in a header file.
+# variable_name: name of C++ variable that will hold the file content as byte array.
+# filename: the file whose content will be converted to C++ byte array.
+# dest_src_file: destination header file that will contain the byte array.
+def append_file_as_byte_array_string(variable_name, filename, dest_src_file):
+    string = '// Generated from {0}:\n'.format(filename)
+    string += 'constexpr uint8_t {0}[]={{\n'.format(variable_name)
+    bytes_ = open(filename, "rb").read()
+    for byte in bytes_:
+        string += '0x{:02x}'.format(byte) + ", "
+    string += "\n};\n"
+    with open(dest_src_file, "a") as out_file:
+        out_file.write(string)
+
+
+def main():
+    input_file = sys.argv[1]
+    output_file = sys.argv[2]
+    os.chdir(sys.path[0])
+
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=os.path.basename(sys.argv[0]), copyright_year=datetime.today().year)
+
+    # -------- Compile shaders -----------
+    # boiler plate code
+    os.system("echo \"{0}\" > \"{1}\"".format(boilerplate_code, output_file))
+    os.system(
+        'echo "// Compiled binary for Metal default shaders.\n\n" >>  \"{0}\"'.format(output_file))
+    os.system('echo "#include <TargetConditionals.h>\n\n" >>  \"{0}\"'.format(output_file))
+
+    os.system('echo "// clang-format off" >> \"{0}\"'.format(output_file))
+
+    append_file_as_byte_array_string('gDefaultMetallib', input_file, output_file)
+
+    os.system('echo "// clang-format on" >> \"{0}\"'.format(output_file))
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/src/libANGLE/renderer/vulkan/CLProgramVk.cpp b/src/libANGLE/renderer/vulkan/CLProgramVk.cpp
index 76852328172174fdbf6c2e8ae5ccafc826af4c1a..f6cac226cfd969daec4453ad318ad822deb720dc 100644
--- a/src/libANGLE/renderer/vulkan/CLProgramVk.cpp
+++ b/src/libANGLE/renderer/vulkan/CLProgramVk.cpp
@@ -860,6 +860,11 @@ bool CLProgramVk::buildInternal(const cl::DevicePtrs &devices,
         // add clspv compiler options based on device features
         processedOptions += ClspvGetCompilerOptions(&device->getImpl<CLDeviceVk>());
 
+        cl_uint addressBits;
+        ANGLE_CL_IMPL_TRY(
+            device->getInfo(cl::DeviceInfo::AddressBits, sizeof(cl_uint), &addressBits, nullptr));
+        processedOptions += addressBits == 64 ? " -arch=spir64" : " -arch=spir";
+
         if (buildType != BuildType::BINARY)
         {
             // Invoke clspv
diff --git a/src/libANGLE/renderer/vulkan/ContextVk.cpp b/src/libANGLE/renderer/vulkan/ContextVk.cpp
index 1f6538dc06917e6193c7f223ffcf61a99ee6f543..fc87fc51bd9d1755761b1b832d4b11fb238e2cc4 100644
--- a/src/libANGLE/renderer/vulkan/ContextVk.cpp
+++ b/src/libANGLE/renderer/vulkan/ContextVk.cpp
@@ -6041,6 +6041,10 @@ angle::Result ContextVk::syncState(const gl::Context *context,
                             break;
                         case gl::state::EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT:
                             break;
+                        case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                            // Noop until addition of backend support for
+                            // ANGLE_variable_rasterization_rate_metal extension
+                            break;
                         default:
                             UNREACHABLE();
                     }
diff --git a/src/libANGLE/renderer/vulkan/vk_format_utils.cpp b/src/libANGLE/renderer/vulkan/vk_format_utils.cpp
index 01136131aa33732d5c1421e95456d73cc4aaddaa..5a7cd43b2d3bdd1653a25248186b1b3e6d96b38e 100644
--- a/src/libANGLE/renderer/vulkan/vk_format_utils.cpp
+++ b/src/libANGLE/renderer/vulkan/vk_format_utils.cpp
@@ -341,7 +341,7 @@ angle::FormatID ExternalFormatTable::getOrAllocExternalFormatID(uint64_t externa
 
     if (mExternalYuvFormats.size() >= kMaxExternalFormatCountSupported)
     {
-        ERR() << "ANGLE only suports maximum " << kMaxExternalFormatCountSupported
+        ERR() << "ANGLE only supports maximum " << kMaxExternalFormatCountSupported
               << " external renderable formats";
         return angle::FormatID::NONE;
     }
diff --git a/src/libANGLE/validationEGL.cpp b/src/libANGLE/validationEGL.cpp
index d1bc7fcd98951fe1e23a43440776665534bf6c6d..1cf4bedb4e60e4ac9f4e5bfaf7424d9e7cfd904d 100644
--- a/src/libANGLE/validationEGL.cpp
+++ b/src/libANGLE/validationEGL.cpp
@@ -3459,11 +3459,11 @@ bool ValidateCreatePixmapSurface(const ValidationContext *val,
 
     if (!(config->surfaceType & EGL_PIXMAP_BIT))
     {
-        val->setError(EGL_BAD_MATCH, "Congfig does not suport pixmaps.");
+        val->setError(EGL_BAD_MATCH, "Config does not support pixmaps.");
         return false;
     }
 
-    ANGLE_EGL_TRY_RETURN(val->eglThread, display->valdiatePixmap(config, pixmap, attributes),
+    ANGLE_EGL_TRY_RETURN(val->eglThread, display->validatePixmap(config, pixmap, attributes),
                          val->entryPoint, val->labeledObject, false);
 
     return true;
diff --git a/src/libANGLE/validationES2.cpp b/src/libANGLE/validationES2.cpp
index 95adc0c69f656056fed4e13f9778965d13611a8c..8ec9467abfd1b24d676fddad4ea0c6d8fa938321 100644
--- a/src/libANGLE/validationES2.cpp
+++ b/src/libANGLE/validationES2.cpp
@@ -700,6 +700,9 @@ bool ValidCapUncommon(const PrivateState &state, ErrorSet *errors, GLenum cap, b
         case GL_BLEND_ADVANCED_COHERENT_KHR:
             return state.getExtensions().blendEquationAdvancedCoherentKHR;
 
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            return state.getExtensions().variableRasterizationRateMetalANGLE;
+
         default:
             break;
     }
@@ -5882,6 +5885,19 @@ bool ValidateMaxShaderCompilerThreadsKHR(const Context *context,
     return true;
 }
 
+bool ValidateBindMetalRasterizationRateMapANGLE(const Context *context,
+                                                angle::EntryPoint entryPoint,
+                                                GLuint framebuffer,
+                                                GLMTLRasterizationRateMapANGLE map)
+{
+    if (!context->getExtensions().variableRasterizationRateMetalANGLE)
+    {
+        ANGLE_VALIDATION_ERROR(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+    return true;
+}
+
 bool ValidateMultiDrawArraysANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
                                   PrimitiveMode mode,
diff --git a/src/libANGLE/validationES32.cpp b/src/libANGLE/validationES32.cpp
index 63d4b9d2e2f231bc9f545924b5f03756e37cab23..48f98e8a1d049a83b7e18f39e6cc331b9a868bf4 100644
--- a/src/libANGLE/validationES32.cpp
+++ b/src/libANGLE/validationES32.cpp
@@ -431,12 +431,13 @@ bool ValidateGetPointerv(const Context *context,
                 return false;
             }
             break;
-
+        // GL_ANGLE_variable_rasterization_rate_metal
+        case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+            return context->getExtensions().variableRasterizationRateMetalANGLE;
         default:
             ANGLE_VALIDATION_ERROR(GL_INVALID_ENUM, kInvalidPointerQuery);
             return false;
     }
-
     return true;
 }
 
diff --git a/src/libANGLE/validationESEXT.cpp b/src/libANGLE/validationESEXT.cpp
index 5f93b62a1c61885582a65bbaefef581e58624aa7..7d8900f5a4abea5bbd875fa0bec3fe5a35c5e237 100644
--- a/src/libANGLE/validationESEXT.cpp
+++ b/src/libANGLE/validationESEXT.cpp
@@ -3792,6 +3792,29 @@ bool ValidateLogicOpANGLE(const PrivateState &state,
     return ValidateLogicOpCommon(state, errors, entryPoint, opcodePacked);
 }
 
+// GL_WEBKIT_explicit_resolve_target
+bool ValidateFramebufferResolveRenderbufferWEBKIT(const Context *context,
+                                                  angle::EntryPoint entryPoint,
+                                                  GLenum target,
+                                                  GLenum attachment,
+                                                  GLenum renderbuffertarget,
+                                                  RenderbufferID renderbuffer)
+{
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (!context->getExtensions().explicitResolveTargetWEBKIT)
+    {
+        ANGLE_VALIDATION_ERROR(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return ValidateFramebufferRenderbufferBase(context, entryPoint, target, attachment,
+                                               renderbuffertarget, renderbuffer);
+#else
+    UNIMPLEMENTED();
+    return false;
+#endif
+}
+
 bool ValidateFramebufferFoveationConfigQCOM(const Context *context,
                                             angle::EntryPoint entryPoint,
                                             FramebufferID framebufferPacked,
diff --git a/src/libANGLE/validationESEXT_autogen.h b/src/libANGLE/validationESEXT_autogen.h
index 70f4404b6b8950d438668d76ebbf622f927f7685..a4c5abf33d3610e6687f0ead07d50b13a57ec4bc 100644
--- a/src/libANGLE/validationESEXT_autogen.h
+++ b/src/libANGLE/validationESEXT_autogen.h
@@ -1006,6 +1006,12 @@ bool ValidateGetTranslatedShaderSourceANGLE(const Context *context,
                                             const GLsizei *length,
                                             const GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+bool ValidateBindMetalRasterizationRateMapANGLE(const Context *context,
+                                                angle::EntryPoint entryPoint,
+                                                GLuint framebuffer,
+                                                GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 bool ValidateAcquireTexturesANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
@@ -2935,6 +2941,14 @@ bool ValidateStartTilingQCOM(const Context *context,
                              GLuint width,
                              GLuint height,
                              GLbitfield preserveMask);
+
+// GL_WEBKIT_explicit_resolve_target
+bool ValidateFramebufferResolveRenderbufferWEBKIT(const Context *context,
+                                                  angle::EntryPoint entryPoint,
+                                                  GLenum target,
+                                                  GLenum attachment,
+                                                  GLenum renderbuffertarget,
+                                                  RenderbufferID renderbufferPacked);
 }  // namespace gl
 
 #endif  // LIBANGLE_VALIDATION_ESEXT_AUTOGEN_H_
diff --git a/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp b/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp
index 677bc570df8ed398d72fdc08eabe8e5a6e2fd726..4958ca7dce4b183e6cdcef4ee44e8a8ca9ecc5b5 100644
--- a/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp
+++ b/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp
@@ -181,6 +181,7 @@ const ProcEntry g_procTable[] = {
     {"glBindFramebuffer", P(GL_BindFramebuffer)},
     {"glBindFramebufferOES", P(GL_BindFramebufferOES)},
     {"glBindImageTexture", P(GL_BindImageTexture)},
+    {"glBindMetalRasterizationRateMapANGLE", P(GL_BindMetalRasterizationRateMapANGLE)},
     {"glBindProgramPipeline", P(GL_BindProgramPipeline)},
     {"glBindProgramPipelineEXT", P(GL_BindProgramPipelineEXT)},
     {"glBindRenderbuffer", P(GL_BindRenderbuffer)},
@@ -395,6 +396,7 @@ const ProcEntry g_procTable[] = {
     {"glFramebufferPixelLocalStorageRestoreANGLE", P(GL_FramebufferPixelLocalStorageRestoreANGLE)},
     {"glFramebufferRenderbuffer", P(GL_FramebufferRenderbuffer)},
     {"glFramebufferRenderbufferOES", P(GL_FramebufferRenderbufferOES)},
+    {"glFramebufferResolveRenderbufferWEBKIT", P(GL_FramebufferResolveRenderbufferWEBKIT)},
     {"glFramebufferTexture", P(GL_FramebufferTexture)},
     {"glFramebufferTexture2D", P(GL_FramebufferTexture2D)},
     {"glFramebufferTexture2DMultisampleEXT", P(GL_FramebufferTexture2DMultisampleEXT)},
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.cpp b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
index a0b514980dfcc027b3c2142c3b7190c8e91dd013..9f7901e69f8d7779f492dc895fc3040a928176a3 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.cpp
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
@@ -6828,6 +6828,55 @@ void GL_APIENTRY GL_GetTranslatedShaderSourceANGLE(GLuint shader,
     ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
 }
 
+// GL_ANGLE_variable_rasterization_rate_metal
+void GL_APIENTRY GL_BindMetalRasterizationRateMapANGLE(GLuint framebuffer,
+                                                       GLMTLRasterizationRateMapANGLE map)
+{
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+    Context *context = GetValidGlobalContext();
+    EVENT(context, GLBindMetalRasterizationRateMapANGLE,
+          "context = %d, framebuffer = %u, map = 0x%016" PRIxPTR "", CID(context), framebuffer,
+          (uintptr_t)map);
+
+    if (ANGLE_LIKELY(context != nullptr))
+    {
+        SCOPED_SHARE_CONTEXT_LOCK(context);
+        bool isCallValid = context->skipValidation();
+        if (!isCallValid)
+        {
+            if (ANGLE_LIKELY(context->getExtensions().variableRasterizationRateMetalANGLE))
+            {
+#if defined(ANGLE_ENABLE_ASSERTS)
+                const uint32_t errorCount = context->getPushedErrorCount();
+#endif
+                isCallValid = ValidateBindMetalRasterizationRateMapANGLE(
+                    context, angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE, framebuffer,
+                    map);
+#if defined(ANGLE_ENABLE_ASSERTS)
+                ASSERT(context->getPushedErrorCount() - errorCount == (isCallValid ? 0 : 1));
+#endif
+            }
+            else
+            {
+                RecordVersionErrorESEXT(context,
+                                        angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE);
+            }
+        }
+        if (ANGLE_LIKELY(isCallValid))
+        {
+            context->bindMetalRasterizationRateMap(framebuffer, map);
+        }
+        ANGLE_CAPTURE_GL(BindMetalRasterizationRateMapANGLE, isCallValid, context, framebuffer,
+                         map);
+    }
+    else
+    {
+        GenerateContextLostErrorOnCurrentGlobalContext(
+            angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE);
+    }
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+}
+
 // GL_ANGLE_vulkan_image
 void GL_APIENTRY GL_AcquireTexturesANGLE(GLuint numTextures,
                                          const GLuint *textures,
@@ -20229,4 +20278,59 @@ GL_StartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield p
     ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
 }
 
+// GL_WEBKIT_explicit_resolve_target
+void GL_APIENTRY GL_FramebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                         GLenum attachment,
+                                                         GLenum renderbuffertarget,
+                                                         GLuint renderbuffer)
+{
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+    Context *context = GetValidGlobalContext();
+    EVENT(context, GLFramebufferResolveRenderbufferWEBKIT,
+          "context = %d, target = %s, attachment = %s, renderbuffertarget = %s, renderbuffer = %u",
+          CID(context), GLenumToString(GLESEnum::AllEnums, target),
+          GLenumToString(GLESEnum::AllEnums, attachment),
+          GLenumToString(GLESEnum::AllEnums, renderbuffertarget), renderbuffer);
+
+    if (ANGLE_LIKELY(context != nullptr))
+    {
+        RenderbufferID renderbufferPacked = PackParam<RenderbufferID>(renderbuffer);
+        SCOPED_SHARE_CONTEXT_LOCK(context);
+        bool isCallValid = context->skipValidation();
+        if (!isCallValid)
+        {
+            if (ANGLE_LIKELY(context->getExtensions().explicitResolveTargetWEBKIT))
+            {
+#if defined(ANGLE_ENABLE_ASSERTS)
+                const uint32_t errorCount = context->getPushedErrorCount();
+#endif
+                isCallValid = ValidateFramebufferResolveRenderbufferWEBKIT(
+                    context, angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT, target,
+                    attachment, renderbuffertarget, renderbufferPacked);
+#if defined(ANGLE_ENABLE_ASSERTS)
+                ASSERT(context->getPushedErrorCount() - errorCount == (isCallValid ? 0 : 1));
+#endif
+            }
+            else
+            {
+                RecordVersionErrorESEXT(context,
+                                        angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT);
+            }
+        }
+        if (ANGLE_LIKELY(isCallValid))
+        {
+            context->framebufferResolveRenderbufferWEBKIT(target, attachment, renderbuffertarget,
+                                                          renderbufferPacked);
+        }
+        ANGLE_CAPTURE_GL(FramebufferResolveRenderbufferWEBKIT, isCallValid, context, target,
+                         attachment, renderbuffertarget, renderbufferPacked);
+    }
+    else
+    {
+        GenerateContextLostErrorOnCurrentGlobalContext(
+            angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT);
+    }
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+}
+
 }  // extern "C"
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.h b/src/libGLESv2/entry_points_gles_ext_autogen.h
index 95cfccfa72a43cc554b91b9decd4e21c90760231..cab858f9f2e8789bf32022c34126e08b418f7921 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.h
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.h
@@ -744,6 +744,10 @@ ANGLE_EXPORT void GL_APIENTRY GL_GetTranslatedShaderSourceANGLE(GLuint shader,
                                                                 GLsizei *length,
                                                                 GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+ANGLE_EXPORT void GL_APIENTRY
+GL_BindMetalRasterizationRateMapANGLE(GLuint framebuffer, GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 ANGLE_EXPORT void GL_APIENTRY GL_AcquireTexturesANGLE(GLuint numTextures,
                                                       const GLuint *textures,
@@ -1976,6 +1980,12 @@ ANGLE_EXPORT void GL_APIENTRY GL_TextureFoveationParametersQCOM(GLuint texture,
 ANGLE_EXPORT void GL_APIENTRY GL_EndTilingQCOM(GLbitfield preserveMask);
 ANGLE_EXPORT void GL_APIENTRY
 GL_StartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
+
+// GL_WEBKIT_explicit_resolve_target
+ANGLE_EXPORT void GL_APIENTRY GL_FramebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                                      GLenum attachment,
+                                                                      GLenum renderbuffertarget,
+                                                                      GLuint renderbuffer);
 }  // extern "C"
 
 #endif  // LIBGLESV2_ENTRY_POINTS_GLES_EXT_AUTOGEN_H_
diff --git a/src/libGLESv2/libGLESv2_autogen.cpp b/src/libGLESv2/libGLESv2_autogen.cpp
index b3286a8bbe7f6be3d88396a4cd100e6a36f8d6cd..fc7877d5371c66dc260ee5018306c5bc04e3ed72 100644
--- a/src/libGLESv2/libGLESv2_autogen.cpp
+++ b/src/libGLESv2/libGLESv2_autogen.cpp
@@ -3949,6 +3949,13 @@ void GL_APIENTRY glGetTranslatedShaderSourceANGLE(GLuint shader,
     return GL_GetTranslatedShaderSourceANGLE(shader, bufSize, length, source);
 }
 
+// GL_ANGLE_variable_rasterization_rate_metal
+void GL_APIENTRY glBindMetalRasterizationRateMapANGLE(GLuint framebuffer,
+                                                      GLMTLRasterizationRateMapANGLE map)
+{
+    return GL_BindMetalRasterizationRateMapANGLE(framebuffer, map);
+}
+
 // GL_ANGLE_vulkan_image
 void GL_APIENTRY glAcquireTexturesANGLE(GLuint numTextures,
                                         const GLuint *textures,
@@ -6118,4 +6125,14 @@ glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield pr
     return GL_StartTilingQCOM(x, y, width, height, preserveMask);
 }
 
+// GL_WEBKIT_explicit_resolve_target
+void GL_APIENTRY glFramebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                        GLenum attachment,
+                                                        GLenum renderbuffertarget,
+                                                        GLuint renderbuffer)
+{
+    return GL_FramebufferResolveRenderbufferWEBKIT(target, attachment, renderbuffertarget,
+                                                   renderbuffer);
+}
+
 }  // extern "C"
diff --git a/src/libGLESv2/libGLESv2_autogen.def b/src/libGLESv2/libGLESv2_autogen.def
index 19bb2b4efe5ebc5ceadce83b56ae9b778ce7b973..22518f23ede2f05559c06b6e56d1e9dd2d6c7d48 100644
--- a/src/libGLESv2/libGLESv2_autogen.def
+++ b/src/libGLESv2/libGLESv2_autogen.def
@@ -672,6 +672,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1295,6 +1298,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/libGLESv2_no_capture_autogen.def b/src/libGLESv2/libGLESv2_no_capture_autogen.def
index dc28412bf28d91ee0ed302527cda671de055139c..d074effc9351cdecb22ccfeb6283600a9b903c7a 100644
--- a/src/libGLESv2/libGLESv2_no_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_no_capture_autogen.def
@@ -672,6 +672,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1295,6 +1298,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
index 3462169a4b9a534dd8594decbe80c3896b70feb2..94d37d1df4b754aeed4b73496dc9fbe8e315faa0 100644
--- a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
+++ b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
@@ -672,6 +672,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1295,6 +1298,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/libGLESv2_with_capture_autogen.def b/src/libGLESv2/libGLESv2_with_capture_autogen.def
index b6505af708c3f7d326eeabb13d5f8eaf4539a457..d00a116c72ceb3058f671b208bf166d7fc80bd85 100644
--- a/src/libGLESv2/libGLESv2_with_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_with_capture_autogen.def
@@ -672,6 +672,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1295,6 +1298,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/tests/angle_end2end_tests.gni b/src/tests/angle_end2end_tests.gni
index a886245fb8459dc9374ceb119ab7626fb127d26b..61921da4926c5e57768ab0ead5580d41d032affe 100644
--- a/src/tests/angle_end2end_tests.gni
+++ b/src/tests/angle_end2end_tests.gni
@@ -167,6 +167,7 @@ angle_end2end_tests_sources = [
   "gl_tests/TextureTest.cpp",
   "gl_tests/TextureUploadFormatTest.cpp",
   "gl_tests/TiledRenderingTest.cpp",
+  "gl_tests/TimeoutDrawTest.cpp",
   "gl_tests/TimerQueriesTest.cpp",
   "gl_tests/TransformFeedbackTest.cpp",
   "gl_tests/UniformBufferTest.cpp",
diff --git a/src/tests/angle_unittest_main.cpp b/src/tests/angle_unittest_main.cpp
index 1356dceac33eb8ff7056822826701b0269b522a2..8c217637b79e486faf1ffb0958de61196e2839f6 100644
--- a/src/tests/angle_unittest_main.cpp
+++ b/src/tests/angle_unittest_main.cpp
@@ -6,7 +6,9 @@
 
 #include "GLSLANG/ShaderLang.h"
 #include "gtest/gtest.h"
-#include "test_utils/runner/TestSuite.h"
+#if defined(ANGLE_HAS_RAPIDJSON)
+#    include "test_utils/runner/TestSuite.h"
+#endif
 
 class CompilerTestEnvironment : public testing::Environment
 {
@@ -40,8 +42,13 @@ int main(int argc, char **argv)
             gVerbose = true;
         }
     }
-
+#if defined(ANGLE_HAS_RAPIDJSON)
     angle::TestSuite testSuite(&argc, argv);
     testing::AddGlobalTestEnvironment(new CompilerTestEnvironment());
     return testSuite.run();
+#else
+    testing::AddGlobalTestEnvironment(new CompilerTestEnvironment());
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+#endif  // defined(ANGLE_HAS_RAPIDJSON)
 }
diff --git a/src/tests/angle_unittests.gni b/src/tests/angle_unittests.gni
index 127882302e89bffcae7cf48ef50551fed48bdae4..c607b91859c5f05380efde7ff818a774e86b5a3a 100644
--- a/src/tests/angle_unittests.gni
+++ b/src/tests/angle_unittests.gni
@@ -175,6 +175,7 @@ angle_unittests_gl_sources =
 
 angle_unittests_msl_sources = [
   "../common/apple/ObjCPtr_test.mm",
+  "../tests/compiler_tests/EnsureLoopForwardProgress_test.cpp",
   "../tests/compiler_tests/MSLOutput_test.cpp",
 ]
 
diff --git a/src/tests/compiler_tests/EnsureLoopForwardProgress_test.cpp b/src/tests/compiler_tests/EnsureLoopForwardProgress_test.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..398bef2325bbf39b5c031c1f5fcf4eaa2f27688a
--- /dev/null
+++ b/src/tests/compiler_tests/EnsureLoopForwardProgress_test.cpp
@@ -0,0 +1,166 @@
+//
+// Copyright 2025 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// EnsureLoopForwardProgress_test.cpp:
+//   Tests that loops make forward progress.
+//
+
+#include "GLSLANG/ShaderLang.h"
+#include "angle_gl.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "tests/test_utils/compiler_test.h"
+
+namespace
+{
+using namespace sh;
+using namespace testing;
+
+class EnsureLoopForwardProgressTest : public MatchOutputCodeTest
+{
+  public:
+    EnsureLoopForwardProgressTest() : MatchOutputCodeTest(GL_FRAGMENT_SHADER, SH_ESSL_OUTPUT)
+    {
+        ShCompileOptions defaultCompileOptions          = {};
+        defaultCompileOptions.ensureLoopForwardProgress = true;
+        defaultCompileOptions.validateAST               = true;
+        setDefaultCompileOptions(defaultCompileOptions);
+    }
+};
+
+TEST_F(EnsureLoopForwardProgressTest, FiniteForInitLessThanConstantPlusPlus)
+{
+    const char kShader[]   = R"(#version 300 es
+void main() {
+        for (highp int i = 0; i < 100; ++i) { }
+})";
+    const char kExpected[] = R"(#version 300 es
+void main(){
+  for (highp int _ui = 0; (_ui < 100); (++_ui))
+  {
+  }
+}
+)";
+    compile(kShader);
+    EXPECT_EQ(kExpected, outputCode(SH_ESSL_OUTPUT));
+}
+
+TEST_F(EnsureLoopForwardProgressTest, InfiniteForExample)
+{
+    const char kShader[]   = R"(#version 300 es
+void main() {
+  for (highp int i = 0; i < 100; i++) { i = 0; }
+})";
+    const char kExpected[] = R"(#version 300 es
+void main(){
+  for (highp int _ui = 0; (_ui < 100); (_ui++))
+  {
+    loopForwardProgress();
+    {
+      (_ui = 0);
+    }
+  }
+}
+)";
+    compile(kShader);
+    EXPECT_EQ(kExpected, outputCode(SH_ESSL_OUTPUT));
+}
+
+TEST_F(EnsureLoopForwardProgressTest, InfiniteNestedForExample)
+{
+    const char kShader[]   = R"(#version 300 es
+void main() {
+  for (highp int i = 0; i < 100; i++) { for (highp int j = 0; j < 100; j++) { j = 0; } i = 0; }
+})";
+    const char kExpected[] = R"(#version 300 es
+void main(){
+  for (highp int _ui = 0; (_ui < 100); (_ui++))
+  {
+    loopForwardProgress();
+    {
+      for (highp int _uj = 0; (_uj < 100); (_uj++))
+      {
+        loopForwardProgress();
+        {
+          (_uj = 0);
+        }
+      }
+      (_ui = 0);
+    }
+  }
+}
+)";
+    compile(kShader);
+    EXPECT_EQ(kExpected, outputCode(SH_ESSL_OUTPUT));
+}
+
+TEST_F(EnsureLoopForwardProgressTest, FiniteFors)
+{
+    const char kShaderPrefix[] = R"(#version 300 es
+precision highp int;
+uniform int a;
+uniform uint b;
+void main() {
+
+)";
+    const char kShaderSuffix[] = "}\n";
+    const char *tests[]{"int i = 101; for (; i < 10; i++) { }",
+                        "int i = 101; for (; i < 10; i+=1) { }",
+                        "int i = 101; for (; i < 10; i-=1) { }",
+                        "for (int i = 0; i < 10; i++) { }",
+                        "for (int i = 0; i < a; i++) { }",
+                        "for (int i = 0; i < 100000/2; ++i) { }",
+                        "for (uint i = 0u; i < 10u; i++) { }",
+                        "for (uint i = 0u; i < b; i++) { }",
+                        "for (uint i = 0u; i < 100000u/2u; ++i) { }",
+                        "for (uint i = 0u; i < 4294967295u; ++i) { }",
+                        "for (uint i = 10u; i > 1u+3u ; --i) { }",
+                        "const int z = 7; for (int i = 0; i < z; i++) { }",
+                        "for (int i = 0; i < 10; i++) { for (int j = 0; j < 1000; ++j) { }}"};
+    for (auto &test : tests)
+    {
+        std::string shader = (std::stringstream() << kShaderPrefix << test << kShaderSuffix).str();
+        compile(shader.c_str());
+        std::string output = outputCode(SH_ESSL_OUTPUT);
+        EXPECT_THAT(output, HasSubstr("void main(){"));
+        EXPECT_THAT(output, Not(HasSubstr("loopForwardProgress();")))
+            << "input: " << test << "output: " << output;
+    }
+}
+
+TEST_F(EnsureLoopForwardProgressTest, InfiniteFors)
+{
+    const char kShaderPrefix[] = R"(#version 300 es
+precision highp int;
+uniform int a;
+uniform uint b;
+void main() {
+
+)";
+    const char kShaderSuffix[] = "}\n";
+    const char *tests[]{"for (;;) { }",
+                        "for (bool b = true; b; b = false) { }",
+                        "for (int i = 0; i < 10;) { }",
+                        "int i = 101; for (; i < 10; i+=2) { }",
+                        "int i = 101; for (; i < 10; i-=2) { }",
+                        "int z = 7; for (int i = 0; i < z; i++) { }",
+                        "for (int i = 0; i < 10; i++) { i++; }",
+                        "for (int i = 0; i < 10;) { i++; }",
+                        "for (int i = 0; i < a/2; i++) { }",
+                        "for (int i = 0; float(i) < 10e10; ++i) { }",
+                        "for (int i = 0; i < 10; i++) { for (int j = 0; j < 1000; ++i) { }}",
+                        "for (int i = 0; i != 1; i+=2) { }"};
+    for (auto &test : tests)
+    {
+        std::string shader = (std::stringstream() << kShaderPrefix << test << kShaderSuffix).str();
+        compile(shader.c_str());
+        std::string output = outputCode(SH_ESSL_OUTPUT);
+        EXPECT_THAT(output, HasSubstr("void main(){"));
+        EXPECT_THAT(output, HasSubstr("loopForwardProgress();"))
+            << "input: " << test << "output: " << output;
+    }
+}
+
+}  // namespace
\ No newline at end of file
diff --git a/src/tests/compiler_tests/ImmutableString_test_autogen.cpp b/src/tests/compiler_tests/ImmutableString_test_autogen.cpp
index 466d5a045887bc85847230fed86567976763f46b..248ad3b4253cc7e51b4fe139da0a8db6d232b0b5 100644
--- a/src/tests/compiler_tests/ImmutableString_test_autogen.cpp
+++ b/src/tests/compiler_tests/ImmutableString_test_autogen.cpp
@@ -1332,139 +1332,140 @@ TEST(ImmutableStringTest, ScriptGeneratedHashesMatch)
     ASSERT_EQ(0x0000050fu, ImmutableString("interpolateAtCenter(10B").mangledNameHash());
     ASSERT_EQ(0x00000510u, ImmutableString("interpolateAtCenter(20B").mangledNameHash());
     ASSERT_EQ(0x00000511u, ImmutableString("interpolateAtCenter(30B").mangledNameHash());
-    ASSERT_EQ(0x00000512u, ImmutableString("saturate(00B").mangledNameHash());
-    ASSERT_EQ(0x00000513u, ImmutableString("saturate(10B").mangledNameHash());
-    ASSERT_EQ(0x00000514u, ImmutableString("saturate(20B").mangledNameHash());
-    ASSERT_EQ(0x00000515u, ImmutableString("saturate(30B").mangledNameHash());
-    ASSERT_EQ(0x00000516u, ImmutableString("gl_DepthRangeParameters").mangledNameHash());
-    ASSERT_EQ(0x00000517u, ImmutableString("gl_DepthRange").mangledNameHash());
-    ASSERT_EQ(0x00000518u, ImmutableString("gl_NumSamples").mangledNameHash());
-    ASSERT_EQ(0x00000519u, ImmutableString("gl_MaxVertexAttribs").mangledNameHash());
-    ASSERT_EQ(0x0000051au, ImmutableString("gl_MaxVertexUniformVectors").mangledNameHash());
-    ASSERT_EQ(0x0000051bu, ImmutableString("gl_MaxVertexTextureImageUnits").mangledNameHash());
-    ASSERT_EQ(0x0000051cu, ImmutableString("gl_MaxCombinedTextureImageUnits").mangledNameHash());
-    ASSERT_EQ(0x0000051du, ImmutableString("gl_MaxTextureImageUnits").mangledNameHash());
-    ASSERT_EQ(0x0000051eu, ImmutableString("gl_MaxFragmentUniformVectors").mangledNameHash());
-    ASSERT_EQ(0x0000051fu, ImmutableString("gl_MaxVaryingVectors").mangledNameHash());
-    ASSERT_EQ(0x00000520u, ImmutableString("gl_MaxDrawBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000521u, ImmutableString("gl_MaxDualSourceDrawBuffersEXT").mangledNameHash());
-    ASSERT_EQ(0x00000522u, ImmutableString("gl_MaxVertexOutputVectors").mangledNameHash());
-    ASSERT_EQ(0x00000523u, ImmutableString("gl_MaxFragmentInputVectors").mangledNameHash());
-    ASSERT_EQ(0x00000524u, ImmutableString("gl_MinProgramTexelOffset").mangledNameHash());
-    ASSERT_EQ(0x00000525u, ImmutableString("gl_MaxProgramTexelOffset").mangledNameHash());
-    ASSERT_EQ(0x00000526u, ImmutableString("gl_MaxImageUnits").mangledNameHash());
-    ASSERT_EQ(0x00000527u, ImmutableString("gl_MaxVertexImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x00000528u, ImmutableString("gl_MaxFragmentImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x00000529u, ImmutableString("gl_MaxComputeImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x0000052au, ImmutableString("gl_MaxCombinedImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x0000052bu,
+    ASSERT_EQ(0x00000512u, ImmutableString("loopForwardProgress(").mangledNameHash());
+    ASSERT_EQ(0x00000513u, ImmutableString("saturate(00B").mangledNameHash());
+    ASSERT_EQ(0x00000514u, ImmutableString("saturate(10B").mangledNameHash());
+    ASSERT_EQ(0x00000515u, ImmutableString("saturate(20B").mangledNameHash());
+    ASSERT_EQ(0x00000516u, ImmutableString("saturate(30B").mangledNameHash());
+    ASSERT_EQ(0x00000517u, ImmutableString("gl_DepthRangeParameters").mangledNameHash());
+    ASSERT_EQ(0x00000518u, ImmutableString("gl_DepthRange").mangledNameHash());
+    ASSERT_EQ(0x00000519u, ImmutableString("gl_NumSamples").mangledNameHash());
+    ASSERT_EQ(0x0000051au, ImmutableString("gl_MaxVertexAttribs").mangledNameHash());
+    ASSERT_EQ(0x0000051bu, ImmutableString("gl_MaxVertexUniformVectors").mangledNameHash());
+    ASSERT_EQ(0x0000051cu, ImmutableString("gl_MaxVertexTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x0000051du, ImmutableString("gl_MaxCombinedTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x0000051eu, ImmutableString("gl_MaxTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x0000051fu, ImmutableString("gl_MaxFragmentUniformVectors").mangledNameHash());
+    ASSERT_EQ(0x00000520u, ImmutableString("gl_MaxVaryingVectors").mangledNameHash());
+    ASSERT_EQ(0x00000521u, ImmutableString("gl_MaxDrawBuffers").mangledNameHash());
+    ASSERT_EQ(0x00000522u, ImmutableString("gl_MaxDualSourceDrawBuffersEXT").mangledNameHash());
+    ASSERT_EQ(0x00000523u, ImmutableString("gl_MaxVertexOutputVectors").mangledNameHash());
+    ASSERT_EQ(0x00000524u, ImmutableString("gl_MaxFragmentInputVectors").mangledNameHash());
+    ASSERT_EQ(0x00000525u, ImmutableString("gl_MinProgramTexelOffset").mangledNameHash());
+    ASSERT_EQ(0x00000526u, ImmutableString("gl_MaxProgramTexelOffset").mangledNameHash());
+    ASSERT_EQ(0x00000527u, ImmutableString("gl_MaxImageUnits").mangledNameHash());
+    ASSERT_EQ(0x00000528u, ImmutableString("gl_MaxVertexImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x00000529u, ImmutableString("gl_MaxFragmentImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x0000052au, ImmutableString("gl_MaxComputeImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x0000052bu, ImmutableString("gl_MaxCombinedImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x0000052cu,
               ImmutableString("gl_MaxCombinedShaderOutputResources").mangledNameHash());
-    ASSERT_EQ(0x0000052cu, ImmutableString("gl_MaxComputeWorkGroupCount").mangledNameHash());
-    ASSERT_EQ(0x0000052du, ImmutableString("gl_MaxComputeWorkGroupSize").mangledNameHash());
-    ASSERT_EQ(0x0000052eu, ImmutableString("gl_MaxComputeUniformComponents").mangledNameHash());
-    ASSERT_EQ(0x0000052fu, ImmutableString("gl_MaxComputeTextureImageUnits").mangledNameHash());
-    ASSERT_EQ(0x00000530u, ImmutableString("gl_MaxComputeAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x00000531u, ImmutableString("gl_MaxComputeAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000532u, ImmutableString("gl_MaxVertexAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x00000533u, ImmutableString("gl_MaxFragmentAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x00000534u, ImmutableString("gl_MaxCombinedAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x00000535u, ImmutableString("gl_MaxAtomicCounterBindings").mangledNameHash());
-    ASSERT_EQ(0x00000536u, ImmutableString("gl_MaxVertexAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000537u, ImmutableString("gl_MaxFragmentAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000538u, ImmutableString("gl_MaxCombinedAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000539u, ImmutableString("gl_MaxAtomicCounterBufferSize").mangledNameHash());
-    ASSERT_EQ(0x0000053au, ImmutableString("gl_MaxGeometryInputComponents").mangledNameHash());
-    ASSERT_EQ(0x0000053bu, ImmutableString("gl_MaxGeometryOutputComponents").mangledNameHash());
-    ASSERT_EQ(0x0000053cu, ImmutableString("gl_MaxGeometryImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x0000053du, ImmutableString("gl_MaxGeometryTextureImageUnits").mangledNameHash());
-    ASSERT_EQ(0x0000053eu, ImmutableString("gl_MaxGeometryOutputVertices").mangledNameHash());
-    ASSERT_EQ(0x0000053fu,
+    ASSERT_EQ(0x0000052du, ImmutableString("gl_MaxComputeWorkGroupCount").mangledNameHash());
+    ASSERT_EQ(0x0000052eu, ImmutableString("gl_MaxComputeWorkGroupSize").mangledNameHash());
+    ASSERT_EQ(0x0000052fu, ImmutableString("gl_MaxComputeUniformComponents").mangledNameHash());
+    ASSERT_EQ(0x00000530u, ImmutableString("gl_MaxComputeTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x00000531u, ImmutableString("gl_MaxComputeAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x00000532u, ImmutableString("gl_MaxComputeAtomicCounterBuffers").mangledNameHash());
+    ASSERT_EQ(0x00000533u, ImmutableString("gl_MaxVertexAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x00000534u, ImmutableString("gl_MaxFragmentAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x00000535u, ImmutableString("gl_MaxCombinedAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x00000536u, ImmutableString("gl_MaxAtomicCounterBindings").mangledNameHash());
+    ASSERT_EQ(0x00000537u, ImmutableString("gl_MaxVertexAtomicCounterBuffers").mangledNameHash());
+    ASSERT_EQ(0x00000538u, ImmutableString("gl_MaxFragmentAtomicCounterBuffers").mangledNameHash());
+    ASSERT_EQ(0x00000539u, ImmutableString("gl_MaxCombinedAtomicCounterBuffers").mangledNameHash());
+    ASSERT_EQ(0x0000053au, ImmutableString("gl_MaxAtomicCounterBufferSize").mangledNameHash());
+    ASSERT_EQ(0x0000053bu, ImmutableString("gl_MaxGeometryInputComponents").mangledNameHash());
+    ASSERT_EQ(0x0000053cu, ImmutableString("gl_MaxGeometryOutputComponents").mangledNameHash());
+    ASSERT_EQ(0x0000053du, ImmutableString("gl_MaxGeometryImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x0000053eu, ImmutableString("gl_MaxGeometryTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x0000053fu, ImmutableString("gl_MaxGeometryOutputVertices").mangledNameHash());
+    ASSERT_EQ(0x00000540u,
               ImmutableString("gl_MaxGeometryTotalOutputComponents").mangledNameHash());
-    ASSERT_EQ(0x00000540u, ImmutableString("gl_MaxGeometryUniformComponents").mangledNameHash());
-    ASSERT_EQ(0x00000541u, ImmutableString("gl_MaxGeometryAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x00000542u, ImmutableString("gl_MaxGeometryAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000543u, ImmutableString("gl_MaxTessControlInputComponents").mangledNameHash());
-    ASSERT_EQ(0x00000544u, ImmutableString("gl_MaxTessControlOutputComponents").mangledNameHash());
-    ASSERT_EQ(0x00000545u, ImmutableString("gl_MaxTessControlTextureImageUnits").mangledNameHash());
-    ASSERT_EQ(0x00000546u, ImmutableString("gl_MaxTessControlUniformComponents").mangledNameHash());
-    ASSERT_EQ(0x00000547u,
+    ASSERT_EQ(0x00000541u, ImmutableString("gl_MaxGeometryUniformComponents").mangledNameHash());
+    ASSERT_EQ(0x00000542u, ImmutableString("gl_MaxGeometryAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x00000543u, ImmutableString("gl_MaxGeometryAtomicCounterBuffers").mangledNameHash());
+    ASSERT_EQ(0x00000544u, ImmutableString("gl_MaxTessControlInputComponents").mangledNameHash());
+    ASSERT_EQ(0x00000545u, ImmutableString("gl_MaxTessControlOutputComponents").mangledNameHash());
+    ASSERT_EQ(0x00000546u, ImmutableString("gl_MaxTessControlTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x00000547u, ImmutableString("gl_MaxTessControlUniformComponents").mangledNameHash());
+    ASSERT_EQ(0x00000548u,
               ImmutableString("gl_MaxTessControlTotalOutputComponents").mangledNameHash());
-    ASSERT_EQ(0x00000548u, ImmutableString("gl_MaxTessControlImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x00000549u, ImmutableString("gl_MaxTessControlAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x0000054au,
+    ASSERT_EQ(0x00000549u, ImmutableString("gl_MaxTessControlImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x0000054au, ImmutableString("gl_MaxTessControlAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x0000054bu,
               ImmutableString("gl_MaxTessControlAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x0000054bu, ImmutableString("gl_MaxTessPatchComponents").mangledNameHash());
-    ASSERT_EQ(0x0000054cu, ImmutableString("gl_MaxPatchVertices").mangledNameHash());
-    ASSERT_EQ(0x0000054du, ImmutableString("gl_MaxTessGenLevel").mangledNameHash());
-    ASSERT_EQ(0x0000054eu,
-              ImmutableString("gl_MaxTessEvaluationInputComponents").mangledNameHash());
+    ASSERT_EQ(0x0000054cu, ImmutableString("gl_MaxTessPatchComponents").mangledNameHash());
+    ASSERT_EQ(0x0000054du, ImmutableString("gl_MaxPatchVertices").mangledNameHash());
+    ASSERT_EQ(0x0000054eu, ImmutableString("gl_MaxTessGenLevel").mangledNameHash());
     ASSERT_EQ(0x0000054fu,
-              ImmutableString("gl_MaxTessEvaluationOutputComponents").mangledNameHash());
+              ImmutableString("gl_MaxTessEvaluationInputComponents").mangledNameHash());
     ASSERT_EQ(0x00000550u,
-              ImmutableString("gl_MaxTessEvaluationTextureImageUnits").mangledNameHash());
+              ImmutableString("gl_MaxTessEvaluationOutputComponents").mangledNameHash());
     ASSERT_EQ(0x00000551u,
+              ImmutableString("gl_MaxTessEvaluationTextureImageUnits").mangledNameHash());
+    ASSERT_EQ(0x00000552u,
               ImmutableString("gl_MaxTessEvaluationUniformComponents").mangledNameHash());
-    ASSERT_EQ(0x00000552u, ImmutableString("gl_MaxTessEvaluationImageUniforms").mangledNameHash());
-    ASSERT_EQ(0x00000553u, ImmutableString("gl_MaxTessEvaluationAtomicCounters").mangledNameHash());
-    ASSERT_EQ(0x00000554u,
+    ASSERT_EQ(0x00000553u, ImmutableString("gl_MaxTessEvaluationImageUniforms").mangledNameHash());
+    ASSERT_EQ(0x00000554u, ImmutableString("gl_MaxTessEvaluationAtomicCounters").mangledNameHash());
+    ASSERT_EQ(0x00000555u,
               ImmutableString("gl_MaxTessEvaluationAtomicCounterBuffers").mangledNameHash());
-    ASSERT_EQ(0x00000555u, ImmutableString("gl_MaxSamples").mangledNameHash());
-    ASSERT_EQ(0x00000556u, ImmutableString("gl_MaxClipDistances").mangledNameHash());
-    ASSERT_EQ(0x00000557u, ImmutableString("gl_MaxCullDistances").mangledNameHash());
-    ASSERT_EQ(0x00000558u, ImmutableString("gl_MaxCombinedClipAndCullDistances").mangledNameHash());
-    ASSERT_EQ(0x00000559u, ImmutableString("gl_FragCoord").mangledNameHash());
-    ASSERT_EQ(0x0000055au, ImmutableString("gl_FrontFacing").mangledNameHash());
-    ASSERT_EQ(0x0000055bu, ImmutableString("gl_PointCoord").mangledNameHash());
-    ASSERT_EQ(0x0000055cu, ImmutableString("gl_FragColor").mangledNameHash());
-    ASSERT_EQ(0x0000055du, ImmutableString("gl_FragData").mangledNameHash());
-    ASSERT_EQ(0x0000055eu, ImmutableString("gl_FragDepth").mangledNameHash());
-    ASSERT_EQ(0x0000055fu, ImmutableString("gl_HelperInvocation").mangledNameHash());
-    ASSERT_EQ(0x00000560u, ImmutableString("gl_SecondaryFragColorEXT").mangledNameHash());
-    ASSERT_EQ(0x00000561u, ImmutableString("gl_SecondaryFragDataEXT").mangledNameHash());
-    ASSERT_EQ(0x00000562u, ImmutableString("gl_FragDepthEXT").mangledNameHash());
-    ASSERT_EQ(0x00000563u, ImmutableString("gl_LastFragData").mangledNameHash());
-    ASSERT_EQ(0x00000564u, ImmutableString("gl_LastFragColor").mangledNameHash());
-    ASSERT_EQ(0x00000565u, ImmutableString("gl_LastFragColorARM").mangledNameHash());
-    ASSERT_EQ(0x00000566u, ImmutableString("gl_LastFragDepthARM").mangledNameHash());
-    ASSERT_EQ(0x00000567u, ImmutableString("gl_LastFragStencilARM").mangledNameHash());
-    ASSERT_EQ(0x00000568u, ImmutableString("gl_PrimitiveID").mangledNameHash());
-    ASSERT_EQ(0x00000569u, ImmutableString("gl_Layer").mangledNameHash());
-    ASSERT_EQ(0x0000056au, ImmutableString("gl_SampleID").mangledNameHash());
-    ASSERT_EQ(0x0000056bu, ImmutableString("gl_SamplePosition").mangledNameHash());
-    ASSERT_EQ(0x0000056cu, ImmutableString("gl_SampleMaskIn").mangledNameHash());
-    ASSERT_EQ(0x0000056du, ImmutableString("gl_SampleMask").mangledNameHash());
-    ASSERT_EQ(0x0000056eu, ImmutableString("gl_Position").mangledNameHash());
-    ASSERT_EQ(0x0000056fu, ImmutableString("gl_PointSize").mangledNameHash());
-    ASSERT_EQ(0x00000570u, ImmutableString("gl_InstanceID").mangledNameHash());
-    ASSERT_EQ(0x00000571u, ImmutableString("gl_InstanceIndex").mangledNameHash());
-    ASSERT_EQ(0x00000572u, ImmutableString("gl_VertexID").mangledNameHash());
-    ASSERT_EQ(0x00000573u, ImmutableString("gl_VertexIndex").mangledNameHash());
-    ASSERT_EQ(0x00000574u, ImmutableString("gl_DrawID").mangledNameHash());
-    ASSERT_EQ(0x00000575u, ImmutableString("gl_BaseVertex").mangledNameHash());
-    ASSERT_EQ(0x00000576u, ImmutableString("gl_BaseInstance").mangledNameHash());
-    ASSERT_EQ(0x00000577u, ImmutableString("angle_BaseVertex").mangledNameHash());
-    ASSERT_EQ(0x00000578u, ImmutableString("angle_BaseInstance").mangledNameHash());
-    ASSERT_EQ(0x00000579u, ImmutableString("gl_ClipDistance").mangledNameHash());
-    ASSERT_EQ(0x0000057au, ImmutableString("gl_NumWorkGroups").mangledNameHash());
-    ASSERT_EQ(0x0000057bu, ImmutableString("gl_WorkGroupSize").mangledNameHash());
-    ASSERT_EQ(0x0000057cu, ImmutableString("gl_WorkGroupID").mangledNameHash());
-    ASSERT_EQ(0x0000057du, ImmutableString("gl_LocalInvocationID").mangledNameHash());
-    ASSERT_EQ(0x0000057eu, ImmutableString("gl_GlobalInvocationID").mangledNameHash());
-    ASSERT_EQ(0x0000057fu, ImmutableString("gl_LocalInvocationIndex").mangledNameHash());
-    ASSERT_EQ(0x00000580u, ImmutableString("gl_PrimitiveIDIn").mangledNameHash());
-    ASSERT_EQ(0x00000581u, ImmutableString("gl_InvocationID").mangledNameHash());
-    ASSERT_EQ(0x00000582u, ImmutableString("gl_PerVertex").mangledNameHash());
-    ASSERT_EQ(0x00000583u, ImmutableString("gl_in").mangledNameHash());
-    ASSERT_EQ(0x00000584u, ImmutableString("gl_PatchVerticesIn").mangledNameHash());
-    ASSERT_EQ(0x00000585u, ImmutableString("gl_TessLevelOuter").mangledNameHash());
-    ASSERT_EQ(0x00000586u, ImmutableString("gl_TessLevelInner").mangledNameHash());
-    ASSERT_EQ(0x00000587u, ImmutableString("gl_out").mangledNameHash());
-    ASSERT_EQ(0x00000588u, ImmutableString("gl_BoundingBox").mangledNameHash());
-    ASSERT_EQ(0x00000589u, ImmutableString("gl_BoundingBoxEXT").mangledNameHash());
-    ASSERT_EQ(0x0000058au, ImmutableString("gl_BoundingBoxOES").mangledNameHash());
-    ASSERT_EQ(0x0000058bu, ImmutableString("gl_TessCoord").mangledNameHash());
-    ASSERT_EQ(0x0000058cu, ImmutableString("gl_ViewID_OVR").mangledNameHash());
-    ASSERT_EQ(0x0000058du, ImmutableString("gl_CullDistance").mangledNameHash());
+    ASSERT_EQ(0x00000556u, ImmutableString("gl_MaxSamples").mangledNameHash());
+    ASSERT_EQ(0x00000557u, ImmutableString("gl_MaxClipDistances").mangledNameHash());
+    ASSERT_EQ(0x00000558u, ImmutableString("gl_MaxCullDistances").mangledNameHash());
+    ASSERT_EQ(0x00000559u, ImmutableString("gl_MaxCombinedClipAndCullDistances").mangledNameHash());
+    ASSERT_EQ(0x0000055au, ImmutableString("gl_FragCoord").mangledNameHash());
+    ASSERT_EQ(0x0000055bu, ImmutableString("gl_FrontFacing").mangledNameHash());
+    ASSERT_EQ(0x0000055cu, ImmutableString("gl_PointCoord").mangledNameHash());
+    ASSERT_EQ(0x0000055du, ImmutableString("gl_FragColor").mangledNameHash());
+    ASSERT_EQ(0x0000055eu, ImmutableString("gl_FragData").mangledNameHash());
+    ASSERT_EQ(0x0000055fu, ImmutableString("gl_FragDepth").mangledNameHash());
+    ASSERT_EQ(0x00000560u, ImmutableString("gl_HelperInvocation").mangledNameHash());
+    ASSERT_EQ(0x00000561u, ImmutableString("gl_SecondaryFragColorEXT").mangledNameHash());
+    ASSERT_EQ(0x00000562u, ImmutableString("gl_SecondaryFragDataEXT").mangledNameHash());
+    ASSERT_EQ(0x00000563u, ImmutableString("gl_FragDepthEXT").mangledNameHash());
+    ASSERT_EQ(0x00000564u, ImmutableString("gl_LastFragData").mangledNameHash());
+    ASSERT_EQ(0x00000565u, ImmutableString("gl_LastFragColor").mangledNameHash());
+    ASSERT_EQ(0x00000566u, ImmutableString("gl_LastFragColorARM").mangledNameHash());
+    ASSERT_EQ(0x00000567u, ImmutableString("gl_LastFragDepthARM").mangledNameHash());
+    ASSERT_EQ(0x00000568u, ImmutableString("gl_LastFragStencilARM").mangledNameHash());
+    ASSERT_EQ(0x00000569u, ImmutableString("gl_PrimitiveID").mangledNameHash());
+    ASSERT_EQ(0x0000056au, ImmutableString("gl_Layer").mangledNameHash());
+    ASSERT_EQ(0x0000056bu, ImmutableString("gl_SampleID").mangledNameHash());
+    ASSERT_EQ(0x0000056cu, ImmutableString("gl_SamplePosition").mangledNameHash());
+    ASSERT_EQ(0x0000056du, ImmutableString("gl_SampleMaskIn").mangledNameHash());
+    ASSERT_EQ(0x0000056eu, ImmutableString("gl_SampleMask").mangledNameHash());
+    ASSERT_EQ(0x0000056fu, ImmutableString("gl_Position").mangledNameHash());
+    ASSERT_EQ(0x00000570u, ImmutableString("gl_PointSize").mangledNameHash());
+    ASSERT_EQ(0x00000571u, ImmutableString("gl_InstanceID").mangledNameHash());
+    ASSERT_EQ(0x00000572u, ImmutableString("gl_InstanceIndex").mangledNameHash());
+    ASSERT_EQ(0x00000573u, ImmutableString("gl_VertexID").mangledNameHash());
+    ASSERT_EQ(0x00000574u, ImmutableString("gl_VertexIndex").mangledNameHash());
+    ASSERT_EQ(0x00000575u, ImmutableString("gl_DrawID").mangledNameHash());
+    ASSERT_EQ(0x00000576u, ImmutableString("gl_BaseVertex").mangledNameHash());
+    ASSERT_EQ(0x00000577u, ImmutableString("gl_BaseInstance").mangledNameHash());
+    ASSERT_EQ(0x00000578u, ImmutableString("angle_BaseVertex").mangledNameHash());
+    ASSERT_EQ(0x00000579u, ImmutableString("angle_BaseInstance").mangledNameHash());
+    ASSERT_EQ(0x0000057au, ImmutableString("gl_ClipDistance").mangledNameHash());
+    ASSERT_EQ(0x0000057bu, ImmutableString("gl_NumWorkGroups").mangledNameHash());
+    ASSERT_EQ(0x0000057cu, ImmutableString("gl_WorkGroupSize").mangledNameHash());
+    ASSERT_EQ(0x0000057du, ImmutableString("gl_WorkGroupID").mangledNameHash());
+    ASSERT_EQ(0x0000057eu, ImmutableString("gl_LocalInvocationID").mangledNameHash());
+    ASSERT_EQ(0x0000057fu, ImmutableString("gl_GlobalInvocationID").mangledNameHash());
+    ASSERT_EQ(0x00000580u, ImmutableString("gl_LocalInvocationIndex").mangledNameHash());
+    ASSERT_EQ(0x00000581u, ImmutableString("gl_PrimitiveIDIn").mangledNameHash());
+    ASSERT_EQ(0x00000582u, ImmutableString("gl_InvocationID").mangledNameHash());
+    ASSERT_EQ(0x00000583u, ImmutableString("gl_PerVertex").mangledNameHash());
+    ASSERT_EQ(0x00000584u, ImmutableString("gl_in").mangledNameHash());
+    ASSERT_EQ(0x00000585u, ImmutableString("gl_PatchVerticesIn").mangledNameHash());
+    ASSERT_EQ(0x00000586u, ImmutableString("gl_TessLevelOuter").mangledNameHash());
+    ASSERT_EQ(0x00000587u, ImmutableString("gl_TessLevelInner").mangledNameHash());
+    ASSERT_EQ(0x00000588u, ImmutableString("gl_out").mangledNameHash());
+    ASSERT_EQ(0x00000589u, ImmutableString("gl_BoundingBox").mangledNameHash());
+    ASSERT_EQ(0x0000058au, ImmutableString("gl_BoundingBoxEXT").mangledNameHash());
+    ASSERT_EQ(0x0000058bu, ImmutableString("gl_BoundingBoxOES").mangledNameHash());
+    ASSERT_EQ(0x0000058cu, ImmutableString("gl_TessCoord").mangledNameHash());
+    ASSERT_EQ(0x0000058du, ImmutableString("gl_ViewID_OVR").mangledNameHash());
+    ASSERT_EQ(0x0000058eu, ImmutableString("gl_CullDistance").mangledNameHash());
     ASSERT_EQ(0x00000000u, ImmutableString("radians").unmangledNameHash());
     ASSERT_EQ(0x00000001u, ImmutableString("degrees").unmangledNameHash());
     ASSERT_EQ(0x00000002u, ImmutableString("sin").unmangledNameHash());
@@ -1643,7 +1644,8 @@ TEST(ImmutableStringTest, ScriptGeneratedHashesMatch)
     ASSERT_EQ(0x000000afu, ImmutableString("numSamples").unmangledNameHash());
     ASSERT_EQ(0x000000b0u, ImmutableString("samplePosition").unmangledNameHash());
     ASSERT_EQ(0x000000b1u, ImmutableString("interpolateAtCenter").unmangledNameHash());
-    ASSERT_EQ(0x000000b2u, ImmutableString("saturate").unmangledNameHash());
+    ASSERT_EQ(0x000000b2u, ImmutableString("loopForwardProgress").unmangledNameHash());
+    ASSERT_EQ(0x000000b3u, ImmutableString("saturate").unmangledNameHash());
 }
 
 }  // namespace sh
diff --git a/src/tests/compiler_tests/MSLOutput_test.cpp b/src/tests/compiler_tests/MSLOutput_test.cpp
index b565921ac0c0a476459a7e2381ceec691bef0b80..13c88a436997efa658726b22b2cc8ef7cf1d5b0a 100644
--- a/src/tests/compiler_tests/MSLOutput_test.cpp
+++ b/src/tests/compiler_tests/MSLOutput_test.cpp
@@ -1085,3 +1085,34 @@ void F(int v) { g = v; }
 void main() { F(1), F(g); })";
     compile(kShader, options);
 }
+
+TEST_F(MSLOutputTest, EnsureLoopForwardProgressInfinite)
+{
+    ShCompileOptions options          = defaultOptions();
+    options.ensureLoopForwardProgress = 1;
+    const std::string &shaderString =
+        R"(
+        precision mediump float;
+        void main() {
+            for (int i = 0; i < i + 1; ++i) { }
+            gl_FragColor = vec4(1);
+        })";
+    compile(shaderString, options);
+    ASSERT_TRUE(foundInCode(SH_MSL_METAL_OUTPUT, "loopForwardProgress();"));
+    ASSERT_TRUE(foundInCode(SH_MSL_METAL_OUTPUT, "volatile bool p = true;"));
+}
+
+TEST_F(MSLOutputTest, EnsureLoopForwardProgressFinite)
+{
+    ShCompileOptions options          = defaultOptions();
+    options.ensureLoopForwardProgress = 1;
+    const std::string &shaderString =
+        R"(
+        precision mediump float;
+        void main() {
+            for (int i = 0; i < 1; ++i) { }
+            gl_FragColor = vec4(1);
+        })";
+    compile(shaderString, options);
+    ASSERT_FALSE(foundInCode(SH_MSL_METAL_OUTPUT, "loopForwardProgress();"));
+}
diff --git a/src/tests/compiler_tests/Parse_test.cpp b/src/tests/compiler_tests/Parse_test.cpp
index dc12840a18aa573ee9d717a1e5d43f1fb96581e2..38532082204da19b21273fefe862e80a5582cffd 100644
--- a/src/tests/compiler_tests/Parse_test.cpp
+++ b/src/tests/compiler_tests/Parse_test.cpp
@@ -897,7 +897,7 @@ void f(out float r, out float)
 0:4:     Function Prototype: 'main' (symbol id 3004) (void)
 0:5:     Code block
 0:6:       move second child to first child (mediump 4-component vector of float)
-0:6:         gl_FragColor (symbol id 1912) (FragColor mediump 4-component vector of float)
+0:6:         gl_FragColor (symbol id 1913) (FragColor mediump 4-component vector of float)
 0:6:         Constant union (const mediump 4-component vector of float)
 0:6:           0.5 (const float)
 0:6:           0.5 (const float)
@@ -905,9 +905,9 @@ void f(out float r, out float)
 0:6:           0.5 (const float)
 0:7:       Call a function: 'f' (symbol id 3001) (void)
 0:7:         vector swizzle (x) (mediump float)
-0:7:           gl_FragColor (symbol id 1912) (FragColor mediump 4-component vector of float)
+0:7:           gl_FragColor (symbol id 1913) (FragColor mediump 4-component vector of float)
 0:7:         vector swizzle (y) (mediump float)
-0:7:           gl_FragColor (symbol id 1912) (FragColor mediump 4-component vector of float)
+0:7:           gl_FragColor (symbol id 1913) (FragColor mediump 4-component vector of float)
 0:9:   Function Definition:
 0:9:     Function Prototype: 'f' (symbol id 3001) (void)
 0:9:       parameter: 'r' (symbol id 3006) (out highp float)
diff --git a/src/tests/egl_tests/EGLContextCompatibilityTest.cpp b/src/tests/egl_tests/EGLContextCompatibilityTest.cpp
index eac20d2294f4485728a9f9ac4d76bf1ddecad7ec..10264796728c43afb04eb8cdc6861e648c5b9165 100644
--- a/src/tests/egl_tests/EGLContextCompatibilityTest.cpp
+++ b/src/tests/egl_tests/EGLContextCompatibilityTest.cpp
@@ -173,8 +173,9 @@ class EGLContextCompatibilityTest : public ANGLETestBase, public testing::Test
     void SetUp() final
     {
         ANGLETestBase::ANGLETestSetUp();
+#if !defined(EGL_EGL_PROTOTYPES) || !EGL_EGL_PROTOTYPES
         ASSERT_TRUE(eglGetPlatformDisplay != nullptr);
-
+#endif
         EGLAttrib dispattrs[] = {EGL_PLATFORM_ANGLE_TYPE_ANGLE, mRenderer, EGL_NONE};
         mDisplay              = eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE,
                                                       reinterpret_cast<void *>(EGL_DEFAULT_DISPLAY), dispattrs);
@@ -490,11 +491,13 @@ void RegisterContextCompatibilityTests()
 
     LoadEntryPointsWithUtilLoader(angle::GLESDriverType::AngleEGL);
 
+#if !defined(EGL_EGL_PROTOTYPES) || !EGL_EGL_PROTOTYPES
     if (eglGetPlatformDisplay == nullptr)
     {
         std::cerr << "EGLContextCompatibilityTest: missing eglGetPlatformDisplay\n";
         return;
     }
+#endif
 
     for (EGLint renderer : renderers)
     {
diff --git a/src/tests/egl_tests/EGLDisplayTest.cpp b/src/tests/egl_tests/EGLDisplayTest.cpp
index b4278a5a226eb3e42f4b879e27c6d16d65ae10c3..8d92c9637db17be1f3659c5b1199b703ba69fcc5 100644
--- a/src/tests/egl_tests/EGLDisplayTest.cpp
+++ b/src/tests/egl_tests/EGLDisplayTest.cpp
@@ -182,7 +182,9 @@ TEST_P(EGLDisplayTest, GetPlatformDisplayEXT)
     // eglGetPlatformDisplayEXT() requires EGL_EXT_platform_base.
     ANGLE_SKIP_TEST_IF(!IsEGLClientExtensionEnabled("EGL_EXT_platform_base"));
 
+#if !defined(EGL_EGLEXT_PROTOTYPES) || !EGL_EGLEXT_PROTOTYPES
     ASSERT_TRUE(eglGetPlatformDisplayEXT != nullptr);
+#endif
 
     EGLint dispattrs[] = {EGL_PLATFORM_ANGLE_TYPE_ANGLE, GetParam().getRenderer(), EGL_NONE};
     EGLDisplay display = eglGetPlatformDisplayEXT(
diff --git a/src/tests/gl_tests/CopyCompressedTextureTest.cpp b/src/tests/gl_tests/CopyCompressedTextureTest.cpp
index 1ba6b5562469f4c8ed4cf8d9a1d810c334e4a83a..c8cef82a027c71c84233dc7491f9e2ec8d706c8f 100644
--- a/src/tests/gl_tests/CopyCompressedTextureTest.cpp
+++ b/src/tests/gl_tests/CopyCompressedTextureTest.cpp
@@ -66,12 +66,13 @@ class CopyCompressedTextureTest : public ANGLETest<>
             return false;
         }
 
+#if !defined(GL_GLEXT_PROTOTYPES) || !GL_GLEXT_PROTOTYPES
         EXPECT_NE(nullptr, glCompressedCopyTextureCHROMIUM);
         if (glCompressedCopyTextureCHROMIUM == nullptr)
         {
             return false;
         }
-
+#endif
         return true;
     }
 
diff --git a/src/tests/gl_tests/GLSLTest.cpp b/src/tests/gl_tests/GLSLTest.cpp
index f04fc2458887d0c647bcadf0e16a6f6a4ef8128e..9c96d6ee35d98f05e3e7ba40b06ae5eb05609a4d 100644
--- a/src/tests/gl_tests/GLSLTest.cpp
+++ b/src/tests/gl_tests/GLSLTest.cpp
@@ -6884,6 +6884,64 @@ void main()
     EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::green);
 }
 
+// Tests that extracting samplers from structs that are members of other structs
+// will not cause a error when accessing any fields (e.g., uni.b)
+// (This is a modification of the above test "SamplerInStructMemberIndexing").
+TEST_P(GLSLTest, SamplerInStructInStructMemberIndexing)
+{
+    const char kVertexShader[] = R"(attribute vec2 position;
+varying vec2 texCoord;
+void main()
+{
+    gl_Position = vec4(position, 0, 1);
+    texCoord = position * 0.5 + vec2(0.5);
+})";
+
+    const char kFragmentShader[] = R"(precision mediump float;
+struct S1 { sampler2D samp; };
+struct S2 { S1 s1; bool b; };
+uniform S2 uni;
+varying vec2 texCoord;
+void main()
+{
+    uni;
+    if (uni.b)
+    {
+        gl_FragColor = texture2D(uni.s1.samp, texCoord);
+    }
+    else
+    {
+        gl_FragColor = vec4(1, 0, 0, 1);
+    }
+})";
+
+    ANGLE_GL_PROGRAM(program, kVertexShader, kFragmentShader);
+    glUseProgram(program);
+
+    GLint bLoc = glGetUniformLocation(program, "uni.b");
+    ASSERT_NE(-1, bLoc);
+    GLint sampLoc = glGetUniformLocation(program, "uni.s1.samp");
+    ASSERT_NE(-1, sampLoc);
+
+    glUniform1i(bLoc, 1);
+
+    std::array<GLColor, 4> kGreenPixels = {
+        {GLColor::green, GLColor::green, GLColor::green, GLColor::green}};
+
+    GLTexture tex;
+    glBindTexture(GL_TEXTURE_2D, tex);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 2, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+                 kGreenPixels.data());
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    ASSERT_GL_NO_ERROR();
+
+    drawQuad(program, "position", 0.5f);
+    ASSERT_GL_NO_ERROR();
+
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::green);
+}
+
 // Tests that rewriting samplers in structs works when passed as function argument.  In this test,
 // the function references another struct, which is not being modified.  Regression test for AST
 // validation applied to a multipass transformation, where references to declarations were attempted
@@ -6995,6 +7053,7 @@ TEST_P(GLSLTest_ES3, ConditionInitializerDeclaresVariable)
         "}\n";
 
     ANGLE_GL_PROGRAM(program, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
     drawQuad(program, essl3_shaders::PositionAttrib(), 0.5f);
     EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::green);
 }
@@ -21075,6 +21134,816 @@ void main() {
 
     EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
 }
+
+// Test highp int scalar + vec
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingAdd1)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u + ivec4(0, -1, 1, 2147483645);
+    o.r = r.x == 2 ? 1.0 : 0.0;
+    o.g = r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == 3 ? 1.0 : 0.0;
+    o.a = r.w == 2147483647 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec + scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingAdd2)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, 2147483645) + u;
+    o.r = r.x == 2 ? 1.0 : 0.0;
+    o.g = r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == 3 ? 1.0 : 0.0;
+    o.a = r.w == 2147483647 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec += scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingAdd3)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, 2147483645);
+    r += u;
+    o.r = r.x == 2 ? 1.0 : 0.0;
+    o.g = r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == 3 ? 1.0 : 0.0;
+    o.a = r.w == 2147483647 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar + vec handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingAddUB)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u + ivec4(0, -1, 1, 2147483647);
+    o.r = r.x == 2 ? 1.0 : 0.0;
+    o.g = r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == 3 ? 1.0 : 0.0;
+    o.a = r.w == -2147483647 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar - vec
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingSub1)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u - ivec4(0, -1, 1, 2147483647);
+    o.r = r.x == 2 ? 1.0 : 0.0;
+    o.g = r.y == 3 ? 1.0 : 0.0;
+    o.b = r.z == 1 ? 1.0 : 0.0;
+    o.a = r.w == -2147483645 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec - scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingSub2)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, -2147483646) - u;
+    o.r = r.x == -2 ? 1.0 : 0.0;
+    o.g = r.y == -3 ? 1.0 : 0.0;
+    o.b = r.z == -1 ? 1.0 : 0.0;
+    o.a = r.w == -2147483648 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec -= scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingSub3)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, -2147483646);
+    r -= u;
+    o.r = r.x == -2 ? 1.0 : 0.0;
+    o.g = r.y == -3 ? 1.0 : 0.0;
+    o.b = r.z == -1 ? 1.0 : 0.0;
+    o.a = r.w == -2147483648 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+//
+// Test highp int scalar - vec handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingSubUB)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, -2147483648) - u;
+    o.r = r.x == -2 ? 1.0 : 0.0;
+    o.g = r.y == -3 ? 1.0 : 0.0;
+    o.b = r.z == -1 ? 1.0 : 0.0;
+    o.a = r.w == 2147483646 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar * vec
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMul1)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u * ivec4(0, -1, 1, 3);
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == -2 ? 1.0 : 0.0;
+    o.b = r.z == 2 ? 1.0 : 0.0;
+    o.a = r.w == 6 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec * scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMul2)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, 3) * u;
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == -2 ? 1.0 : 0.0;
+    o.b = r.z == 2 ? 1.0 : 0.0;
+    o.a = r.w == 6 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec *= scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMul3)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(0, -1, 1, 3);
+    r *= u;
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == -2 ? 1.0 : 0.0;
+    o.b = r.z == 2 ? 1.0 : 0.0;
+    o.a = r.w == 6 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar * vector handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMulUB)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u * ivec4(0, -1, 1, -2147483648);
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == -1 ? 1.0 : 0.0;
+    o.a = r.w == -2147483648 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, -1);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar / vec
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingDiv1)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u / ivec4(2, -1, 1, 3);
+    o.r = r.x == 1 ? 1.0 : 0.0;
+    o.g = r.y == -2 ? 1.0 : 0.0;
+    o.b = r.z == 2 ? 1.0 : 0.0;
+    o.a = r.w == 0 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec / scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingDiv2)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(2, -1, 1, 3) / u;
+    o.r = r.x == 1 ? 1.0 : 0.0;
+    o.g = r.y == 0 ? 1.0 : 0.0;
+    o.b = r.z == 0 ? 1.0 : 0.0;
+    o.a = r.w == 1 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec /= scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingDiv3)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(2, -1, 1, 3);
+    r /= u;
+    o.r = r.x == 1 ? 1.0 : 0.0;
+    o.g = r.y == 0 ? 1.0 : 0.0;
+    o.b = r.z == 0 ? 1.0 : 0.0;
+    o.a = r.w == 1 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar / vec handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingDivUB)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u / ivec4(0, -1, 1, 3);
+    o.r = r.x == -2147483648 ? 1.0 : 0.0;
+    // FIXME: ANGLE_div should also handle -INT_MAX / -1
+    // o.g = r.y == -2147483648 ? 1.0 : 0.0;
+    o.g = 1.0;
+    o.b = r.z == -2147483648 ? 1.0 : 0.0;
+    o.a = r.w == -715827882 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, -2147483648);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar % vec
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMod1)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u % ivec4(2, 7, 1, 3);
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == 2 ? 1.0 : 0.0;
+    o.b = r.z == 0 ? 1.0 : 0.0;
+    o.a = r.w == 2 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec % scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMod2)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(2147483647, 0, 1, 3) % u;
+    o.r = r.x == 1 ? 1.0 : 0.0;
+    o.g = r.y == 0 ? 1.0 : 0.0;
+    o.b = r.z == 1 ? 1.0 : 0.0;
+    o.a = r.w == 1 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int vec %= scalar
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingMod3)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(2147483647, 0, 1, 3);
+    r %= u;
+    o.r = r.x == 1 ? 1.0 : 0.0;
+    o.g = r.y == 0 || r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == 1 ? 1.0 : 0.0;
+    o.a = r.w == 1 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, 2);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int scalar % vec handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingModUB)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = u % ivec4(0, -1, 1, 3);
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == 0 ? 1.0 : 0.0;
+    o.b = r.z == 0 ? 1.0 : 0.0;
+    o.a = r.w == -2 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform1i(u, -2147483648);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int float to int vector conversion
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingFtoi1)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform vec4 u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u);
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == -1 ? 1.0 : 0.0;
+    o.b = r.z == -2147483648 ? 1.0 : 0.0;
+    o.a = r.w ==  83645 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform4f(u, 0., -1., -2147483648., 83645.);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int float to int scalar conversion
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingFtoi2)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform vec4 u;
+out vec4 o;
+void main() {
+    int rx = int(u.x);
+    int ry = int(u.y);
+    int rz = int(u.z);
+    int rw = int(u.w);
+    o.r = rx == 0 ? 1.0 : 0.0;
+    o.g = ry == -1 ? 1.0 : 0.0;
+    o.b = rz == -2147483648 ? 1.0 : 0.0;
+    o.a = rw ==  83645 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform4f(u, 0., -1., -2147483648., 83645.);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+//
+// Test highp int float to int vector conversion handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingFtoiUB1)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform vec4 u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u);
+    o.r = r.x == 0 ? 1.0 : 0.0;
+    o.g = r.y == -1 ? 1.0 : 0.0;
+    o.b = r.z == -2147483648 ? 1.0 : 0.0;
+    o.a = r.w ==  2147483647 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform4f(u, 0., -1., -2147483649., 2147483648.);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int float to int scalar conversion handles UB
+TEST_P(GLSLTest_ES3, IntVecOperatorOverloadingFtoiUB2)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform vec4 u;
+out vec4 o;
+void main() {
+    int rx = int(u.x);
+    int ry = int(u.y);
+    int rz = int(u.z);
+    int rw = int(u.w);
+    o.r = rx == 0 ? 1.0 : 0.0;
+    o.g = ry == -1 ? 1.0 : 0.0;
+    o.b = rz == -2147483648 ? 1.0 : 0.0;
+    o.a = rw ==  2147483647 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    glUseProgram(testProgram);
+    GLint u = glGetUniformLocation(testProgram, "u");
+    EXPECT_NE(-1, u);
+    glUniform4f(u, 0., -1., -2147483649., 2147483648.);
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int wrap behavior with plus and minus.
+TEST_P(GLSLTest_ES3, IntVecAdditionSubtractionWrap)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u) + ivec4(0, -1, 1, 3);
+    r -= ivec4(2147483647, 2147483647, 2147483647, 0);
+    r += ivec4(0, 0, 0, 2147483647);
+    o.r = r.x == -2147483647 ? 1.0 : 0.0;
+    o.g = r.y == -2147483648 ? 1.0 : 0.0;
+    o.b = r.z == -2147483646 ? 1.0 : 0.0;
+    o.a = r.w == -2147483646 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int wrap behavior with multiplication.
+TEST_P(GLSLTest_ES3, IntVecMultiplicationWrap)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u) + ivec4(-2, 2, 1, -1);
+    r *= ivec4(2147483647, 2147483647, -2147483648, -2147483648);
+    o.r = r.x == 2 ? 1.0 : 0.0;
+    o.g = r.y == -2 ? 1.0 : 0.0;
+    o.b = r.z == -2147483648 ? 1.0 : 0.0;
+    o.a = r.w == -2147483648 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int wrap behavior with division.
+TEST_P(GLSLTest_ES3, IntVecDivisionWrap)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u) + ivec4(2147483647, 2147483647, -2147483648, -2147483648);
+    r /= ivec4(1, -1, 1, -1);
+    o.r = r.x == 2147483647 ? 1.0 : 0.0;
+    o.g = r.y == -2147483647 ? 1.0 : 0.0;
+    o.b = r.z == -2147483648 ? 1.0 : 0.0;
+    o.a = 1.0;
+
+    // FIXME
+    //o.a = r.w == -2147483648 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int wrap behavior with modulus.
+TEST_P(GLSLTest_ES3, IntScalarModulus)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u) + ivec4(2147483647, 2147483647, -2147483648, -2147483648);
+    r %= 8;
+    o.r = r.x == 7 ? 1.0 : 0.0;
+    o.g = r.y == 7 ? 1.0 : 0.0;
+    o.b = r.z == 0 ? 1.0 : 0.0;
+    o.a = r.w == 0 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
+// Test highp int modulus undefinedness with negative numbers
+TEST_P(GLSLTest_ES3, IntScalarModulusUB1)
+{
+    ANGLE_SKIP_TEST_IF(!IsMetal());
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp int;
+precision highp float;
+uniform int u;
+out vec4 o;
+void main() {
+    ivec4 r = ivec4(u) + ivec4(-1, 1, -7, 7);
+    r %= 8;
+    o.r = r.x == -1 ? 1.0 : 0.0;
+    o.g = r.y == 1 ? 1.0 : 0.0;
+    o.b = r.z == -7 ? 1.0 : 0.0;
+    o.a = r.w == 7 ? 1.0 : 0.0;
+}
+)";
+    ANGLE_GL_PROGRAM(testProgram, essl3_shaders::vs::Simple(), kFS);
+    ASSERT_GL_NO_ERROR();
+    drawQuad(testProgram, essl31_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor(255, 255, 255, 255));
+    ASSERT_GL_NO_ERROR();
+}
+
 }  // anonymous namespace
 
 ANGLE_INSTANTIATE_TEST_ES2_AND_ES3_AND(
diff --git a/src/tests/gl_tests/ImageTestMetal.mm b/src/tests/gl_tests/ImageTestMetal.mm
index 170879bf90a74256ced4f403eb8895705592f6ed..28141cb7dcad9ebd2d76ad98d8265dfcf869158e 100644
--- a/src/tests/gl_tests/ImageTestMetal.mm
+++ b/src/tests/gl_tests/ImageTestMetal.mm
@@ -15,7 +15,6 @@
 
 #include <CoreFoundation/CoreFoundation.h>
 #include <Metal/Metal.h>
-#include <gmock/gmock.h>
 #include <span>
 
 namespace angle
diff --git a/src/tests/gl_tests/PbufferTest.cpp b/src/tests/gl_tests/PbufferTest.cpp
index 4a3409a407b16df54f085a5ccc3d63fb6f808a9f..dead2f816e3fb7f93eb5dce24d9491b752884fcd 100644
--- a/src/tests/gl_tests/PbufferTest.cpp
+++ b/src/tests/gl_tests/PbufferTest.cpp
@@ -302,7 +302,6 @@ TEST_P(PbufferTest, BindTexImageOverwrite)
     // Test skipped because Pbuffers are not supported or Pbuffer does not support binding to RGBA
     // textures.
     ANGLE_SKIP_TEST_IF(!mSupportsPbuffers || !mSupportsBindTexImage);
-
     EGLWindow *window = getEGLWindow();
     window->makeCurrent();
 
@@ -532,7 +531,6 @@ TEST_P(PbufferTest, BindTexImageOverwriteReleasesOrphanedPbuffer)
     // Test skipped because Pbuffers are not supported or Pbuffer does not support binding to RGBA
     // textures.
     ANGLE_SKIP_TEST_IF(!mSupportsPbuffers || !mSupportsBindTexImage);
-
     EGLWindow *window = getEGLWindow();
     window->makeCurrent();
 
diff --git a/src/tests/gl_tests/PixelLocalStorageTest.cpp b/src/tests/gl_tests/PixelLocalStorageTest.cpp
index 795d843d5604e56f73e735b280d164cd11473b2c..8bc8040cb4ce38861493ed3c5990cfd7e172b254 100644
--- a/src/tests/gl_tests/PixelLocalStorageTest.cpp
+++ b/src/tests/gl_tests/PixelLocalStorageTest.cpp
@@ -6,6 +6,7 @@
 
 #include <sstream>
 #include <string>
+#include "common/string_utils.h"
 #include "test_utils/ANGLETest.h"
 #include "test_utils/gl_raii.h"
 
@@ -8557,7 +8558,6 @@ TEST_P(PixelLocalStorageCompilerTest, BlendEquationAdvanced_illegal_with_PLS)
     layout(binding=0, rgba8i) uniform lowp ipixelLocalANGLE pls;)";
     EXPECT_TRUE(log.compileFragmentShader(kRequireBlendAdvanced));
 
-    bool before = true;
     for (const char *layoutQualifier : {
              "blend_support_multiply",
              "blend_support_screen",
@@ -8577,44 +8577,34 @@ TEST_P(PixelLocalStorageCompilerTest, BlendEquationAdvanced_illegal_with_PLS)
              "blend_support_all_equations",
          })
     {
-        constexpr char kRequireBlendAdvancedBeforePLS[] = R"(#version 300 es
-        #extension GL_ANGLE_shader_pixel_local_storage : require
-        #extension GL_KHR_blend_equation_advanced : require
-        layout(%s) out;
-        void main()
-        {}
-        layout(binding=0, rgba8i) uniform lowp ipixelLocalANGLE pls;)";
-
-        constexpr char kRequireBlendAdvancedAfterPLS[] = R"(#version 300 es
-        #extension GL_ANGLE_shader_pixel_local_storage : require
-        #extension GL_KHR_blend_equation_advanced : require
-        layout(binding=0, rgba8i) uniform lowp ipixelLocalANGLE pls;
-        layout(%s) out;
-        void main()
-        {})";
+        std::string shaderBefore = R"(#version 300 es
+#extension GL_ANGLE_shader_pixel_local_storage : require
+#extension GL_KHR_blend_equation_advanced : require
+layout(%s) out;
+void main()
+{}
+layout(binding=0, rgba8i) uniform lowp ipixelLocalANGLE pls;)";
+        ReplaceSubstring(&shaderBefore, "%s", layoutQualifier);
 
-        const char *formatStr =
-            before ? kRequireBlendAdvancedBeforePLS : kRequireBlendAdvancedAfterPLS;
-        size_t buffSize =
-            snprintf(nullptr, 0, formatStr, layoutQualifier) + 1;  // Extra space for '\0'
-        std::unique_ptr<char[]> shader(new char[buffSize]);
-        std::snprintf(shader.get(), buffSize, formatStr, layoutQualifier);
-        EXPECT_FALSE(log.compileFragmentShader(shader.get()));
-        if (before)
-        {
+        EXPECT_FALSE(log.compileFragmentShader(shaderBefore.c_str()));
         EXPECT_TRUE(
             log.has("ERROR: 0:4: 'layout' : illegal advanced blend equation when pixel local "
                     "storage is declared"));
-        }
-        else
-        {
+
+        std::string shaderAfter = R"(#version 300 es
+#extension GL_ANGLE_shader_pixel_local_storage : require
+#extension GL_KHR_blend_equation_advanced : require
+layout(binding=0, rgba8i) uniform lowp ipixelLocalANGLE pls;
+layout(%s) out;
+void main()
+{})";
+        ReplaceSubstring(&shaderAfter, "%s", layoutQualifier);
+
+        EXPECT_FALSE(log.compileFragmentShader(shaderAfter.c_str()));
         EXPECT_TRUE(
             log.has("ERROR: 0:5: 'layout' : illegal advanced blend equation when pixel local "
                     "storage is declared"));
     }
-
-        before = !before;
-    }
 }
 
 // Check proper validation of PLS function arguments.
diff --git a/src/tests/gl_tests/ProvokingVertexTest.cpp b/src/tests/gl_tests/ProvokingVertexTest.cpp
index 739499b04e28e44f9b771d3cf21aa7f785e88df8..db2e5a6b328a1ee84cdb1eb92b30b546729ccd42 100644
--- a/src/tests/gl_tests/ProvokingVertexTest.cpp
+++ b/src/tests/gl_tests/ProvokingVertexTest.cpp
@@ -12,7 +12,6 @@
 #include "GLES2/gl2.h"
 #include "test_utils/ANGLETest.h"
 #include "test_utils/gl_raii.h"
-#include "util/gles_loader_autogen.h"
 
 using namespace angle;
 
diff --git a/src/tests/gl_tests/RobustResourceInitTest.cpp b/src/tests/gl_tests/RobustResourceInitTest.cpp
index 7452b1e56577f205d476ad52bd6c5be13b314352..7fe056ab39eb78ad330a4c52814a217db4d08586 100644
--- a/src/tests/gl_tests/RobustResourceInitTest.cpp
+++ b/src/tests/gl_tests/RobustResourceInitTest.cpp
@@ -9,7 +9,6 @@
 
 #include "test_utils/gl_raii.h"
 #include "util/EGLWindow.h"
-#include "util/gles_loader_autogen.h"
 
 namespace angle
 {
diff --git a/src/tests/gl_tests/SamplersTest.cpp b/src/tests/gl_tests/SamplersTest.cpp
index bdd785436212f7ededd0b36be63a1b2b56de54dc..501a3f10c75339f6833e6fc0c652958ad84e0626 100644
--- a/src/tests/gl_tests/SamplersTest.cpp
+++ b/src/tests/gl_tests/SamplersTest.cpp
@@ -11,7 +11,6 @@
 
 #include "test_utils/angle_test_configs.h"
 #include "test_utils/gl_raii.h"
-#include "util/gles_loader_autogen.h"
 #include "util/shader_utils.h"
 
 namespace angle
diff --git a/src/tests/gl_tests/TextureTest.cpp b/src/tests/gl_tests/TextureTest.cpp
index 627f4e830a346dda2cc813a9ca6a8d9e5fe55294..90c3c0ea5bb34247d50ee3206568354f8613c1a3 100644
--- a/src/tests/gl_tests/TextureTest.cpp
+++ b/src/tests/gl_tests/TextureTest.cpp
@@ -2001,6 +2001,7 @@ void Texture2DDepthStencilTestES3::TestSampleWithDepthStencilMode(GLenum format,
             break;
         default:
             UNREACHABLE();
+            return;
     }
 
     // Set up a color texture.
@@ -10660,7 +10661,7 @@ class TextureLimitsTest : public ANGLETest<>
         initTextures(vertexTextureCount + fragmentTextureCount, 0);
 
         glUseProgram(mProgram);
-        RGBA8 expectedSum = {0};
+        RGBA8 expectedSum{};
         for (GLint texIndex = 0; texIndex < vertexTextureCount; ++texIndex)
         {
             std::stringstream uniformNameStr;
diff --git a/src/tests/gl_tests/TimeoutDrawTest.cpp b/src/tests/gl_tests/TimeoutDrawTest.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..a53ba6fd09fd3e6cfa967464f1342132e6832438
--- /dev/null
+++ b/src/tests/gl_tests/TimeoutDrawTest.cpp
@@ -0,0 +1,201 @@
+
+//
+// Copyright 2025 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+#include "test_utils/ANGLETest.h"
+#include "test_utils/gl_raii.h"
+#include "util/shader_utils.h"
+
+namespace
+{
+
+// To inspect current behavior, run the tests in following manner:
+// clang-format off
+// ANGLE_FEATURE_OVERRIDES_DISABLED=injectAsmStatementIntoLoopBodies GMD_STDOUT=1 ./out/Debug/angle_end2end_tests --gtest_also_run_disabled_tests --gtest_filter=TimeoutDrawTest.DISABLED_DynamicInfiniteLoop2VS/ES3_Metal
+// GMD_STDOUT=1 ./out/Debug/angle_end2end_tests --gtest_also_run_disabled_tests --gtest_filter=TimeoutDrawTest.DISABLED_DynamicInfiniteLoop2VS/ES3_Metal_EnsureLoopForwardProgress
+// clang-format on
+
+using namespace angle;
+class TimeoutDrawTest : public ANGLETest<>
+{
+  protected:
+    TimeoutDrawTest()
+    {
+        setWindowWidth(128);
+        setWindowHeight(128);
+        setConfigRedBits(8);
+        setConfigGreenBits(8);
+        setConfigBlueBits(8);
+        setConfigAlphaBits(8);
+        // Tests should skip if robustness not supported, but this can be done only after
+        // Metal supports robustness.
+        if (IsEGLClientExtensionEnabled("EGL_EXT_create_context_robustness"))
+        {
+            setContextResetStrategy(EGL_LOSE_CONTEXT_ON_RESET_EXT);
+        }
+        else
+        {
+            setContextResetStrategy(EGL_NO_RESET_NOTIFICATION_EXT);
+        }
+    }
+    void testSetUp() override
+    {
+        glClear(GL_COLOR_BUFFER_BIT);
+        glFinish();
+    }
+};
+
+// Tests that trivial infinite loops in vertex shaders hang instead of progress.
+TEST_P(TimeoutDrawTest, DISABLED_TrivialInfiniteLoopVS)
+{
+    constexpr char kVS[] = R"(precision highp float;
+attribute vec4 a_position;
+void main()
+{
+    for (;;) {}
+    gl_Position = a_position;
+})";
+    ANGLE_GL_PROGRAM(program, kVS, essl1_shaders::fs::Red());
+    drawQuad(program, essl1_shaders::PositionAttrib(), 0.5f);
+    glFinish();
+    if (glGetError() != GL_CONTEXT_LOST)
+    {
+        FAIL();
+        EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
+    }
+}
+
+// Tests that trivial infinite loops in fragment shaders hang instead of progress.
+TEST_P(TimeoutDrawTest, DISABLED_TrivialInfiniteLoopFS)
+{
+    constexpr char kFS[] = R"(precision mediump float;
+void main()
+{
+    for (;;) {}
+    gl_FragColor = vec4(1, 0, 0, 1);
+})";
+    ANGLE_GL_PROGRAM(program, essl1_shaders::vs::Simple(), kFS);
+    drawQuad(program, essl1_shaders::PositionAttrib(), 0.5f);
+    glFinish();
+    if (glGetError() != GL_CONTEXT_LOST)
+    {
+        FAIL();
+        EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
+    }
+}
+// Tests that infinite loops based on user-supplied values in vertex shaders hang instead of
+// progress. Otherwise optimizer would be able to assume something about the domain of the
+// user-supplied value.
+TEST_P(TimeoutDrawTest, DISABLED_DynamicInfiniteLoopVS)
+{
+    constexpr char kVS[] = R"(precision highp float;
+attribute vec4 a_position;
+uniform int f;
+void main()
+{
+    for (;f != 0;) {}
+    gl_Position = a_position;
+})";
+    ANGLE_GL_PROGRAM(program, kVS, essl1_shaders::fs::Red());
+    glUseProgram(program);
+    GLint uniformLocation = glGetUniformLocation(program, "f");
+    glUniform1i(uniformLocation, 77);
+    drawQuad(program, essl1_shaders::PositionAttrib(), 0.5f);
+    glFinish();
+    if (glGetError() != GL_CONTEXT_LOST)
+    {
+        FAIL();
+        EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
+    }
+}
+// Tests that infinite loops based on user-supplied values in fragment shaders hang instead of
+// progress. Otherwise optimizer would be able to assume something about the domain of the
+// user-supplied value.
+TEST_P(TimeoutDrawTest, DISABLED_DynamicInfiniteLoopFS)
+{
+    constexpr char kFS[] = R"(precision mediump float;
+uniform int f;
+void main()
+{
+    for (;f != 0;) {}
+    gl_FragColor = vec4(1, 0, 0, 1);
+})";
+    ANGLE_GL_PROGRAM(program, essl1_shaders::vs::Simple(), kFS);
+    glUseProgram(program);
+    GLint uniformLocation = glGetUniformLocation(program, "f");
+    glUniform1i(uniformLocation, 88);
+    EXPECT_GL_NO_ERROR();
+    drawQuad(program, essl1_shaders::PositionAttrib(), 0.5f);
+    glFinish();
+    if (glGetError() != GL_CONTEXT_LOST)
+    {
+        FAIL();
+        EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
+    }
+}
+// Tests that infinite loops based on user-supplied values in vertex shaders hang instead of
+// progress. Otherwise optimizer would be able to assume something about the domain of the
+// user-supplied value. Explicit value break variant.
+TEST_P(TimeoutDrawTest, DISABLED_DynamicInfiniteLoop2VS)
+{
+    constexpr char kVS[] = R"(precision highp float;
+attribute vec4 a_position;
+uniform int f;
+void main()
+{
+    for (;;) { if (f <= 1) break; }
+    gl_Position = a_position;
+})";
+    ANGLE_GL_PROGRAM(program, kVS, essl1_shaders::fs::Red());
+    glUseProgram(program);
+    GLint uniformLocation = glGetUniformLocation(program, "f");
+    glUniform1i(uniformLocation, 66);
+    EXPECT_GL_NO_ERROR();
+    drawQuad(program, essl1_shaders::PositionAttrib(), 0.5f);
+    glFinish();
+    if (glGetError() != GL_CONTEXT_LOST)
+    {
+        FAIL();
+        EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
+    }
+}
+
+// Tests that infinite loops based on user-supplied values in fragment shaders hang instead of
+// progress. Otherwise optimizer would be able to assume something about the domain of the
+// user-supplied value. Explicit value break variant.
+TEST_P(TimeoutDrawTest, DISABLED_DynamicInfiniteLoop2FS)
+{
+    constexpr char kFS[] = R"(precision mediump float;
+uniform float f;
+void main()
+{
+    for (;;) { if (f < 0.1) break; }
+    gl_FragColor = vec4(1, 0, f, 1);
+})";
+    ANGLE_GL_PROGRAM(program, essl1_shaders::vs::Simple(), kFS);
+    glUseProgram(program);
+    GLint uniformLocation = glGetUniformLocation(program, "f");
+    glUniform1f(uniformLocation, .5f);
+    EXPECT_GL_NO_ERROR();
+    drawQuad(program, essl1_shaders::PositionAttrib(), 0.5f);
+    glFinish();
+    if (glGetError() != GL_CONTEXT_LOST)
+    {
+        FAIL();
+        EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::transparentBlack);
+    }
+}
+}  // namespace
+
+GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(TimeoutDrawTest);
+
+ANGLE_INSTANTIATE_TEST(
+    TimeoutDrawTest,
+    WithRobustness(ES2_METAL()),
+    WithRobustness(ES3_METAL()),
+    WithRobustness(ES2_METAL().enable(Feature::InjectAsmStatementIntoLoopBodies)),
+    WithRobustness(ES3_METAL().enable(Feature::InjectAsmStatementIntoLoopBodies)),
+    WithRobustness(ES2_METAL().enable(Feature::EnsureLoopForwardProgress)),
+    WithRobustness(ES3_METAL().enable(Feature::EnsureLoopForwardProgress)));
diff --git a/src/tests/gl_tests/TransformFeedbackTest.cpp b/src/tests/gl_tests/TransformFeedbackTest.cpp
index 1b1a168949a1a9b573895f7b82b8fdc2bdb9b115..063053a732cd589db8738fbbccd6ff916d26610c 100644
--- a/src/tests/gl_tests/TransformFeedbackTest.cpp
+++ b/src/tests/gl_tests/TransformFeedbackTest.cpp
@@ -7,7 +7,6 @@
 #include "test_utils/ANGLETest.h"
 #include "test_utils/gl_raii.h"
 #include "util/EGLWindow.h"
-#include "util/gles_loader_autogen.h"
 #include "util/random_utils.h"
 #include "util/test_utils.h"
 
diff --git a/src/tests/gl_tests/UniformTest.cpp b/src/tests/gl_tests/UniformTest.cpp
index 3ce294a3f51d672019a5200fd3a3c682bed71033..d60693ce377824a7e432b61c1c603d69e2320b00 100644
--- a/src/tests/gl_tests/UniformTest.cpp
+++ b/src/tests/gl_tests/UniformTest.cpp
@@ -9,7 +9,6 @@
 #include "test_utils/angle_test_configs.h"
 #include "test_utils/angle_test_instantiate.h"
 #include "test_utils/gl_raii.h"
-#include "util/gles_loader_autogen.h"
 #include "util/shader_utils.h"
 
 #include <array>
@@ -2228,7 +2227,7 @@ TEST_P(UniformTestES3, MatrixUniformUpload)
         matrixValues[i] = static_cast<GLfloat>(i);
     }
 
-    using UniformMatrixCxRfv = decltype(glUniformMatrix2fv);
+    using UniformMatrixCxRfv = GL_APIENTRY void (*)(GLint, GLsizei, GLboolean, const GLfloat *);
     UniformMatrixCxRfv uniformMatrixCxRfv[kMaxDims + 1][kMaxDims + 1] = {
         {nullptr, nullptr, nullptr, nullptr, nullptr},
         {nullptr, nullptr, nullptr, nullptr, nullptr},
diff --git a/util/autogen/angle_features_autogen.cpp b/util/autogen/angle_features_autogen.cpp
index afead501106c9506e14f35bce66a258ae30ecfa2..8e96dbda21d153caac1161fb31082a975ded1186 100644
--- a/util/autogen/angle_features_autogen.cpp
+++ b/util/autogen/angle_features_autogen.cpp
@@ -160,6 +160,7 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::EnableShaderSubstitution, "enableShaderSubstitution"},
     {Feature::EnableTimestampQueries, "enableTimestampQueries"},
     {Feature::EnableTranslatedShaderSubstitution, "enableTranslatedShaderSubstitution"},
+    {Feature::EnsureLoopForwardProgress, "ensureLoopForwardProgress"},
     {Feature::EnsureNonEmptyBufferIsBoundForDraw, "ensureNonEmptyBufferIsBoundForDraw"},
     {Feature::ExpandIntegerPowExpressions, "expandIntegerPowExpressions"},
     {Feature::ExplicitFragmentLocations, "explicitFragmentLocations"},
@@ -212,6 +213,7 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::HasShaderStencilOutput, "hasShaderStencilOutput"},
     {Feature::HasStencilAutoResolve, "hasStencilAutoResolve"},
     {Feature::HasTextureSwizzle, "hasTextureSwizzle"},
+    {Feature::HasVariableRasterizationRate, "hasVariableRasterizationRate"},
     {Feature::InitFragmentOutputVariables, "initFragmentOutputVariables"},
     {Feature::InitializeCurrentVertexAttributes, "initializeCurrentVertexAttributes"},
     {Feature::InjectAsmStatementIntoLoopBodies, "injectAsmStatementIntoLoopBodies"},
diff --git a/util/autogen/angle_features_autogen.h b/util/autogen/angle_features_autogen.h
index b168ae94b3e126dc53f34d8935f72ad37337e724..7f7735c68b94b03d79a43789b5ee12584cb860a7 100644
--- a/util/autogen/angle_features_autogen.h
+++ b/util/autogen/angle_features_autogen.h
@@ -160,6 +160,7 @@ enum class Feature
     EnableShaderSubstitution,
     EnableTimestampQueries,
     EnableTranslatedShaderSubstitution,
+    EnsureLoopForwardProgress,
     EnsureNonEmptyBufferIsBoundForDraw,
     ExpandIntegerPowExpressions,
     ExplicitFragmentLocations,
@@ -212,6 +213,7 @@ enum class Feature
     HasShaderStencilOutput,
     HasStencilAutoResolve,
     HasTextureSwizzle,
+    HasVariableRasterizationRate,
     InitFragmentOutputVariables,
     InitializeCurrentVertexAttributes,
     InjectAsmStatementIntoLoopBodies,
diff --git a/util/capture/frame_capture_replay_autogen.cpp b/util/capture/frame_capture_replay_autogen.cpp
index 23c88f2c9e81c4338b2f7d3e3e4bbf88a89d3865..8196274f4adc448a70810936ca52699640b4da29 100644
--- a/util/capture/frame_capture_replay_autogen.cpp
+++ b/util/capture/frame_capture_replay_autogen.cpp
@@ -105,6 +105,10 @@ void ReplayTraceFunctionCall(const CallCapture &call, const TraceFunctionMap &cu
                                captures[3].value.GLbooleanVal, captures[4].value.GLintVal,
                                captures[5].value.GLenumVal, captures[6].value.GLenumVal);
             break;
+        case angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE:
+            glBindMetalRasterizationRateMapANGLE(
+                captures[0].value.GLuintVal, captures[1].value.GLMTLRasterizationRateMapANGLEVal);
+            break;
         case angle::EntryPoint::GLBindProgramPipeline:
             glBindProgramPipeline(gProgramPipelineMap[captures[0].value.GLuintVal]);
             break;
@@ -1055,6 +1059,11 @@ void ReplayTraceFunctionCall(const CallCapture &call, const TraceFunctionMap &cu
                                          captures[2].value.GLenumVal,
                                          gRenderbufferMap[captures[3].value.GLuintVal]);
             break;
+        case angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT:
+            glFramebufferResolveRenderbufferWEBKIT(
+                captures[0].value.GLenumVal, captures[1].value.GLenumVal,
+                captures[2].value.GLenumVal, gRenderbufferMap[captures[3].value.GLuintVal]);
+            break;
         case angle::EntryPoint::GLFramebufferTexture:
             glFramebufferTexture(captures[0].value.GLenumVal, captures[1].value.GLenumVal,
                                  gTextureMap[captures[2].value.GLuintVal],
diff --git a/util/capture/trace_gles_loader_autogen.cpp b/util/capture/trace_gles_loader_autogen.cpp
index b3ea621fcecc4e71d45b5813d17dcd28ce0562ec..dfee47320d0bf5d292de2b21e2a45e0987eaf38f 100644
--- a/util/capture/trace_gles_loader_autogen.cpp
+++ b/util/capture/trace_gles_loader_autogen.cpp
@@ -632,6 +632,8 @@ ANGLE_TRACE_LOADER_EXPORT PFNGLSAMPLEMASKIANGLEPROC t_glSampleMaskiANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC t_glTexStorage2DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC
     t_glGetTranslatedShaderSourceANGLE;
+ANGLE_TRACE_LOADER_EXPORT PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    t_glBindMetalRasterizationRateMapANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLACQUIRETEXTURESANGLEPROC t_glAcquireTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLRELEASETEXTURESANGLEPROC t_glReleaseTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC t_glBindUniformLocationCHROMIUM;
@@ -881,6 +883,8 @@ ANGLE_TRACE_LOADER_EXPORT PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC
     t_glTextureFoveationParametersQCOM;
 ANGLE_TRACE_LOADER_EXPORT PFNGLENDTILINGQCOMPROC t_glEndTilingQCOM;
 ANGLE_TRACE_LOADER_EXPORT PFNGLSTARTTILINGQCOMPROC t_glStartTilingQCOM;
+ANGLE_TRACE_LOADER_EXPORT PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    t_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_TRACE_LOADER_EXPORT PFNGLBLENDEQUATIONOESPROC t_glBlendEquationOES;
 ANGLE_TRACE_LOADER_EXPORT PFNGLDRAWTEXFOESPROC t_glDrawTexfOES;
 ANGLE_TRACE_LOADER_EXPORT PFNGLDRAWTEXFVOESPROC t_glDrawTexfvOES;
@@ -1852,6 +1856,9 @@ void LoadTraceGLES(LoadProc loadProc)
         loadProc("glTexStorage2DMultisampleANGLE"));
     t_glGetTranslatedShaderSourceANGLE = reinterpret_cast<PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC>(
         loadProc("glGetTranslatedShaderSourceANGLE"));
+    t_glBindMetalRasterizationRateMapANGLE =
+        reinterpret_cast<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>(
+            loadProc("glBindMetalRasterizationRateMapANGLE"));
     t_glAcquireTexturesANGLE =
         reinterpret_cast<PFNGLACQUIRETEXTURESANGLEPROC>(loadProc("glAcquireTexturesANGLE"));
     t_glReleaseTexturesANGLE =
@@ -2283,6 +2290,9 @@ void LoadTraceGLES(LoadProc loadProc)
         loadProc("glTextureFoveationParametersQCOM"));
     t_glEndTilingQCOM   = reinterpret_cast<PFNGLENDTILINGQCOMPROC>(loadProc("glEndTilingQCOM"));
     t_glStartTilingQCOM = reinterpret_cast<PFNGLSTARTTILINGQCOMPROC>(loadProc("glStartTilingQCOM"));
+    t_glFramebufferResolveRenderbufferWEBKIT =
+        reinterpret_cast<PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC>(
+            loadProc("glFramebufferResolveRenderbufferWEBKIT"));
     t_glBlendEquationOES =
         reinterpret_cast<PFNGLBLENDEQUATIONOESPROC>(loadProc("glBlendEquationOES"));
     t_glDrawTexfOES  = reinterpret_cast<PFNGLDRAWTEXFOESPROC>(loadProc("glDrawTexfOES"));
diff --git a/util/capture/trace_gles_loader_autogen.h b/util/capture/trace_gles_loader_autogen.h
index dede1c17482e47327bc8e1c66ee895d1399dd7a2..25679eda93dce0705fffc114641c87eae4efcace 100644
--- a/util/capture/trace_gles_loader_autogen.h
+++ b/util/capture/trace_gles_loader_autogen.h
@@ -597,6 +597,7 @@
 #define glSampleMaskiANGLE t_glSampleMaskiANGLE
 #define glTexStorage2DMultisampleANGLE t_glTexStorage2DMultisampleANGLE
 #define glGetTranslatedShaderSourceANGLE t_glGetTranslatedShaderSourceANGLE
+#define glBindMetalRasterizationRateMapANGLE t_glBindMetalRasterizationRateMapANGLE
 #define glAcquireTexturesANGLE t_glAcquireTexturesANGLE
 #define glReleaseTexturesANGLE t_glReleaseTexturesANGLE
 #define glBindUniformLocationCHROMIUM t_glBindUniformLocationCHROMIUM
@@ -830,6 +831,7 @@
 #define glTextureFoveationParametersQCOM t_glTextureFoveationParametersQCOM
 #define glEndTilingQCOM t_glEndTilingQCOM
 #define glStartTilingQCOM t_glStartTilingQCOM
+#define glFramebufferResolveRenderbufferWEBKIT t_glFramebufferResolveRenderbufferWEBKIT
 #define glBlendEquationOES t_glBlendEquationOES
 #define glDrawTexfOES t_glDrawTexfOES
 #define glDrawTexfvOES t_glDrawTexfvOES
@@ -1521,6 +1523,8 @@ ANGLE_TRACE_LOADER_EXPORT extern PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC
     t_glTexStorage2DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC
     t_glGetTranslatedShaderSourceANGLE;
+ANGLE_TRACE_LOADER_EXPORT extern PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    t_glBindMetalRasterizationRateMapANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLACQUIRETEXTURESANGLEPROC t_glAcquireTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLRELEASETEXTURESANGLEPROC t_glReleaseTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC
@@ -1787,6 +1791,8 @@ ANGLE_TRACE_LOADER_EXPORT extern PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC
     t_glTextureFoveationParametersQCOM;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLENDTILINGQCOMPROC t_glEndTilingQCOM;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLSTARTTILINGQCOMPROC t_glStartTilingQCOM;
+ANGLE_TRACE_LOADER_EXPORT extern PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    t_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLBLENDEQUATIONOESPROC t_glBlendEquationOES;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLDRAWTEXFOESPROC t_glDrawTexfOES;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLDRAWTEXFVOESPROC t_glDrawTexfvOES;
diff --git a/util/capture/trace_interpreter_autogen.cpp b/util/capture/trace_interpreter_autogen.cpp
index 5d1dd539b0dff80fd976f420a5a34ff18b68b403..650e5f596f59a628864b8bca293bcba10f655979 100644
--- a/util/capture/trace_interpreter_autogen.cpp
+++ b/util/capture/trace_interpreter_autogen.cpp
@@ -910,6 +910,13 @@ CallCapture ParseCallCapture(const Token &nameToken,
             paramTokens, strings);
         return CallCapture(EntryPoint::GLBindImageTexture, std::move(params));
     }
+    if (strcmp(nameToken, "glBindMetalRasterizationRateMapANGLE") == 0)
+    {
+        ParamBuffer params =
+            ParseParameters<std::remove_pointer<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>::type>(
+                paramTokens, strings);
+        return CallCapture(EntryPoint::GLBindMetalRasterizationRateMapANGLE, std::move(params));
+    }
     if (strcmp(nameToken, "glBindProgramPipeline") == 0)
     {
         ParamBuffer params =
@@ -2310,6 +2317,13 @@ CallCapture ParseCallCapture(const Token &nameToken,
                 paramTokens, strings);
         return CallCapture(EntryPoint::GLFramebufferRenderbufferOES, std::move(params));
     }
+    if (strcmp(nameToken, "glFramebufferResolveRenderbufferWEBKIT") == 0)
+    {
+        ParamBuffer params = ParseParameters<
+            std::remove_pointer<PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC>::type>(paramTokens,
+                                                                                      strings);
+        return CallCapture(EntryPoint::GLFramebufferResolveRenderbufferWEBKIT, std::move(params));
+    }
     if (strcmp(nameToken, "glFramebufferTexture") == 0)
     {
         ParamBuffer params =
diff --git a/util/gles_loader_autogen.cpp b/util/gles_loader_autogen.cpp
index b8e0123a75adaf27cab67e114cfc6b348d8890f2..8d80a45bbdc818d22c7db539e4668e8f0a67a5a8 100644
--- a/util/gles_loader_autogen.cpp
+++ b/util/gles_loader_autogen.cpp
@@ -609,6 +609,8 @@ ANGLE_UTIL_EXPORT PFNGLGETMULTISAMPLEFVANGLEPROC l_glGetMultisamplefvANGLE;
 ANGLE_UTIL_EXPORT PFNGLSAMPLEMASKIANGLEPROC l_glSampleMaskiANGLE;
 ANGLE_UTIL_EXPORT PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC l_glTexStorage2DMultisampleANGLE;
 ANGLE_UTIL_EXPORT PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC l_glGetTranslatedShaderSourceANGLE;
+ANGLE_UTIL_EXPORT PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    l_glBindMetalRasterizationRateMapANGLE;
 ANGLE_UTIL_EXPORT PFNGLACQUIRETEXTURESANGLEPROC l_glAcquireTexturesANGLE;
 ANGLE_UTIL_EXPORT PFNGLRELEASETEXTURESANGLEPROC l_glReleaseTexturesANGLE;
 ANGLE_UTIL_EXPORT PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC l_glBindUniformLocationCHROMIUM;
@@ -850,6 +852,8 @@ ANGLE_UTIL_EXPORT PFNGLSHADINGRATEQCOMPROC l_glShadingRateQCOM;
 ANGLE_UTIL_EXPORT PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC l_glTextureFoveationParametersQCOM;
 ANGLE_UTIL_EXPORT PFNGLENDTILINGQCOMPROC l_glEndTilingQCOM;
 ANGLE_UTIL_EXPORT PFNGLSTARTTILINGQCOMPROC l_glStartTilingQCOM;
+ANGLE_UTIL_EXPORT PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    l_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_UTIL_EXPORT PFNGLBLENDEQUATIONOESPROC l_glBlendEquationOES;
 ANGLE_UTIL_EXPORT PFNGLDRAWTEXFOESPROC l_glDrawTexfOES;
 ANGLE_UTIL_EXPORT PFNGLDRAWTEXFVOESPROC l_glDrawTexfvOES;
@@ -1820,6 +1824,9 @@ void LoadUtilGLES(LoadProc loadProc)
         loadProc("glTexStorage2DMultisampleANGLE"));
     l_glGetTranslatedShaderSourceANGLE = reinterpret_cast<PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC>(
         loadProc("glGetTranslatedShaderSourceANGLE"));
+    l_glBindMetalRasterizationRateMapANGLE =
+        reinterpret_cast<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>(
+            loadProc("glBindMetalRasterizationRateMapANGLE"));
     l_glAcquireTexturesANGLE =
         reinterpret_cast<PFNGLACQUIRETEXTURESANGLEPROC>(loadProc("glAcquireTexturesANGLE"));
     l_glReleaseTexturesANGLE =
@@ -2251,6 +2258,9 @@ void LoadUtilGLES(LoadProc loadProc)
         loadProc("glTextureFoveationParametersQCOM"));
     l_glEndTilingQCOM   = reinterpret_cast<PFNGLENDTILINGQCOMPROC>(loadProc("glEndTilingQCOM"));
     l_glStartTilingQCOM = reinterpret_cast<PFNGLSTARTTILINGQCOMPROC>(loadProc("glStartTilingQCOM"));
+    l_glFramebufferResolveRenderbufferWEBKIT =
+        reinterpret_cast<PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC>(
+            loadProc("glFramebufferResolveRenderbufferWEBKIT"));
     l_glBlendEquationOES =
         reinterpret_cast<PFNGLBLENDEQUATIONOESPROC>(loadProc("glBlendEquationOES"));
     l_glDrawTexfOES  = reinterpret_cast<PFNGLDRAWTEXFOESPROC>(loadProc("glDrawTexfOES"));
diff --git a/util/gles_loader_autogen.h b/util/gles_loader_autogen.h
index 6989307cb6c4eea5f25701dfbe33a7e498fc24ae..86fe91cd58e3abdfe00626eb7b485ec921884a6b 100644
--- a/util/gles_loader_autogen.h
+++ b/util/gles_loader_autogen.h
@@ -597,6 +597,7 @@
 #define glSampleMaskiANGLE l_glSampleMaskiANGLE
 #define glTexStorage2DMultisampleANGLE l_glTexStorage2DMultisampleANGLE
 #define glGetTranslatedShaderSourceANGLE l_glGetTranslatedShaderSourceANGLE
+#define glBindMetalRasterizationRateMapANGLE l_glBindMetalRasterizationRateMapANGLE
 #define glAcquireTexturesANGLE l_glAcquireTexturesANGLE
 #define glReleaseTexturesANGLE l_glReleaseTexturesANGLE
 #define glBindUniformLocationCHROMIUM l_glBindUniformLocationCHROMIUM
@@ -830,6 +831,7 @@
 #define glTextureFoveationParametersQCOM l_glTextureFoveationParametersQCOM
 #define glEndTilingQCOM l_glEndTilingQCOM
 #define glStartTilingQCOM l_glStartTilingQCOM
+#define glFramebufferResolveRenderbufferWEBKIT l_glFramebufferResolveRenderbufferWEBKIT
 #define glBlendEquationOES l_glBlendEquationOES
 #define glDrawTexfOES l_glDrawTexfOES
 #define glDrawTexfvOES l_glDrawTexfvOES
@@ -1486,6 +1488,8 @@ ANGLE_UTIL_EXPORT extern PFNGLGETMULTISAMPLEFVANGLEPROC l_glGetMultisamplefvANGL
 ANGLE_UTIL_EXPORT extern PFNGLSAMPLEMASKIANGLEPROC l_glSampleMaskiANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC l_glTexStorage2DMultisampleANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC l_glGetTranslatedShaderSourceANGLE;
+ANGLE_UTIL_EXPORT extern PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    l_glBindMetalRasterizationRateMapANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLACQUIRETEXTURESANGLEPROC l_glAcquireTexturesANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLRELEASETEXTURESANGLEPROC l_glReleaseTexturesANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC l_glBindUniformLocationCHROMIUM;
@@ -1728,6 +1732,8 @@ ANGLE_UTIL_EXPORT extern PFNGLSHADINGRATEQCOMPROC l_glShadingRateQCOM;
 ANGLE_UTIL_EXPORT extern PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC l_glTextureFoveationParametersQCOM;
 ANGLE_UTIL_EXPORT extern PFNGLENDTILINGQCOMPROC l_glEndTilingQCOM;
 ANGLE_UTIL_EXPORT extern PFNGLSTARTTILINGQCOMPROC l_glStartTilingQCOM;
+ANGLE_UTIL_EXPORT extern PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    l_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_UTIL_EXPORT extern PFNGLBLENDEQUATIONOESPROC l_glBlendEquationOES;
 ANGLE_UTIL_EXPORT extern PFNGLDRAWTEXFOESPROC l_glDrawTexfOES;
 ANGLE_UTIL_EXPORT extern PFNGLDRAWTEXFVOESPROC l_glDrawTexfvOES;
diff --git a/util/ios/ios_main.mm b/util/ios/ios_main.mm
index 6df44200413599cbee17741ac8d74380f694bdff..1c8cdb539081b41661c1d96b9058969fcba8ecc0 100644
--- a/util/ios/ios_main.mm
+++ b/util/ios/ios_main.mm
@@ -12,9 +12,9 @@
 #include <stdio.h>
 
 static int original_argc;
-static char **original_argv;
+static char *_Nullable *_Nullable original_argv = nullptr;
 
-int main(int argc, char **argv);
+int main(int argc, char *_Nullable *_Nullable argv);
 
 @interface AngleUtilAppDelegate : UIResponder <UIApplicationDelegate>
 
@@ -31,8 +31,8 @@ int main(int argc, char **argv);
     exit(main(original_argc, original_argv));
 }
 
-- (BOOL)application:(UIApplication *)application
-    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
+- (BOOL)application:(UIApplication *_Nonnull)application
+    didFinishLaunchingWithOptions:(NSDictionary *_Nullable)launchOptions
 {
     self.window                    = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
     self.window.rootViewController = [[UIViewController alloc] initWithNibName:nil bundle:nil];
@@ -49,7 +49,7 @@ int main(int argc, char **argv);
 
 @end
 
-extern "C" int ios_main(int argc, char **argv)
+extern "C" int ios_main(int argc, char *_Nonnull *_Nonnull argv)
 {
     original_argc = argc;
     original_argv = argv;
diff --git a/util/posix/test_utils_posix.cpp b/util/posix/test_utils_posix.cpp
index 27c4440ed7eece68bdd936f9e36f561e897291e9..c33dc73a9c5982f60a8c118793ab41d8538a94ed 100644
--- a/util/posix/test_utils_posix.cpp
+++ b/util/posix/test_utils_posix.cpp
@@ -354,7 +354,9 @@ void WriteDebugMessage(const char *format, ...)
 {
     va_list vararg;
     va_start(vararg, format);
+ANGLE_DISABLE_NONLITERAL_FORMAT_WARNING
     vfprintf(stderr, format, vararg);
+ANGLE_REENABLE_NONLITERAL_FORMAT_WARNING
     va_end(vararg);
 }
 
