// This file is automatically generated from CSSProperties.json by the process-css-properties.py script. Do not edit it.

#include "config.h"
#include "CSSPropertyParsing.h"

#include "CSSFunctionValue.h"
#include "CSSParserContext.h"
#include "CSSParserIdioms.h"
#include "CSSPropertyParser.h"
#include "CSSPropertyParserConsumer+Align.h"
#include "CSSPropertyParserConsumer+Anchor.h"
#include "CSSPropertyParserConsumer+AngleDefinitions.h"
#include "CSSPropertyParserConsumer+Animations.h"
#include "CSSPropertyParserConsumer+AppleVisualEffect.h"
#include "CSSPropertyParserConsumer+Attr.h"
#include "CSSPropertyParserConsumer+Background.h"
#include "CSSPropertyParserConsumer+Box.h"
#include "CSSPropertyParserConsumer+CSSPrimitiveValueResolver.h"
#include "CSSPropertyParserConsumer+Color.h"
#include "CSSPropertyParserConsumer+ColorAdjust.h"
#include "CSSPropertyParserConsumer+Content.h"
#include "CSSPropertyParserConsumer+CounterStyles.h"
#include "CSSPropertyParserConsumer+Display.h"
#include "CSSPropertyParserConsumer+Easing.h"
#include "CSSPropertyParserConsumer+Filter.h"
#include "CSSPropertyParserConsumer+Font.h"
#include "CSSPropertyParserConsumer+Grid.h"
#include "CSSPropertyParserConsumer+Ident.h"
#include "CSSPropertyParserConsumer+Image.h"
#include "CSSPropertyParserConsumer+Inline.h"
#include "CSSPropertyParserConsumer+Inset.h"
#include "CSSPropertyParserConsumer+IntegerDefinitions.h"
#include "CSSPropertyParserConsumer+LengthDefinitions.h"
#include "CSSPropertyParserConsumer+LengthPercentageDefinitions.h"
#include "CSSPropertyParserConsumer+List.h"
#include "CSSPropertyParserConsumer+Lists.h"
#include "CSSPropertyParserConsumer+Masking.h"
#include "CSSPropertyParserConsumer+Motion.h"
#include "CSSPropertyParserConsumer+NumberDefinitions.h"
#include "CSSPropertyParserConsumer+Overflow.h"
#include "CSSPropertyParserConsumer+Page.h"
#include "CSSPropertyParserConsumer+Percentage.h"
#include "CSSPropertyParserConsumer+PercentageDefinitions.h"
#include "CSSPropertyParserConsumer+Position.h"
#include "CSSPropertyParserConsumer+PositionTry.h"
#include "CSSPropertyParserConsumer+Primitives.h"
#include "CSSPropertyParserConsumer+ResolutionDefinitions.h"
#include "CSSPropertyParserConsumer+Ruby.h"
#include "CSSPropertyParserConsumer+SVG.h"
#include "CSSPropertyParserConsumer+ScrollSnap.h"
#include "CSSPropertyParserConsumer+Scrollbars.h"
#include "CSSPropertyParserConsumer+Shapes.h"
#include "CSSPropertyParserConsumer+Sizing.h"
#include "CSSPropertyParserConsumer+String.h"
#include "CSSPropertyParserConsumer+Syntax.h"
#include "CSSPropertyParserConsumer+TextDecoration.h"
#include "CSSPropertyParserConsumer+TimeDefinitions.h"
#include "CSSPropertyParserConsumer+Timeline.h"
#include "CSSPropertyParserConsumer+Transform.h"
#include "CSSPropertyParserConsumer+Transitions.h"
#include "CSSPropertyParserConsumer+UI.h"
#include "CSSPropertyParserConsumer+URL.h"
#include "CSSPropertyParserConsumer+ViewTransition.h"
#include "CSSPropertyParserConsumer+WillChange.h"
#include "CSSQuadValue.h"
#include "CSSTransformListValue.h"
#include "CSSValuePair.h"
#include "CSSValuePool.h"
#include "DeprecatedGlobalSettings.h"

namespace WebCore {

using namespace CSSPropertyParserHelpers;

static bool isKeywordValidForTestUsingSharedRule(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTestUsingSharedRuleExported(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTestUsingSharedRuleWithOverrideFunction(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithCommas(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#{2,3}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds { 2, 3 }, ListOptimization::None>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithCommasFixed(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#{2}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds { 2, 2 }, ListOptimization::None>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithCommasNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#{1,3}@(no-single-item-opt)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds { 1, 3 }, ListOptimization::None>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithCommasSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#{1,3}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds { 1, 3 }, ListOptimization::SingleValue>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpaces(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{2,3}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds { 2, 3 }, ListOptimization::None>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpacesFixed(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{2}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds { 2, 2 }, ListOptimization::None>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpacesNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{1,3}@(no-single-item-opt)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds { 1, 3 }, ListOptimization::None>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpacesSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{1,3}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds { 1, 3 }, ListOptimization::SingleValue>(range, consumeRepeatedTerm, context);
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpacesWithType(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{1,2}@(type=CSSValuePair)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, context);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, context);
        if (!term1) {
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpacesWithTypeWithDefaultPrevious(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, context);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, context);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestBoundedRepetitionWithSpacesWithTypeWithDefaultPreviousTwo(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{1,4}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, context);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, context);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        auto term2 = consumeRepeatedTerm(rangeCopy, context);
        if (!term2) {
            term2 = term1;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull());
        }
        auto term3 = consumeRepeatedTerm(rangeCopy, context);
        if (!term3) {
            term3 = term2;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull(), term3.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull(), term3.releaseNonNull());
    };
    return consumeBoundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionBoundedParameters(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo(<number>#{1,4})
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // <number>#{1,4}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 4 }>(range, consumeRepeatedTerm, context);
            };
            return consumeBoundedRepetition(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionFixedParameters(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo(<number>#{3})
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // <number>#{3}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 3, 3 }>(range, consumeRepeatedTerm, context);
            };
            return consumeBoundedRepetition(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionNoParameters(CSSParserTokenRange& range)
{
    // foo([  ])
    auto consumeFooFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
            // [  ]
            auto consumeMatchAllOrdered = [](CSSParserTokenRange& range) -> std::optional<CSSValueListBuilder> {
                CSSValueListBuilder list;
                return { WTFMove(list) };
            };
            return consumeMatchAllOrdered(args);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range);
}

static RefPtr<CSSValue> consumeTestFunctionParametersMatchAllAnyOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo([ <number> && <string> ])
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // [ <number> && <string> ]
            auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                RefPtr<CSSValue> value0; // <number>
                auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
                    auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                        // <number>
                        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                    };
                    if (value0)
                        return false;
                    value0 = consumeTerm0(range, context);
                    return !!value0;
                };
                RefPtr<CSSValue> value1; // <string>
                auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
                    auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                        // <string>
                        return consumeString(range);
                    };
                    if (value1)
                        return false;
                    value1 = consumeTerm1(range);
                    return !!value1;
                };
                for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
                    if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range))
                        continue;
                    break;
                }
                CSSValueListBuilder list;
                if (value0) // <number>
                    list.append(value0.releaseNonNull());
                else
                    return { };
                if (value1) // <string>
                    list.append(value1.releaseNonNull());
                else
                    return { };
                return { WTFMove(list) };
            };
            return consumeMatchAllAnyOrder(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionParametersMatchAllAnyOrderWithOptional(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo([ <number> && <string>? ])
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // [ <number> && <string>? ]
            auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                RefPtr<CSSValue> value0; // <number>
                auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
                    auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                        // <number>
                        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                    };
                    if (value0)
                        return false;
                    value0 = consumeTerm0(range, context);
                    return !!value0;
                };
                RefPtr<CSSValue> value1; // <string>?
                auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
                    auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                        // <string>
                        return consumeString(range);
                    };
                    if (value1)
                        return false;
                    value1 = consumeTerm1(range);
                    return !!value1;
                };
                for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
                    if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range))
                        continue;
                    break;
                }
                CSSValueListBuilder list;
                if (value0) // <number>
                    list.append(value0.releaseNonNull());
                else
                    return { };
                if (value1) // <string>?
                    list.append(value1.releaseNonNull());
                return { WTFMove(list) };
            };
            return consumeMatchAllAnyOrder(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionParametersMatchAllOrdered(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo([ <number> <string> ])
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // [ <number> <string> ]
            auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                };
                auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    // <string>
                    return consumeString(range);
                };
                CSSValueListBuilder list;
                // <number>
                auto value0 = consumeTerm0(range, context);
                if (value0)
                    list.append(value0.releaseNonNull());
                else
                    return { };
                // <string>
                auto value1 = consumeTerm1(range);
                if (value1)
                    list.append(value1.releaseNonNull());
                else
                    return { };
                return { WTFMove(list) };
            };
            return consumeMatchAllOrdered(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionParametersMatchAllOrderedWithOptional(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo([ <number> <string>? ])
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // [ <number> <string>? ]
            auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                };
                auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    // <string>
                    return consumeString(range);
                };
                CSSValueListBuilder list;
                // <number>
                auto value0 = consumeTerm0(range, context);
                if (value0)
                    list.append(value0.releaseNonNull());
                else
                    return { };
                // <string>?
                auto value1 = consumeTerm1(range);
                if (value1)
                    list.append(value1.releaseNonNull());
                return { WTFMove(list) };
            };
            return consumeMatchAllOrdered(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionParametersMatchOneOrMoreAnyOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo([ <number> || <string> ])
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // [ <number> || <string> ]
            auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                RefPtr<CSSValue> value0; // <number>
                auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
                    auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                        // <number>
                        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                    };
                    if (value0)
                        return false;
                    value0 = consumeTerm0(range, context);
                    return !!value0;
                };
                RefPtr<CSSValue> value1; // <string>
                auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
                    auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                        // <string>
                        return consumeString(range);
                    };
                    if (value1)
                        return false;
                    value1 = consumeTerm1(range);
                    return !!value1;
                };
                for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
                    if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range))
                        continue;
                    break;
                }
                CSSValueListBuilder list;
                if (value0) // <number>
                    list.append(value0.releaseNonNull());
                if (value1) // <string>
                    list.append(value1.releaseNonNull());
                if (list.isEmpty())
                    return { };
                return { WTFMove(list) };
            };
            return consumeMatchOneOrMoreAnyOrder(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionSingleParameter(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo(<number>)
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(args, context, { .parserMode = context.mode });
            };
            auto parameter = consumeParameter(args, context);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionSingleParameterMatchOne(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo([ <number> | <string> | bar | baz ])
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // bar | baz
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueBar:
                case CSSValueID::CSSValueBaz:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number>
                if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(args, context, { .parserMode = context.mode }))
                    return result;
                // <string>
                return consumeString(args);
            };
            auto parameter = consumeParameter(args, context);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionSingleParameterOptional(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo(<number>?)
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(args, context, { .parserMode = context.mode });
            };
            auto parameter = consumeParameter(args, context);
            if (!parameter)
                return CSSValueListBuilder { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionUnboundedParametersNoMin(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo(<number>#)
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // <number>#
            auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds::minimumOf(1)>(range, consumeRepeatedTerm, context);
            };
            return consumeUnboundedRepetition(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestFunctionUnboundedParametersWithMinimum(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // foo(<number>#{2,})
    auto consumeFooFunction = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
            // <number>#{2,}
            auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds::minimumOf(2)>(range, consumeRepeatedTerm, context);
            };
            return consumeUnboundedRepetition(args, context);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueFoo)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, context);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueFoo, WTFMove(*result));
    };
    return consumeFooFunction(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident> && <length> ]
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <number>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, context);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <custom-ident>
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // <length>
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range, context);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (!value0) // <number>
            return { };
        if (!value1) // <custom-ident>
            return { };
        if (!value2) // <length>
            return { };
        return CSSValueList::createSpaceSeparated(value0.releaseNonNull(), value1.releaseNonNull(), value2.releaseNonNull());
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithOptional(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident>? && <length> ]
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <number>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, context);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <custom-ident>?
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // <length>
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range, context);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // <number>
            list.append(value0.releaseNonNull());
        else
            return { };
        if (value1) // <custom-ident>?
            list.append(value1.releaseNonNull());
        if (value2) // <length>
            list.append(value2.releaseNonNull());
        else
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithOptionalNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident>? && <length>? ]@(no-single-item-opt)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <number>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, context);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <custom-ident>?
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // <length>?
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range, context);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // <number>
            list.append(value0.releaseNonNull());
        else
            return { };
        if (value1) // <custom-ident>?
            list.append(value1.releaseNonNull());
        if (value2) // <length>?
            list.append(value2.releaseNonNull());
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithOptionalSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident>? && <length>? ]
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <number>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, context);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <custom-ident>?
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // <length>?
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range, context);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // <number>
            list.append(value0.releaseNonNull());
        else
            return { };
        if (value1) // <custom-ident>?
            list.append(value1.releaseNonNull());
        if (value2) // <length>?
            list.append(value2.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]);
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithOptionalWithPreserveOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident>? && <length>? ]@(preserve-order)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // <number>
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // <custom-ident>?
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // <length>?
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (!consumedValue0) // <number>
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]);
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithOptionalWithPreserveOrderNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident>? && <length>? ]@(preserve-order no-single-item-opt)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // <number>
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // <custom-ident>?
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // <length>?
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (!consumedValue0) // <number>
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithPreserveOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident> && <length> ]@(preserve-order)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // <number>
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // <custom-ident>
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // <length>
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (!consumedValue0) // <number>
            return { };
        if (!consumedValue1) // <custom-ident>
            return { };
        if (!consumedValue2) // <length>
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllAnyOrderWithPreserveOrderNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> && <custom-ident> && <length> ]@(preserve-order no-single-item-opt)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // <number>
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // <custom-ident>
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // <length>
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (!consumedValue0) // <number>
            return { };
        if (!consumedValue1) // <custom-ident>
            return { };
        if (!consumedValue2) // <length>
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllOrdered(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> <custom-ident> <length> ]
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <length>
            return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
        };
        // <number>
        auto value0 = consumeTerm0(range, context);
        if (!value0)
            return { };
        // <custom-ident>
        auto value1 = consumeTerm1(range);
        if (!value1)
            return { };
        // <length>
        auto value2 = consumeTerm2(range, context);
        if (!value2)
            return { };
        return CSSValueList::createSpaceSeparated(value0.releaseNonNull(), value1.releaseNonNull(), value2.releaseNonNull());
    };
    return consumeMatchAllOrdered(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllOrderedWithOptional(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> <custom-ident>? <length> ]
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <length>
            return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // <number>
        auto value0 = consumeTerm0(range, context);
        if (value0)
            list.append(value0.releaseNonNull());
        else
            return { };
        // <custom-ident>?
        auto value1 = consumeTerm1(range);
        if (value1)
            list.append(value1.releaseNonNull());
        // <length>
        auto value2 = consumeTerm2(range, context);
        if (value2)
            list.append(value2.releaseNonNull());
        else
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllOrdered(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllOrderedWithOptionalNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> <custom-ident>? <length>? ]@(no-single-item-opt)
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <length>
            return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // <number>
        auto value0 = consumeTerm0(range, context);
        if (value0)
            list.append(value0.releaseNonNull());
        else
            return { };
        // <custom-ident>?
        auto value1 = consumeTerm1(range);
        if (value1)
            list.append(value1.releaseNonNull());
        // <length>?
        auto value2 = consumeTerm2(range, context);
        if (value2)
            list.append(value2.releaseNonNull());
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllOrdered(range, context);
}

static RefPtr<CSSValue> consumeTestMatchAllOrderedWithOptionalSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> <custom-ident>? <length>? ]
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <length>
            return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // <number>
        auto value0 = consumeTerm0(range, context);
        if (value0)
            list.append(value0.releaseNonNull());
        else
            return { };
        // <custom-ident>?
        auto value1 = consumeTerm1(range);
        if (value1)
            list.append(value1.releaseNonNull());
        // <length>?
        auto value2 = consumeTerm2(range, context);
        if (value2)
            list.append(value2.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]);
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllOrdered(range, context);
}

static RefPtr<CSSValue> consumeTestMatchOneOrMoreAnyOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> || <custom-ident> || <length> ]
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <number>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, context);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <custom-ident>
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // <length>
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range, context);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // <number>
            list.append(value0.releaseNonNull());
        if (value1) // <custom-ident>
            list.append(value1.releaseNonNull());
        if (value2) // <length>
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]);
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchOneOrMoreAnyOrderNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> || <custom-ident> || <length> ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <number>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, context);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <custom-ident>
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // <length>
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range, context);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // <number>
            list.append(value0.releaseNonNull());
        if (value1) // <custom-ident>
            list.append(value1.releaseNonNull());
        if (value2) // <length>
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchOneOrMoreAnyOrderWithPreserveOrder(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> || <custom-ident> || <length> ]@(preserve-order)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // <number>
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // <custom-ident>
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // <length>
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]);
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestMatchOneOrMoreAnyOrderWithPreserveOrderNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // [ <number> || <custom-ident> || <length> ]@(preserve-order no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // <number>
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <number>
                return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // <custom-ident>
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // <length>
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range, const CSSParserContext& context) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow });
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range, context)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, context) || tryConsumeTerm1(range) || tryConsumeTerm2(range, context))
                continue;
            break;
        }
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range, context);
}

static RefPtr<CSSValue> consumeTestNumericValueRange(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number [-inf,-10]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<CSS::Range{-CSS::Range::infinity, -10}>>::consumeAndResolve(range, context, { .parserMode = context.mode }))
        return result;
    // <length [0,inf]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow }))
        return result;
    // <angle [-90,90]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Angle<CSS::Range{-90, 90}>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Forbid }))
        return result;
    // <percentage [1,100]>
    return CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{1, 100}>>::consumeAndResolve(range, context, { .parserMode = context.mode });
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithCommasWithMin(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#{2,}
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(2), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithCommasWithMinNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithCommasWithMinSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithSpacesNoMin(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>*
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(0), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithSpacesNoMinNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>*@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(0), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithSpacesWithMin(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>{2,}
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(2), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithSpacesWithMinNoSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>+@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUnboundedRepetitionWithSpacesWithMinSingleItemOpt(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <number>+
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, const CSSParserContext& context) -> RefPtr<CSSValue> {
            // <number>
            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, context);
    };
    return consumeUnboundedRepetition(range, context);
}

static RefPtr<CSSValue> consumeTestUsingSharedRule(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForTestUsingSharedRule))
        return result;
    // <number>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode }))
        return result;
    // <percentage>
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
}

static RefPtr<CSSValue> consumeTestUsingSharedRuleExported(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForTestUsingSharedRuleExported))
        return result;
    // <length>
    if (auto result = CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow }))
        return result;
    // <string>
    return consumeString(range);
}

static RefPtr<CSSValue> consumeTestUsingSharedRuleWithOverrideFunction(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForTestUsingSharedRuleWithOverrideFunction))
        return result;
    // <shared-rule-with-override-function-override-function>
    return consumeFunctionForSharedRule(range, context);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSharedRuleExported(CSSParserTokenRange& range, const CSSParserContext& context)
{
    // <length>
    if (auto result = CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow }))
        return result;
    // <string>
    return consumeString(range);
}

RefPtr<CSSValue> CSSPropertyParsing::parseStyleProperty(CSSParserTokenRange& range, CSSPropertyID id, CSSPropertyID currentShorthand, const CSSParserContext& context)
{
    if (!isExposed(id, context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyTestTopPriority:
    case CSSPropertyID::CSSPropertyTestHighPriority:
    case CSSPropertyID::CSSPropertyTestAnimationWrapper:
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways:
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationThreadedOnly:
    case CSSPropertyID::CSSPropertyTestProperty:
    case CSSPropertyID::CSSPropertyTestSettingsOne:
    case CSSPropertyID::CSSPropertyTestSinkPriority:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithCommas:
        return consumeTestBoundedRepetitionWithCommas(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithCommasFixed:
        return consumeTestBoundedRepetitionWithCommasFixed(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithCommasNoSingleItemOpt:
        return consumeTestBoundedRepetitionWithCommasNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithCommasSingleItemOpt:
        return consumeTestBoundedRepetitionWithCommasSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpaces:
        return consumeTestBoundedRepetitionWithSpaces(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpacesFixed:
        return consumeTestBoundedRepetitionWithSpacesFixed(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpacesNoSingleItemOpt:
        return consumeTestBoundedRepetitionWithSpacesNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpacesSingleItemOpt:
        return consumeTestBoundedRepetitionWithSpacesSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpacesWithType:
        return consumeTestBoundedRepetitionWithSpacesWithType(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpacesWithTypeWithDefaultPrevious:
        return consumeTestBoundedRepetitionWithSpacesWithTypeWithDefaultPrevious(range, context);
    case CSSPropertyID::CSSPropertyTestBoundedRepetitionWithSpacesWithTypeWithDefaultPreviousTwo:
        return consumeTestBoundedRepetitionWithSpacesWithTypeWithDefaultPreviousTwo(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionBoundedParameters:
        return consumeTestFunctionBoundedParameters(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionFixedParameters:
        return consumeTestFunctionFixedParameters(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionNoParameters:
        return consumeTestFunctionNoParameters(range);
    case CSSPropertyID::CSSPropertyTestFunctionParametersMatchAllAnyOrder:
        return consumeTestFunctionParametersMatchAllAnyOrder(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionParametersMatchAllAnyOrderWithOptional:
        return consumeTestFunctionParametersMatchAllAnyOrderWithOptional(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionParametersMatchAllOrdered:
        return consumeTestFunctionParametersMatchAllOrdered(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionParametersMatchAllOrderedWithOptional:
        return consumeTestFunctionParametersMatchAllOrderedWithOptional(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionParametersMatchOneOrMoreAnyOrder:
        return consumeTestFunctionParametersMatchOneOrMoreAnyOrder(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionSingleParameter:
        return consumeTestFunctionSingleParameter(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionSingleParameterMatchOne:
        return consumeTestFunctionSingleParameterMatchOne(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionSingleParameterOptional:
        return consumeTestFunctionSingleParameterOptional(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionUnboundedParametersNoMin:
        return consumeTestFunctionUnboundedParametersNoMin(range, context);
    case CSSPropertyID::CSSPropertyTestFunctionUnboundedParametersWithMinimum:
        return consumeTestFunctionUnboundedParametersWithMinimum(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrder:
        return consumeTestMatchAllAnyOrder(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithOptional:
        return consumeTestMatchAllAnyOrderWithOptional(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithOptionalNoSingleItemOpt:
        return consumeTestMatchAllAnyOrderWithOptionalNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithOptionalSingleItemOpt:
        return consumeTestMatchAllAnyOrderWithOptionalSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithOptionalWithPreserveOrder:
        return consumeTestMatchAllAnyOrderWithOptionalWithPreserveOrder(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithOptionalWithPreserveOrderNoSingleItemOpt:
        return consumeTestMatchAllAnyOrderWithOptionalWithPreserveOrderNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithPreserveOrder:
        return consumeTestMatchAllAnyOrderWithPreserveOrder(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllAnyOrderWithPreserveOrderNoSingleItemOpt:
        return consumeTestMatchAllAnyOrderWithPreserveOrderNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllOrdered:
        return consumeTestMatchAllOrdered(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllOrderedWithOptional:
        return consumeTestMatchAllOrderedWithOptional(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllOrderedWithOptionalNoSingleItemOpt:
        return consumeTestMatchAllOrderedWithOptionalNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchAllOrderedWithOptionalSingleItemOpt:
        return consumeTestMatchAllOrderedWithOptionalSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchOneOrMoreAnyOrder:
        return consumeTestMatchOneOrMoreAnyOrder(range, context);
    case CSSPropertyID::CSSPropertyTestMatchOneOrMoreAnyOrderNoSingleItemOpt:
        return consumeTestMatchOneOrMoreAnyOrderNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestMatchOneOrMoreAnyOrderWithPreserveOrder:
        return consumeTestMatchOneOrMoreAnyOrderWithPreserveOrder(range, context);
    case CSSPropertyID::CSSPropertyTestMatchOneOrMoreAnyOrderWithPreserveOrderNoSingleItemOpt:
        return consumeTestMatchOneOrMoreAnyOrderWithPreserveOrderNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestNumericValueRange:
        return consumeTestNumericValueRange(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithCommasWithMin:
        return consumeTestUnboundedRepetitionWithCommasWithMin(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithCommasWithMinNoSingleItemOpt:
        return consumeTestUnboundedRepetitionWithCommasWithMinNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithCommasWithMinSingleItemOpt:
        return consumeTestUnboundedRepetitionWithCommasWithMinSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithSpacesNoMin:
        return consumeTestUnboundedRepetitionWithSpacesNoMin(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithSpacesNoMinNoSingleItemOpt:
        return consumeTestUnboundedRepetitionWithSpacesNoMinNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithSpacesWithMin:
        return consumeTestUnboundedRepetitionWithSpacesWithMin(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithSpacesWithMinNoSingleItemOpt:
        return consumeTestUnboundedRepetitionWithSpacesWithMinNoSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestUnboundedRepetitionWithSpacesWithMinSingleItemOpt:
        return consumeTestUnboundedRepetitionWithSpacesWithMinSingleItemOpt(range, context);
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
        return consumeTestUsingSharedRule(range, context);
    case CSSPropertyID::CSSPropertyTestUsingSharedRuleExported:
        return consumeTestUsingSharedRuleExported(range, context);
    case CSSPropertyID::CSSPropertyTestUsingSharedRuleWithOverrideFunction:
        return consumeTestUsingSharedRuleWithOverrideFunction(range, context);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForStyleProperty(CSSPropertyID id, CSSValueID keyword, const CSSParserContext&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
        return isKeywordValidForTestUsingSharedRule(keyword);
    case CSSPropertyID::CSSPropertyTestUsingSharedRuleExported:
        return isKeywordValidForTestUsingSharedRuleExported(keyword);
    case CSSPropertyID::CSSPropertyTestUsingSharedRuleWithOverrideFunction:
        return isKeywordValidForTestUsingSharedRuleWithOverrideFunction(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleStyleProperty(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
    case CSSPropertyID::CSSPropertyTestUsingSharedRuleExported:
    case CSSPropertyID::CSSPropertyTestUsingSharedRuleWithOverrideFunction:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parseFirstAtRuleDescriptor(CSSParserTokenRange& range, CSSPropertyID id, const CSSParserContext& context)
{
    if (!isExposed(id, context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForFirstAtRuleDescriptor(CSSPropertyID, CSSValueID, const CSSParserContext&)
{
    return false;
}

bool CSSPropertyParsing::isKeywordFastPathEligibleFirstAtRuleDescriptor(CSSPropertyID)
{
    return false;
}

RefPtr<CSSValue> CSSPropertyParsing::parseSecondAtRuleDescriptor(CSSParserTokenRange& range, CSSPropertyID id, const CSSParserContext& context)
{
    if (!isExposed(id, context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForSecondDescriptor:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForSecondAtRuleDescriptor(CSSPropertyID, CSSValueID, const CSSParserContext&)
{
    return false;
}

bool CSSPropertyParsing::isKeywordFastPathEligibleSecondAtRuleDescriptor(CSSPropertyID)
{
    return false;
}

} // namespace WebCore

