#!/usr/bin/env python3 -u

# Copyright (C) 2025 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import subprocess
import argparse
import os
import shlex

# Usage Examples:
# ./Tools/Scripts/compare-inlining -v -a <BUILD_A_PATH> -b <BUILD_B_PATH> --test <SINGLE_TEST_PATH> --filter FTL
# ./Tools/Scripts/compare-inlining -v -a <BUILD_A_PATH> -b <BUILD_B_PATH> --test "-e \"testList='crypto'\" cli.js" --cwd <BENCHMARK_WORKING_DIR> --filter FTL

def run_jsc_and_capture(verbose, build_path, jsc_args, cwd):
    jsc_binary = os.path.join(build_path, "jsc")
    env = os.environ.copy()
    env["DYLD_FRAMEWORK_PATH"] = build_path

    required_options = [
        "--alwaysComputeHash=1",
        "--useConcurrentJIT=0",
        "--printEachDFGFTLInlineCall=1"
    ]

    command = [jsc_binary] + jsc_args + required_options

    if verbose:
        def human_friendly_quote(arg):
            if " " in arg or "'" in arg or '"' in arg:
                return f'"{arg}"'
            return arg

        print("\nRunning command:")
        print("  cwd:", cwd)
        print("  cmd:", " ".join(human_friendly_quote(arg) for arg in command))
        print("  env:")
        for key, value in sorted(env.items()):
            if key in ["DYLD_FRAMEWORK_PATH"] or key.startswith("JSC") or key.startswith("WEBKIT"):
                print(f"    {key}={value}")

    try:
        result = subprocess.run(
            command,
            env=env,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            check=True
        )

        if verbose:
            print("Command completed successfully.")
        return result.stdout.splitlines()

    except subprocess.CalledProcessError as e:
        print("Command failed with return code:", e.returncode)
        print("Output:")
        print(e.stdout)
        return []

def extract_inline_lines(lines, filter_type=None):
    result = set()
    for line in lines:
        line = line.strip()
        if "[InlineCall]" not in line:
            continue
        if filter_type:
            prefix = f"[InlineCall] JITType: {filter_type} "
            if not line.startswith(prefix):
                continue
        result.add(line)
    return result

def compare_sets(set_a, set_b):
    removed = sorted(set_a - set_b)
    added = sorted(set_b - set_a)
    return removed, added

def main():
    parser = argparse.ArgumentParser(description="Compare JIT inlining output between two JSC builds.")
    parser.add_argument('-a', '--build-a', required=True, help="Path to build A")
    parser.add_argument('-b', '--build-b', required=True, help="Path to build B")
    parser.add_argument('--test', required=True, help="Test file or CLI args (quoted)")
    parser.add_argument('--cwd', default='.', help="Working directory (default: current directory)")
    parser.add_argument('-v', '--verbose', action='store_true', help="Enable verbose output")
    parser.add_argument('--filter', choices=['FTL', 'DFG', 'Baseline', 'LLInt', 'Host', 'None'], help="Only compare inlining entries with this JITType")

    args = parser.parse_args()
    jsc_args = shlex.split(args.test)

    print("Running build A...")
    output_a = run_jsc_and_capture(args.verbose, args.build_a, jsc_args, args.cwd)
    set_a = extract_inline_lines(output_a, args.filter)

    print("Running build B...")
    output_b = run_jsc_and_capture(args.verbose, args.build_b, jsc_args, args.cwd)
    set_b = extract_inline_lines(output_b, args.filter)

    if args.verbose:
        print("\nInline logs from Build A:")
        for line in sorted(set_a):
            print("  A:", line)
        print("\nInline logs from Build B:")
        for line in sorted(set_b):
            print("  B:", line)

    removed, added = compare_sets(set_a, set_b)

    print("\nInlining REMOVED from A to B:")
    if removed:
        for line in removed:
            print("  -", line)
    else:
        print("  None")

    print("\nInlining ADDED from A to B:")
    if added:
        for line in added:
            print("  +", line)
    else:
        print("  None")

if __name__ == "__main__":
    main()
