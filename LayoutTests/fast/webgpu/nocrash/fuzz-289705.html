<style>
  :root { background: #102030e0; color: #99ddbbcc; font-size: 15px; }
</style>
<script id="shared">
function log(a)
{
}

</script>
<script>
globalThis.testRunner?.waitUntilDone();

async function window0() {
let adapter0 = await navigator.gpu.requestAdapter({});
let device0 = await adapter0.requestDevice({
  requiredFeatures: [
    'depth32float-stencil8',
    'texture-compression-etc2',
    'texture-compression-astc',
    'indirect-first-instance',
    'shader-f16',
    'rg11b10ufloat-renderable',
    'bgra8unorm-storage',
    'float32-blendable',
    'timestamp-query',
  ],
  requiredLimits: {
    maxTextureDimension2D: 8192,
    minUniformBufferOffsetAlignment: 256,
    maxUniformBufferBindingSize: 441363,
    maxStorageBufferBindingSize: 216540544,
  },
});
// START
 }
        async function window1() {
        let buffer47 = device0.createBuffer0;
        try {
       }
        catch {
      }
        }
        async function window2() {
        let adapter1 = await navigator.gpu.requestAdapter(
       );
        let device0 = await adapter1.requestDevice(
       );
        let veryExplicitBindGroupLayout0 = device0.createBindGroupLayout({
         entries: [     {
            binding: 427,       visibility: GPUShaderStage.FRAGMENT,       texture: {
     viewDimension: '2d', sampleType: 'uint', multisampled: false }
     ,     }
      ,   ], }
       );
        let shaderModule0 = device0.createShaderModule({
         code: ` requires readonly_and_readwrite_storage_textures;
       /* zero global variables used */fn fn0(a0: VertexInput0, a1: VertexInput0, a2: ptr<private, VertexInput0>) -> VertexInput0 {
        var out: VertexInput0;
        return out;
      }
       fn unconst_f32(v: f32) -> f32 {
      return v;
      }
       struct VertexInput0 {
        @location(9) @interpolate(flat) location_9: vec2u, }
       fn unconst_f16(v: f16) -> f16 {
      return v;
      }
       struct VertexInput1 {
        @location(8) location_8: vec4f,   @location(5) location_5: f16,   @location(0) location_0: vec2f,   @builtin(vertex_index) vertex_index: u32, }
       /* zero global variables used */@vertex fn vertex0(@location(4) location_4: i32, a1: VertexInput0, @location(12) @interpolate(linear, centroid) location_12: vec4h, a3: VertexInput1) -> @builtin(position) vec4f {
        var out: vec4f;
        return out;
      }
      `, }
       );
        let shaderModule1 = device0.createShaderModule({
         code: ` diagnostic(info, xyz);
       fn unconst_bool(v: bool) -> bool {
      return v;
      }
       struct FragmentOutput1 {
        @location(6) location_6: vec2u,   @location(0) location_0: vec4u, }
       fn unconst_i32(v: i32) -> i32 {
      return v;
      }
       override override3: f16;
       fn unconst_f32(v: f32) -> f32 {
      return v;
      }
       @group(0) @binding(427) var tex1: texture_2d<u32>;
       /* zero global variables used */fn fn0() {
      }
       struct T6 {
        @size(224) f0: vec2f, }
       fn unconst_u32(v: u32) -> u32 {
      return v;
      }
       /* used global variables: tex1 */@fragment fn fragment1(@builtin(front_facing) front_facing: bool, @builtin(sample_index) sample_index: u32) -> FragmentOutput1 {
        var out: FragmentOutput1;
        out.location_0 ^= vec4u(u32(override3));
        out.location_0 >>= textureDimensions(tex1, reverseBits(unconst_i32(206623549))).grrg;
        return out;
      }
      `, }
       );
        let pipelineLayout1 = device0.createPipelineLayout({
      bindGroupLayouts: [veryExplicitBindGroupLayout0]}
       );
        let pipeline0 = device0.createRenderPipeline({
         layout: pipelineLayout1,   fragment: {
        module: shaderModule1,   constants: {
    override3: 1}
     ,   targets: [{
    format: 'r16uint', writeMask: GPUColorWrite.BLUE | GPUColorWrite.GREEN | GPUColorWrite.RED}
     ], }
      ,   vertex: {
          module: shaderModule0,     constants: {
    }
     ,     buffers: [       {
             arrayStride: 92,         attributes: [           {
   format: 'uint16x4', offset: 0, shaderLocation: 9}
    ,           {
   format: 'snorm8x2', offset: 0, shaderLocation: 12}
    ,           {
   format: 'float32', offset: 16, shaderLocation: 0}
    ,           {
   format: 'unorm16x4', offset: 16, shaderLocation: 8}
    ,           {
   format: 'sint32x2', offset: 0, shaderLocation: 4}
    ,           {
   format: 'snorm16x4', offset: 12, shaderLocation: 5}
    ,         ],       }
     ,     ],   }
      , }
       );
// END
await device0.queue.onSubmittedWorkDone();
}

onload = async () => {
  try {
  let sharedScript = document.querySelector('#shared').textContent;

  let workers = [

  ];
  let promises = [ window0(), window1(), window2() ];
  log('promises created');
  let results = await Promise.allSettled(promises);
  for (let result of results) {
    if (result.status === 'rejected') { throw result.reason; }
  }
  log('the end')
  log(location);
  } catch (e) {
    log('error');
    log(e);
    log(e[Symbol.toStringTag]);
    log(e.stack);
    if (e instanceof GPUPipelineError) {
      log(`${e} - ${e.reason}`);
      
    } else if (e instanceof DOMException) {
      if (e.name === 'OperationError') {
      log(e.message);
      
      } else if (e.name === 'InvalidStateError') {
      } else {
        log(e);
        
      }
    } else if (e instanceof GPUValidationError) {
      
    } else if (e instanceof GPUOutOfMemoryError) {
      
    } else if (e instanceof TypeError) {
      log(e);
      
    } else {
      log('unexpected error type');
      log(e);
      
    }
  }
  console.log('Pass')
  globalThis.testRunner?.dumpAsText();
  globalThis.testRunner?.notifyDone();
};
</script>
