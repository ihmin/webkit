<!-- webkit-test-runner [ enableMetalShaderValidation=true ] -->
<style>
  :root { background: #102030e0; color: #99ddbbcc; font-size: 15px; }
</style>
<script>
globalThis.testRunner?.dumpAsText();
globalThis.testRunner?.waitUntilDone();

async function window0() {
    let adapter0 = await navigator.gpu.requestAdapter({powerPreference: 'low-power'});
    let device0 = await adapter0.requestDevice({
      defaultQueue: {},
      requiredLimits: {
        maxStorageBufferBindingSize: 165935735,
        maxStorageTexturesPerShaderStage: 4,
        maxUniformBufferBindingSize: 2362218,
        maxUniformBuffersPerShaderStage: 12,
      },
    });
    let videoFrame1 = new VideoFrame(new ArrayBuffer(16), {
        codedWidth: 2,
        codedHeight: 2,
        format: 'BGRA',
        timestamp: 0,
        colorSpace: {
            fullRange: true,
            matrix: 'unspecified',
            primaries: 'film',
            transfer: 'smpte170m'
        }
    });
    let shaderModule1 = device0.createShaderModule({
    code: `
  requires unrestricted_pointer_parameters;
  enable f16;

  fn unconst_i32(v: i32) -> i32 { return v; }
  fn unconst_u32(v: u32) -> u32 { return v; }

  @group(0) @binding(150) var et2: texture_external;
  @group(0) @binding(332) var<storage, read_write> buffer3: T0;

  @group(1) @binding(150) var et3: texture_external;
  @group(1) @binding(332) var<storage, read_write> buffer4: array<T3>;

  var<private> vp2: array<array<u32, 1>, 24>;

  struct T0 { @size(28) f0: u32, }
  struct T1 { @size(28) f0: array<array<atomic<i32>, 1>, 1>, }
  struct T3 { f0: T1, }

  @compute @workgroup_size(1, 1, 1) fn compute2() {
    buffer3 = T0(u32(atomicLoad(&(*&buffer4)[595582966].f0.f0[0][0])));
    for (var jj20=0u; jj20<26; jj20++) { 
      vp2[jj20][unconst_u32(0)] = u32(atomicExchange(&buffer4[arrayLength(&buffer4)].f0.f0[0][unconst_u32(0)], 0));
    }
    _ = et3;
    _ = et2;
  }
 `, }
     );
    let buffer7 = device0.createBuffer({
        size: 270,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.UNIFORM | GPUBufferUsage.VERTEX
    });
    let pipeline1 = device0.createComputePipeline({
        layout: 'auto',
        compute: {
            module: shaderModule1,
            constants: {
            }
        }
    });
    let externalTexture3 = device0.importExternalTexture({
        source: videoFrame1,
        colorSpace: 'srgb'
    });
    let autogeneratedBindGroupLayout1 = pipeline1.getBindGroupLayout(1);
    let commandEncoder2 = device0.createCommandEncoder();
    let computePassEncoder8 = commandEncoder2.beginComputePass();
    computePassEncoder8.setPipeline(pipeline1);
    let buffer17 = device0.createBuffer({
        size: 60,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE
    });
    let autogeneratedBindGroupLayout5 = pipeline1.getBindGroupLayout(0);
    let bindGroup17 = device0.createBindGroup({
        layout: autogeneratedBindGroupLayout1,
        entries: [{
            binding: 332,
            resource: {
                buffer: buffer17
            }
        }, {
            binding: 150,
            resource: externalTexture3
        }],
    });
    let bindGroup18 = device0.createBindGroup({
        layout: autogeneratedBindGroupLayout5,
        entries: [{
            binding: 150,
            resource: externalTexture3
        }, {
            binding: 332,
            resource: {
                buffer: buffer7,
                size: 48
            }
        }],
    });
    computePassEncoder8.setBindGroup(0, bindGroup17, new Uint32Array(1214), 774, 0);
    computePassEncoder8.setBindGroup(1, bindGroup18);
    computePassEncoder8.dispatchWorkgroups(2);
    computePassEncoder8.end();
    let commandBuffer1 = commandEncoder2.finish();
    device0.queue.submit([commandBuffer1]);
    await device0.queue.onSubmittedWorkDone();
    videoFrame1.close();
}

onload = async () => {
  try {
  let promises = [ window0() ];
  console.log('promises created');
  let results = await Promise.allSettled(promises);
  for (let result of results) {
    if (result.status === 'rejected') { throw result.reason; }
  }
  console.log('the end')
  console.log(location);
  } catch (e) {
    console.log('error');
    console.log(e);
    console.log(e[Symbol.toStringTag]);
    console.log(e.stack);
    if (e instanceof GPUPipelineError) {
      console.log(`${e} - ${e.reason}`);
      
    } else if (e instanceof DOMException) {
      if (e.name === 'OperationError') {
      console.log(e.message);
      
      } else if (e.name === 'InvalidStateError') {
      } else {
        console.log(e);
        
      }
    } else if (e instanceof GPUValidationError) {
      
    } else if (e instanceof GPUOutOfMemoryError) {
      
    } else if (e instanceof TypeError) {
      console.log(e);
      
    } else {
      console.log('unexpected error type');
      console.log(e);
      
    }
  }
  globalThis.testRunner?.notifyDone();
};
</script>
